<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随风来易随风去</title>
  
  
  <link href="http://jiangbk.top/atom.xml" rel="self"/>
  
  <link href="http://jiangbk.top/"/>
  <updated>2021-02-17T06:21:31.189Z</updated>
  <id>http://jiangbk.top/</id>
  
  <author>
    <name>guojiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github学习</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Github%20%E5%AD%A6%E4%B9%A0/Github%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Github%20%E5%AD%A6%E4%B9%A0/Github%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-02-17T06:19:36.000Z</published>
    <updated>2021-02-17T06:21:31.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github学习"><a href="#Github学习" class="headerlink" title="Github学习"></a>Github学习</h1><p>​    使用 Github 优秀框架 + 源码 提升自己</p><h2 id="常用词含义"><a href="#常用词含义" class="headerlink" title="常用词含义"></a>常用词含义</h2><ul><li>watch：会持续收到该项目的动态</li><li>fork：复制某个仓库到自己的 Github 仓库中</li><li>star：可以理解为点赞</li><li>clone：将项目下载至本地 [ git clone xxxx]</li><li>follow：关注你感兴趣的作者，会收到他们的动态</li></ul><hr><h2 id="in-关键字限制搜索范围"><a href="#in-关键字限制搜索范围" class="headerlink" title="in 关键字限制搜索范围"></a>in 关键字限制搜索范围</h2><p><strong>公式：</strong><code>XXX关键字 in:name 或 description 或 readme</code></p><ul><li>xxx in:name [ 项目名称 ] 含有XXX的</li><li>xxx in:description [ 项目描述 ] 含有XXX的</li><li>xxx in:readme [ 项目的readme文件 ] 中包含XXX的</li><li>组合使用<ul><li>xxx in:name,readme 项目的名称和 readme 中包含 xxx 的</li></ul></li></ul><hr><h2 id="stars-或-fork-数量关键字查找"><a href="#stars-或-fork-数量关键字查找" class="headerlink" title="stars 或 fork 数量关键字查找"></a>stars 或 fork 数量关键字查找</h2><p><strong>公式：</strong></p><ul><li><code>xxx关键字 stars 通配符</code> :&gt; 或者 :&gt;=</li><li>区间范围数字： <code>stars:数字1..数字2</code></li></ul><p><strong>案例:</strong></p><ul><li><p>查找 stars 数大于等于 5000 的 Springboot 项目：springboot stars:&gt;=5000</p></li><li><p>查找 forks 数在 1000~2000 之间的 springboot 项目：springboot forks:1000..5000</p></li><li><p>组合使用</p><ul><li>查找 star 大于1000，fork 数在 500 到 1000：<code>springboot stars:&gt;1000 forks:500..1000</code></li></ul></li></ul><hr><h2 id="awesome-加强搜索"><a href="#awesome-加强搜索" class="headerlink" title="awesome 加强搜索"></a>awesome 加强搜索</h2><p><strong>公式：</strong> <code>awesome 关键字</code>：</p><p>awesome 系列，一般用来收集 [ 学习、工具、书籍类相关的项目 ]</p><ul><li>搜索优秀的 redis 相关的项目，包括框架，教程等 awesome redis</li></ul><hr><h2 id="高亮显示某行代码"><a href="#高亮显示某行代码" class="headerlink" title="高亮显示某行代码"></a>高亮显示某行代码</h2><ul><li>一行：地址后面紧跟 #L10<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13</code></li></ul></li><li>多行：地址后面紧跟 #Lx - #Ln<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13-L30</code></li></ul></li></ul><hr><h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><ul><li>使用英文字母 <code>t</code> ,开启项目内搜索</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217142128.png"></p><hr><h2 id="搜索某个地区内的大佬"><a href="#搜索某个地区内的大佬" class="headerlink" title="搜索某个地区内的大佬"></a>搜索某个地区内的大佬</h2><ul><li>location：地区</li><li>language：语言</li><li>例如：<code>location:beijing language:java</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Github学习&quot;&gt;&lt;a href=&quot;#Github学习&quot; class=&quot;headerlink&quot; title=&quot;Github学习&quot;&gt;&lt;/a&gt;Github学习&lt;/h1&gt;&lt;p&gt;​    使用 Github 优秀框架 + 源码 提升自己&lt;/p&gt;
&lt;h2 id=&quot;常用词含</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="github" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/github/"/>
    
    
    <category term="Github" scheme="http://jiangbk.top/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>11_死锁编码及快速定位</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/11-%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/11-%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/</id>
    <published>2021-02-17T06:13:30.000Z</published>
    <updated>2021-02-17T06:14:12.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-死锁编码及快速定位"><a href="#11-死锁编码及快速定位" class="headerlink" title="11_死锁编码及快速定位"></a>11_死锁编码及快速定位</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141338.png"></p><h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><ul><li>系统资源不足</li><li>进程运行推进的顺序不对</li><li>资源分配不当</li></ul><h2 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h2><ul><li>互斥<ul><li>解决方法：把互斥的共享资源封装成可同时访问</li></ul></li><li>占有且等待<ul><li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li></ul></li><li>非抢占式<ul><li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li></ul></li><li>循环等待<ul><li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li></ul></li></ul><h2 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************** 资源类 **************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有锁：&quot;</span> + lockA);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 等待获取锁&quot;</span> + lockB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 已获得锁&quot;</span> + lockB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************** 测试类 ****************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA,lockB),<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB,lockA),<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，main线程无法结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t2 自己持有锁：lockB</span><br><span class="line">t1 自己持有锁：lockA</span><br><span class="line">t1 等待获取锁lockB</span><br><span class="line">t2 等待获取锁lockA</span><br></pre></td></tr></table></figure><hr><h2 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用 jps 命令查看运行的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141339.png"></p><p>在使用 jstack 查看堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack  7560   # 后面参数是 jps输出的该类的pid</span><br></pre></td></tr></table></figure><p>得到的结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141340.png"></p><p>通过查看最后一行，我们看到 Found 1 deadlock，即存在一个死锁</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;11-死锁编码及快速定位&quot;&gt;&lt;a href=&quot;#11-死锁编码及快速定位&quot; class=&quot;headerlink&quot; title=&quot;11_死锁编码及快速定位&quot;&gt;&lt;/a&gt;11_死锁编码及快速定位&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>10_线程池</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/10-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/10-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-02-17T06:12:04.000Z</published>
    <updated>2021-02-17T06:13:09.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10_线程池"></a>10_线程池</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现 Callable 接口</p><ul><li>实现 Runnable 接口</li><li>实现 Callable 接口</li><li>实例化 Thread 类</li><li>使用 线程池 获取</li></ul><hr><h2 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h2><blockquote><p>Callable 接口，是一种让线程执行完成后，<code>[ 能够返回结果的 ]</code></p></blockquote><p>在说到 Callable 接口的时候，我们不得不提到 Runnable 接口 [  两种写法 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 实现Runnable接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***** 实现 Runnable 接口*******&#x2F;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(&quot;线程方法体&quot;);</span><br><span class="line">&#125;,&quot;t1&quot;).start();</span><br></pre></td></tr></table></figure><p>实现 Runnable 接口的时候，需要重写 run 方法，也就是线程在启动的时候，会自动调用的方法</p><hr><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>同理，我们实现 Callable 接口，也需要实现 call 方法，但是这个时候我们还需要有返回值，<font color='red'>这个Callable 接口的应用场景一般就在于批处理业务，比如 [ 转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败 ]</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Callable有返回值</span><br><span class="line"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyThread2 implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;come in Callable&quot;);</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要做的就是通过 Thread 线程， 将 MyThread2 实现 Callable 接口的类包装起来</p><hr><p>这里需要用到的是 FutureTask 类，他实现了 Runnable 接口，并且还需要传递一个实现 Callable 接口的类作为构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span><br><span class="line">&#x2F;&#x2F; 这里通过了FutureTask接触了Callable接口</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br></pre></td></tr></table></figure><p>然后在用 Thread 进行实例化，传入实现 Runnabnle 接口的 FutureTask 的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 &#x3D; new Thread(futureTask, &quot;aaa&quot;);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>最后通过 utureTask.get() 获取到返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出FutureTask的返回值</span><br><span class="line">System.out.println(&quot;result FutureTask &quot; + futureTask.get());</span><br></pre></td></tr></table></figure><hr><p>这就相当于原来我们的方式是 main 方法一条龙之心，后面在引入 Callable 后，对于执行比较久的线程，可以单独新开一个线程进行执行，最后在进行汇总输出</p><p>最后需要注意的是： 最后获得 Callable 线程的计算结果，如果没有计算完成就要去强求获得，会导致阻塞，直到计算完成</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141226.png"></p><p>就是说： <font color='red'>[  futureTask.get() 需要放在最后执行，这样不会导致主线程阻塞  ]</font></p><hr><p>也可以使用下面算法，使用类似于 [ 自旋锁 ] 的方式来进行判断是否运行完毕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断futureTask是否计算完成</span><br><span class="line">while(!futureTask.isDone()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result FutureTask &quot; + futureTask.get());</span><br></pre></td></tr></table></figure><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个 FutureTask 的时候，只会计算一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启两个线程计算futureTask</span><br><span class="line">new Thread(futureTask, &quot;AAA&quot;).start();</span><br><span class="line">new Thread(futureTask, &quot;BBB&quot;).start();</span><br></pre></td></tr></table></figure><p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要定义两个 futureTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask2 &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启两个线程计算futureTask</span><br><span class="line">new Thread(futureTask, &quot;AAA&quot;).start();</span><br><span class="line"></span><br><span class="line">new Thread(futureTask2, &quot;BBB&quot;).start();</span><br></pre></td></tr></table></figure><hr><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：[ 线程复用、控制最大并发数、管理线程 ]</p><p>线程池中的任务是放入到阻塞队列中的</p><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>多核处理的好处是：[ 省略的上下文的切换开销 ]</p><p>原来我们实例化对象的时候，是使用 new 关键字进行创建，到了 Spring 后，我们学了 IOC 依赖注入，发现Spring 帮我们将对象已经加载到了 Spring 容器中，只需要通过 @Autowrite 注解，就能够自动注入，从而使用</p><p>因此使用多线程有下列的好处</p><ul><li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就立即执行</li><li>提高线程的可管理性。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java 中线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor 这几个类。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141227.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141228.png"></p><hr><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul><li>Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池<ul><li>执行长期的任务，性能好很多</li><li>创建一个 [ 定长线程池 ]，可控制线程数最大并发数，超出的线程会在队列中等待</li></ul></li><li>Executors.newSingleThreadExecutor：创建一个只有 1 个线程的 [ 单线程池 ]<ul><li>一个任务一个任务执行的场景</li><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul></li><li>Executors.newCacheThreadPool(); 创建一个 [ 可扩容的线程池 ]<ul><li>执行很多短期异步的小程序或者负载教轻的服务器</li><li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li></ul></li><li>Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li></ul><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>首先我们需要使用  [ Executors 工具类 ]，进行创建线程池，这里创建了一个拥有 5 个线程的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一池5个处理线程 [ 用池化技术，一定要记得关闭 ]</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个只有一个线程的线程池</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newCacheThreadPool();</span><br></pre></td></tr></table></figure><p>然后我们执行下面的的应用场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br></pre></td></tr></table></figure><p>我们需要使用 [ threadPool.execute  ] 执行业务，execute 需要传入一个实现了 Runnable 接口的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t 给用户办理业务&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们使用完毕后关闭线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Array  Arrays(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Collection Collections(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Executor Executors(辅助工具类)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-5 给用户:4 办理业务</span><br><span class="line">pool-1-thread-1 给用户:5 办理业务</span><br><span class="line">pool-1-thread-4 给用户:3 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-3 给用户:2 办理业务</span><br><span class="line">pool-1-thread-2 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:8 办理业务</span><br><span class="line">pool-1-thread-1 给用户:7 办理业务</span><br><span class="line">pool-1-thread-5 给用户:6 办理业务</span><br></pre></td></tr></table></figure><p>我们能够看到，一共有 5 个线程，在给 10 个用户办理业务</p><hr><h5 id="创建周期性执行任务的线程池"><a href="#创建周期性执行任务的线程池" class="headerlink" title="创建周期性执行任务的线程池"></a>创建周期性执行任务的线程池</h5><p>Executors.newScheduledThreadPool(int corePoolSize)：</p><p><strong>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</strong></p><p>底层使用 ScheduledThreadPoolExecutor 来实现 ScheduledThreadPoolExecutor 为ThreadPoolExecutor子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* delay：延时执行任务的时间</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                     long delay,</span><br><span class="line">                                     TimeUnit unit)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws IllegalArgumentException   &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* initialDelay 第一次执行任务延迟时间</span><br><span class="line">* period 连续执行任务之间的周期，从上一个任务开始执行时计算延迟多少开始执行下一个任务，但是还会等上一个任务结束之后。</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                long initialDelay,</span><br><span class="line">                                                long period,</span><br><span class="line">                                                TimeUnit unit)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws IllegalArgumentException   &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* initialDelay 第一次执行任务延迟时间</span><br><span class="line">* delay：连续执行任务之间的周期，从上一个任务全部执行完成时计算延迟多少开始执行下一个任务</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                   long initialDelay,</span><br><span class="line">                                                   long delay,</span><br><span class="line">                                                   TimeUnit unit)</span><br></pre></td></tr></table></figure><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>我们通过查看源码，点击了 Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool 能够发现底层都是使用了 ThreadPoolExecutor</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141229.png"></p><p>我们可以看到线程池的内部，还使用到了 LinkedBlockingQueue 链表阻塞队列</p><p>同时在查看 Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue 阻塞队列</p><p>最后查看一下，完整的三个创建线程的方法</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141230.png"></p><h4 id="线程池的重要参数"><a href="#线程池的重要参数" class="headerlink" title="线程池的重要参数"></a>线程池的重要参数</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141231.png"></p><p>线程池在创建的时候，一共有7大参数</p><ul><li>corePoolSize：[ 核心线程数 ]，线程池中的常驻核心线程数<ul><li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li><li>当线程池中的线程数目达到 corePoolSize 后，就会把到达的队列放到缓存队列中</li></ul></li><li>maximumPoolSize：线程池能够容纳同时执行的 [ 最大线程数 ]，此值必须大于等于1、<ul><li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li></ul></li><li>keepAliveTime：多余的 [ 空闲线程存活时间 ]<ul><li>当线程池数量超过 corePoolSiz e时，当空闲时间达到 keepAliveTime 值时，多余的空闲线程会被销毁，直到只剩下 corePoolSize 个线程为止</li><li>默认情况下，只有当线程池中的线程数大于 corePoolSize 时，keepAliveTime 才会起作用</li></ul></li><li>unit：keepAliveTime 的单位</li><li>workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）<ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul></li><li>threadFactory：表示生成线程池中工作线程的 [ 线程工厂  ]，用于创建线程池 一般用默认即可</li><li>handler：[ 拒绝策略 ] ，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的 Runnable 的策略</li></ul><p>今日值班窗口有 2 个，现在 2 个窗口都有人在办理业余，此时又进来 3 个客人需要办理业务，他们就需要去等待区 [ 阻塞队列 ]等待</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141232.png"></p><p>此时，又进来 3 个客人需要办理业务，但当值窗口已满，等待区已满，就需要 加班窗口 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141233.png"></p><p>今天 人特别多，不知为何，又来了 2 个人，课堂经理就需要到门口，对来的进行阻拦了，因为此时网点已容不下更多人</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141234.png"></p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>以下所有拒绝策略都实现了 RejectedExecutionHandle r接口</p><ul><li>AbortPolicy：默认，直接抛出 RejectedExcutionException 异常，阻止系统正常运行</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><hr><h4 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h4><h5 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141235.png"></p><p><strong>文字说明：</strong></p><ol><li>在创建了线程池后，等待提交过来的任务请求</li><li>当调用 execute() 方法添加一个请求任务时，线程池会做出如下判断<ol><li>如果正在运行的线程池数量小于 corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入 [ 阻塞队列 ]</li><li>如果这时候队列满了，并且正在运行的线程数量还小于 maximumPoolSize，那么还是创建非核心线程 like 运行这个任务；</li><li>如果队列满了并且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和 [ 拒绝策略 ]来执行</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做操作一定的时间 (keepAliveTime) 时，线程池会判断：<ol><li>如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉</li><li>所以线程池的所有任务完成后，它会最终收缩到 corePoolSize 的大小</li></ol></li></ol><p><strong>[ 以顾客去银行办理业务为例，谈谈线程池的底层工作原理：]</strong></p><ol><li>最开始假设来了两个顾客，因为 corePoolSize为 2，因此这两个顾客直接能够去窗口办理</li><li>后面又来了三个顾客，因为 corePool 已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li><li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li><li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li></ol><h4 id="为什么不用默认创建的线程池？"><a href="#为什么不用默认创建的线程池？" class="headerlink" title="为什么不用默认创建的线程池？"></a>为什么不用默认创建的线程池？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程池创建的方法有：[ 固定数的，单一的，可变的 ] ，那么在实际开发中，应该使用哪个？</span><br><span class="line"></span><br><span class="line">答：我们一个都不用，在生产环境中是使用自己自定义的</span><br><span class="line"></span><br><span class="line">为什么不用Executors中JDK提供的？</span><br></pre></td></tr></table></figure><p>根据阿里巴巴手册：并发控制这章</p><ul><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程<ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li></ul></li><li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutors 的方式，这样的处理方式让写的同学 [ 更加明确线程池的运行规则，规避资源耗尽的风险 ]<ul><li>Executors 返回的线程池对象弊端如下：<ul><li>FixedThreadPool 和 SingleThreadPool：<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</li></ul></li><li>CacheThreadPool 和 ScheduledThreadPool<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li></ul></li></ul></li></ul></li></ul><hr><h3 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h3><h4 id="采用默认拒绝策略"><a href="#采用默认拒绝策略" class="headerlink" title="采用默认拒绝策略"></a>采用默认拒绝策略</h4><p>从上面我们知道，因为默认的 Executors 创建的线程池，底层都是使用 LinkBlockingQueue 作为阻塞队列的，而LinkBlockingQueue 虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有 20 多亿，可以相当是无界的了，因此我们要使用 ThreadPoolExecutor 自己手动创建线程池，然后指定阻塞队列的大小</p><p>下面我们创建了一个 核心线程数为 2，最大线程数为 5，并且阻塞队列数为 3 的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写线程池</span></span><br><span class="line"><span class="keyword">final</span> Integer corePoolSize = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> Integer maximumPoolSize = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">final</span> Long keepAliveTime = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span></span><br><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    corePoolSize,</span><br><span class="line">    maximumPoolSize,</span><br><span class="line">    keepAliveTime,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure><p>然后使用 for 循环，模拟 10 个用户来进行请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 循环十次，模拟业务办理，让5个线程处理这10个请求</span><br><span class="line">      for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">          final int tempInt &#x3D; i;</span><br><span class="line">          executorService.execute(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + &quot;\t 给用户:&quot; + tempInt + &quot; 办理业务&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">      executorService.shutdown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是在用户执行到第 9 个的时候，触发了异常，程序中断 [ 最大只能运行 8 个 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task threadPoll.MyThreadPoolExecutorsDemo$$Lambda$14&#x2F;0x0000000840064c40@5b6f7412 rejected from java.util.concurrent.ThreadPoolExecutor@27973e9b[Running, pool size &#x3D; 5, active threads &#x3D; 5, queued tasks &#x3D; 3, completed tasks &#x3D; 0]</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)</span><br><span class="line">at threadPoll.MyThreadPoolExecutorsDemo.main(MyThreadPoolExecutorsDemo.java:32)</span><br><span class="line">pool-1-thread-5 给用户:8 办理业务</span><br><span class="line">pool-1-thread-3 给用户:6 办理业务</span><br><span class="line">pool-1-thread-1 给用户:1 办理业务</span><br><span class="line">pool-1-thread-2 给用户:2 办理业务</span><br><span class="line">pool-1-thread-4 给用户:7 办理业务</span><br><span class="line">pool-1-thread-2 给用户:5 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:3 办理业务</span><br></pre></td></tr></table></figure><p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的 AbortPolicy，也就是抛异常的</p><p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 = 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p><h4 id="采用CallerRunsPolicy拒绝策略"><a href="#采用CallerRunsPolicy拒绝策略" class="headerlink" title="采用CallerRunsPolicy拒绝策略"></a>采用CallerRunsPolicy拒绝策略</h4><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">main 给用户:8 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-3 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:3 办理业务</span><br><span class="line">pool-1-thread-1 给用户:2 办理业务</span><br></pre></td></tr></table></figure><p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p><h4 id="采用-DiscardPolicy-拒绝策略"><a href="#采用-DiscardPolicy-拒绝策略" class="headerlink" title="采用 DiscardPolicy 拒绝策略"></a>采用 DiscardPolicy 拒绝策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-1 给用户:2 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-3 给用户:3 办理业务</span><br></pre></td></tr></table></figure><p>采用 DiscardPolicy 拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p><h4 id="采用DiscardOldestPolicy拒绝策略"><a href="#采用DiscardOldestPolicy拒绝策略" class="headerlink" title="采用DiscardOldestPolicy拒绝策略"></a>采用DiscardOldestPolicy拒绝策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-1 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:8 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br></pre></td></tr></table></figure><p>这个策略和刚刚差不多，会把最久的队列中的任务替换掉</p><hr><h3 id="线程池的合理参数"><a href="#线程池的合理参数" class="headerlink" title="线程池的合理参数"></a>线程池的合理参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产环境中如何配置 corePoolSize 和 maximumPoolSize</span><br></pre></td></tr></table></figure><p>这个是根据具体业务来配置的，分为 CPU 密集型和 IO 密集型</p><ul><li>CPU密集型</li></ul><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p><p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p><p>CPU密集型任务 [ 配置尽可能少的线程数量 ] ：</p><p><strong>一般公式：</strong>CPU核数 + 1个线程数</p><ul><li>IO密集型</li></ul><p>由于 IO 密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p><p>IO 密集型，即该任务需要大量的 IO 操作，即大量的阻塞</p><p>在单线程上运行 IO 密集型的任务会导致浪费大量的 CPU 运算能力花费在等待上</p><p>所以 IO 密集型任务中使用多线程可以大大的加速程序的运行，即使在单核 CPU 上，这种加速主要就是利用了被浪费掉的阻塞时间。</p><p>IO密集时，大部分线程都被阻塞，故需要 [ 多配置线程数 ]：</p><p>参考公式：CPU核数 / (1 - 阻塞系数)   [ 阻塞系数在0.8 ~ 0.9左右 ] </p><p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;10-线程池&quot;&gt;&lt;a href=&quot;#10-线程池&quot; class=&quot;headerlink&quot; title=&quot;10_线程池&quot;&gt;&lt;/a&gt;10_线程池&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
    <category term="线程池" scheme="http://jiangbk.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>9_Synchronized 和 Lock 的区别与好处</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/9-Synchronized-%E5%92%8C-Lock-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/9-Synchronized-%E5%92%8C-Lock-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/</id>
    <published>2021-02-17T06:11:11.000Z</published>
    <updated>2021-02-17T06:11:41.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Synchronized-和-Lock-的区别与好处"><a href="#9-Synchronized-和-Lock-的区别与好处" class="headerlink" title="9_Synchronized 和 Lock 的区别与好处"></a>9_Synchronized 和 Lock 的区别与好处</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早期的时候我们解决  [ 生产者消费者问题  ]对线程的主要操作为：</p><ul><li>synchronized  👉   [ wait ]  [ notify / notifyAll ]</li></ul><p>然后后面出现了替代方案</p><ul><li>lock   👉  [ await ]  [ singal / singalAll ]</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141037.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="synchronized-和-lock-有什么区别？用新的-lock-有什么好处？举例说明"><a href="#synchronized-和-lock-有什么区别？用新的-lock-有什么好处？举例说明" class="headerlink" title="synchronized  和  lock 有什么区别？用新的 lock 有什么好处？举例说明"></a>synchronized  和  lock 有什么区别？用新的 lock 有什么好处？举例说明</h3><p>1）synchronized 属于JVM 层面，属于 java 的关键字</p><ul><li> monitorenter（底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象 只能在同步块或者方法中才能调用 wait/ notify 等方法）</li><li> Lock 是具体类（java.util.concurrent.locks.Lock）是 api 层面的锁</li></ul><p>2）使用方法：</p><ul><li>synchronized：不需要用户去手动释放锁，当 synchronized 代码执行后，系统会自动让线程释放对锁的占用</li><li>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要 lock() 和 unlock() 配置 try catch / finally语句来完成</li></ul><p>3）等待是否中断</p><ul><li>synchronized：不可中断，除非抛出异常或者正常运行完成</li><li>ReentrantLock：可中断，可以设置超时方法<ul><li>设置超时方法，trylock(long timeout, TimeUnit unit)</li><li>通过 lock.lockInterruptibly() 可以实现中断</li></ul></li></ul><p>4）加锁是否公平</p><ul><li>synchronized：非公平锁</li><li>ReentrantLock：默认非公平锁，构造函数可以传递 boolean 值，true 为公平锁，false 为非公平锁</li></ul><p>5）锁绑定多个条件 Condition</p><ul><li>synchronized：没有，要么随机，要么全部唤醒</li><li>ReentrantLock：用来实现 [ 分组唤醒需要唤醒的线程 ]，可以精确唤醒，而不是像 synchronized 那样，要么随机，要么全部唤醒</li></ul><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>针对刚刚提到的区别的第 5 条，我们有下面这样的一个场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目：多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br><span class="line">紧接着</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br><span class="line">..</span><br><span class="line">来10轮</span><br></pre></td></tr></table></figure><p>我们会发现，这样的场景在使用 synchronized 来完成的话，会非常的困难，但是使用 lock 就非常方便了</p><p>也就是我们需要实现一个链式唤醒的操作</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141052.png"></p><p>当 A 线程执行完后，B 线程才能执行，然后 B 线程执行完成后，C 线程才执行</p><p>首先我们需要创建一个重入锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个重入锁</span><br><span class="line">private Lock lock &#x3D; new ReentrantLock();</span><br></pre></td></tr></table></figure><p>然后定义三个条件，也可以称为 [ 锁的钥匙 ]，通过它就可以获取到锁，进入到方法里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这三个相当于备用钥匙</span><br><span class="line">private Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line">private Condition condition2 &#x3D; lock.newCondition();</span><br><span class="line">private Condition condition3 &#x3D; lock.newCondition();</span><br></pre></td></tr></table></figure><p>然后开始记住锁的三部曲： [ 判断 干活 唤醒 ]</p><p>这里的判断，为了 [ 避免虚假唤醒，一定要采用 while ]</p><p>干活就是把需要的内容，打印出来</p><p>唤醒的话，就是修改资源类的值，然后精准唤醒线程进行干活：这里A 唤醒B， B唤醒C，C又唤醒A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知B线程执行）</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************* 资源类 *******************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A 1   B 2   c 3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建一个重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这三个相当于备用钥匙</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知B线程执行）</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知C线程执行）</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知C线程执行）</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通知1号去干活了</span></span><br><span class="line">            condition1.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************* 测试类 *******************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    shareResource.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">A 10</span><br><span class="line">A 11</span><br><span class="line">A 12</span><br><span class="line">A 13</span><br><span class="line">A 14</span><br><span class="line">B 20</span><br><span class="line">B 21</span><br><span class="line">B 22</span><br><span class="line">B 23</span><br><span class="line">B 24</span><br><span class="line">B 25</span><br><span class="line">B 26</span><br><span class="line">B 27</span><br><span class="line">B 28</span><br><span class="line">B 29</span><br><span class="line">C 30</span><br><span class="line">C 31</span><br><span class="line">C 32</span><br><span class="line">C 33</span><br><span class="line">C 34</span><br><span class="line">C 35</span><br><span class="line">C 36</span><br><span class="line">C 37</span><br><span class="line">C 38</span><br><span class="line">C 39</span><br><span class="line">C 310</span><br><span class="line">C 311</span><br><span class="line">C 312</span><br><span class="line">C 313</span><br><span class="line">C 314</span><br><span class="line">.....</span><br><span class="line">执行 10 轮</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9-Synchronized-和-Lock-的区别与好处&quot;&gt;&lt;a href=&quot;#9-Synchronized-和-Lock-的区别与好处&quot; class=&quot;headerlink&quot; title=&quot;9_Synchronized 和 Lock 的区别与好处&quot;&gt;&lt;/a&gt;9_</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
    <category term="Synchronized" scheme="http://jiangbk.top/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>8_ 阻塞队列</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/8-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/8-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2021-02-17T06:09:56.000Z</published>
    <updated>2021-02-17T06:10:18.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-阻塞队列"><a href="#8-阻塞队列" class="headerlink" title="8_ 阻塞队列"></a>8_ 阻塞队列</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭 [ FIFO ]</p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140908.png"></p><p>线程1 通过 Put 往阻塞队列中添加元素，而线程 2 通过 Take 从阻塞队列中移除元素：</p><ul><li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</li><li>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</li></ul><p>[  类比 1 ]：</p><ul><li>当蛋糕店的柜子空的时候，无法从柜子里面获取蛋糕</li><li>当蛋糕店的柜子满的时候，无法继续向柜子里面添加蛋糕了</li></ul><p>[  即 ]：</p><ul><li>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</li><li>试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</li></ul><hr><h3 id="为什么要用-？"><a href="#为什么要用-？" class="headerlink" title="为什么要用 ？"></a>为什么要用 ？</h3><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p><p>在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</p><h4 id="为什么需要-BlockingQueue"><a href="#为什么需要-BlockingQueue" class="headerlink" title="为什么需要 BlockingQueue"></a>为什么需要 BlockingQueue</h4><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都帮你一手包办了</p><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度 [ 减少程序员的负担 ：不需要手动阻塞或者唤醒 ] 。</p><hr><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ 面试 ]</span><br><span class="line">&#x2F;&#x2F; 你用过List集合类</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ArrayList集合类熟悉么？</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 还用过 CopyOnWriteList  和 BlockingQueue</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140924.png"></p><p>BlockingQueue 阻塞队列是属于一个接口，底下有七个实现类：</p><ul><li><strong>ArrayBlockQueue：</strong>由数组结构组成的有界阻塞队列</li><li><strong>LinkedBlockingQueue：</strong>由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<ul><li>[ 有界，但是界限非常大，相当于无界，可以当成无界 ]</li></ul></li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li><strong>SynchronousQueue：</strong>不存储元素的阻塞队列，也即单个元素的队列<ul><li>[ 生产一个，消费一个，不存储元素，不消费不生产 ]</li></ul></li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul><p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p><hr><h3 id="BlockingQueue-核心方法"><a href="#BlockingQueue-核心方法" class="headerlink" title="BlockingQueue 核心方法"></a>BlockingQueue 核心方法</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140931.png"></p><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException：Queue full                             当阻塞队列空时：再往队列中 remove 移除元素，会抛出： NoSuchException</th></tr></thead><tbody><tr><td>特殊性</td><td>插入方法，成功 true，失败 false 移除方法：成功返回出队列元素，队列没有就返回空</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到 put 数据 or 响应中断退出， 当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列可用。</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h5 id="抛出异常组"><a href="#抛出异常组" class="headerlink" title="抛出异常组"></a>抛出异常组</h5><p>但执行 add 方法，向已经满的 ArrayBlockingQueue 中添加元素时候，会抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻塞队列，[ 需要填入默认值 ]</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.add(&quot;XXX&quot;));</span><br></pre></td></tr></table></figure><p>运行后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span><br><span class="line">at java.util.AbstractQueue.add(AbstractQueue.java:98)</span><br><span class="line">at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)</span><br><span class="line">at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:25)</span><br></pre></td></tr></table></figure><p>同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了 3 个值，但是取的时候，取了 4 次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻塞队列，[ 需要填入默认值 ]</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此时队列为空</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br></pre></td></tr></table></figure><p>那么出现异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br><span class="line">at java.util.AbstractQueue.remove(AbstractQueue.java:117)</span><br><span class="line">at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:30)</span><br></pre></td></tr></table></figure><h5 id="布尔类型组"><a href="#布尔类型组" class="headerlink" title="布尔类型组"></a>布尔类型组</h5><p>我们使用 offer 的方法，添加元素时候，如果阻塞队列满了后，会返回 false ，否者返回 true</p><p>同时在取的时候，如果队列已空，那么会返回 null  [ 避免了产生异常，叫停程序 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue blockingQueue &#x3D; new ArrayBlockingQueue(3);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">&#x2F;&#x2F;队列已满</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">&#x2F;&#x2F;队列已空</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h5 id="阻塞队列组"><a href="#阻塞队列组" class="headerlink" title="阻塞队列组"></a>阻塞队列组</h5><p>我们使用 put 的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒</p><p>一般在消息中间件，比如 RabbitMQ 中会使用到，因为需要 [ 保证消息百分百不丢失，因此只有让它阻塞 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">blockingQueue.put(&quot;a&quot;);</span><br><span class="line">blockingQueue.put(&quot;b&quot;);</span><br><span class="line">blockingQueue.put(&quot;c&quot;);</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br><span class="line"></span><br><span class="line">blockingQueue.take();</span><br></pre></td></tr></table></figure><p>同时使用 take 取消息的时候，如果内容不存在的时候，也会被阻塞，直到队列有元素时，才唤醒</p><p>[ 如果一直队列一直没有元素呢 ，让它一直阻塞吗 ？ ]</p><h5 id="不见不散组"><a href="#不见不散组" class="headerlink" title="不见不散组"></a>不见不散组</h5><p>在 offer( ) ， poll 的基础上 [  加时间  ]</p><p>使用 offer 插入的时候，需要指定时间，如果 2 秒还没有插入，那么就放弃插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;a&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;b&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;c&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">&#x2F;&#x2F;尝试加入元素，如果 2s 都没有成功，放弃，返回 false</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;d&quot;, 2L, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>同时 poll 取的时候也进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">&#x2F;&#x2F;尝试取元素,如果 2s 都未取到,返回 null</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>如果 2 秒内取不出来，那么就返回 null</p><p>[ 这组方法就更加灵活，使用较多 ]</p><hr><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 没有容量，与其他 BlockingQueue 不同，SynchronousQueue 是一个不存储元素的 BlockingQueue，每一个 put 操作必须等待一个 take 操作，否者不能继续添加元素</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p><p>生产的线程分别 put 了 A、B、C这三个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个[不储存元素的]阻塞队列</span><br><span class="line">BlockingQueue&lt;String&gt; synchronousQueue &#x3D; new SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put A&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;A&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put B&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put C&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;t1&quot;).start();</span><br></pre></td></tr></table></figure><p>消费线程使用 take，消费阻塞队列中的内容，并且每次消费前，都等待 5 秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">           </span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take A&quot;);</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take B&quot;);</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take C&quot;);</span><br><span class="line"></span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;, &quot;t2&quot;).start();</span><br></pre></td></tr></table></figure><p>最后结果输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t1 put A </span><br><span class="line">5秒后...</span><br><span class="line">t2 take A </span><br><span class="line"></span><br><span class="line">t1 put B </span><br><span class="line">5秒后...</span><br><span class="line">t2 take B </span><br><span class="line"></span><br><span class="line">t1 put C </span><br><span class="line">5秒后...</span><br><span class="line">t2 take C </span><br></pre></td></tr></table></figure><p>我们从最后的运行结果可以看出，每次 t1 线程向队列中添加阻塞队列添加元素后，t1 输入线程就会等待 t2 消费线程，t2 消费后，t2 处于挂起状态，等待 t1 在 存入，从而周而复始，形成 一存一取的状态 。</p><p>完整版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: SynchronousQueue使用演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-11-13 13:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个[不储存元素的]阻塞队列</span></span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put A&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put B&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put C&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take A&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h3><h4 id="生产者消费者模式-2-0"><a href="#生产者消费者模式-2-0" class="headerlink" title="生产者消费者模式 2.0"></a>生产者消费者模式 2.0</h4><p>一个初始值为 0 的变量，两个线程对其交替操作，一个加 1，一个减 1，来 5 轮</p><p>关于多线程的操作，我们需要记住下面几句</p><ul><li>线程 操作 资源类</li><li>判断 干活 通知</li><li>防止虚假唤醒机制</li></ul><p>我们下面实现一个简单的生产者消费者模式，首先有资源类 ShareData</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package blockingQueue;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: xj0927</span><br><span class="line"> * @Description: 资源类 [高内聚，低耦合：内聚指的是，一个空调，自身带有调节温度高低的方法]</span><br><span class="line"> * @Date Created in 2020-11-13 14:13</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ShareData &#123;</span><br><span class="line"></span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void increment()&#123;</span><br><span class="line">        &#x2F;&#x2F;同步代码块：加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;判断</span><br><span class="line">            while (number !&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F;等待：不能生产</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;干活</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通知：唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            &#x2F;&#x2F;释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void decrement()&#123;</span><br><span class="line">        &#x2F;&#x2F;同步代码块：加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;判断</span><br><span class="line">            while (number &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F;等待：不能消费</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;干活</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通知:唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有一个 number 变量，同时提供了 increment  和 decrement 的方法，分别让 number 加 1 和减 1</p><p>但是我们在进行判断的时候，为了 [ 防止出现虚假唤醒机制 ]，不能使用 if 来进行判断，而应该使用 while 判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断</span><br><span class="line">while(number !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 等待不能生产</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能使用 if判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断</span><br><span class="line">if(number !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 等待不能生产</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 资源类 [高内聚，低耦合：内聚指的是，一个空调，自身带有调节温度高低的方法]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-11-13 14:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/********************* 资源类 *************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待：不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知：唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待：不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知:唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************* 测试 *************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//t1线程：生产</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">                shareData.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//t2线程：消费</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">                shareData.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后运行成功后，我们一个进行生产，一个进行消费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br></pre></td></tr></table></figure><hr><h4 id="生成者和消费者-3-0"><a href="#生成者和消费者-3-0" class="headerlink" title="生成者和消费者 3.0"></a>生成者和消费者 3.0</h4><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度 。</p><p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************** 资源类 *******************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认开启，进行生产消费</span></span><br><span class="line">    <span class="comment">// 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子包装类，而不用 number++ [ 不用担心原子操作]</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue [ 进行抽象]</span></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而应该采用依赖注入里面的，构造注入方法传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        <span class="comment">// 查询出传入的class是什么</span></span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，[ 防止出现虚假唤醒 ]</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列:&quot;</span> + data  + <span class="string">&quot;成功&quot;</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//[一旦 FLAG 为true 就停止生产]</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列:&quot;</span> + data  + <span class="string">&quot;失败&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 停止生产，表示FLAG=false，生产结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue != <span class="keyword">null</span> &amp;&amp; retValue != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="string">&quot;成功&quot;</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 退出消费队列 [不要忘记了]</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止生产的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 测试类 *******************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> SynchronousQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 生产线程启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myProd();</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;prod&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费线程启动&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5秒后，停止生产和消费</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5秒钟后，生产和消费线程停止，线程结束&quot;</span>);</span><br><span class="line">        myResource.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">prod 生产线程启动</span><br><span class="line">consumer 消费线程启动</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">consumer 消费队列：1成功</span><br><span class="line">prod 插入队列：1成功</span><br><span class="line">prod 插入队列：2成功</span><br><span class="line">consumer 消费队列：2成功</span><br><span class="line">prod 插入队列：3成功</span><br><span class="line">consumer 消费队列：3成功</span><br><span class="line">prod 插入队列：4成功</span><br><span class="line">consumer 消费队列：4成功</span><br><span class="line">prod 插入队列：5成功</span><br><span class="line">consumer 消费队列：5成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5秒钟后，生产和消费线程停止，线程结束</span><br><span class="line">prod 停止生产,表示FLAG &#x3D; false,生产结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer 消费失败,队列中已为空，退出</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;8-阻塞队列&quot;&gt;&lt;a href=&quot;#8-阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;8_ 阻塞队列&quot;&gt;&lt;/a&gt;8_ 阻塞队列&lt;/h1&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
    <category term="队列" scheme="http://jiangbk.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>7_CountDownLatch_CyclicBarrier_Semaphore使用</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/7-CountDownLatch-CyclicBarrier-Semaphore%E4%BD%BF%E7%94%A8/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/7-CountDownLatch-CyclicBarrier-Semaphore%E4%BD%BF%E7%94%A8/</id>
    <published>2021-02-17T06:07:47.000Z</published>
    <updated>2021-02-17T06:08:42.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-CountDownLatch-CyclicBarrier-Semaphore使用"><a href="#7-CountDownLatch-CyclicBarrier-Semaphore使用" class="headerlink" title="7_CountDownLatch_CyclicBarrier_Semaphore使用"></a>7_CountDownLatch_CyclicBarrier_Semaphore使用</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p><p>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，调用线程就会被阻塞。其它线程调用 CountDown 方法会将计数器减 1（调用 CountDown 方法的线程不会被阻塞），当计数器的值变成零时，因调用 await 方法被阻塞的线程会被唤醒，继续执行 。</p><h3 id="场景：班长关门"><a href="#场景：班长关门" class="headerlink" title="场景：班长关门"></a>场景：班长关门</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个时候就用到了 CountDownLatch，计数器了。我们一共创建 6 个线程，然后计数器的值也设置成 6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数器</span><br><span class="line">CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);</span><br></pre></td></tr></table></figure><p>然后每次学生线程执行完，就让计数器的值<strong>减 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 上完自习，离开教室&quot;);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是<strong>一道墙</strong>，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t 班长最后关门&quot;);</span><br></pre></td></tr></table></figure><p>不加 CountDownLatch 的执行结果，我们发现 main 线程提前已经执行完成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 上完自习，离开教室</span><br><span class="line">0 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br></pre></td></tr></table></figure><p>引入CountDownLatch后的执行结果，我们能够控制住 main 方法的执行，这样能够保证前提任务的执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 上完自习，离开教室</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">1 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moxi.interview.study.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 上完自习，离开教室&quot;</span>);</span><br><span class="line">                <span class="comment">//计数器 -1 </span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置屏障</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 班长最后关门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>和 CountDownLatch 相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行 。</p><p>CyclicBarrier 的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的 await 方法 。</p><h3 id="案例：七龙珠"><a href="#案例：七龙珠" class="headerlink" title="案例：七龙珠"></a>案例：七龙珠</h3><p>集齐 7 个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法[Runnable 接口]</span><br><span class="line">*&#x2F;</span><br><span class="line">CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(7, () -&gt; &#123;</span><br><span class="line">System.out.println(&quot;召唤神龙&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行 await 方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Semaphore：信号量"><a href="#Semaphore：信号量" class="headerlink" title="Semaphore：信号量"></a>Semaphore：信号量</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>信号量主要用于两个目的</p><ul><li>一个是用于共享资源的互斥使用</li><li>另一个用于并发线程数的控制</li></ul><p>通过 acquire() 和 release() 实现 。</p><h3 id="案例：抢车位"><a href="#案例：抢车位" class="headerlink" title="案例：抢车位"></a>案例：抢车位</h3><p>我们模拟一个抢车位的场景，假设一共有6个车，3个停车位</p><p>那么我们首先需要定义信号量为3，也就是3个停车位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span><br><span class="line">*&#x2F;</span><br><span class="line">Semaphore semaphore &#x3D; new Semaphore(3, false);</span><br></pre></td></tr></table></figure><p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后，信号量需要减1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代表一辆车，已经占用了该车位</span><br><span class="line">semaphore.acquire(); &#x2F;&#x2F; 抢占</span><br></pre></td></tr></table></figure><p>同时车辆假设需要等待3秒后，释放信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每个车停3秒</span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(3);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后车辆离开，释放信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 释放停车位</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟6部车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 代表一辆车，已经占用了该车位</span></span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 抢占</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 抢到车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每个车停3秒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 离开车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0 抢到车位</span><br><span class="line">2 抢到车位</span><br><span class="line">1 抢到车位</span><br><span class="line">2 离开车位</span><br><span class="line">1 离开车位</span><br><span class="line">3 抢到车位</span><br><span class="line">0 离开车位</span><br><span class="line">4 抢到车位</span><br><span class="line">5 抢到车位</span><br><span class="line">4 离开车位</span><br><span class="line">3 离开车位</span><br><span class="line">5 离开车位</span><br></pre></td></tr></table></figure><p>看运行结果能够发现，0 2 1 车辆首先抢占到了停车位，然后等待3秒后，离开，然后后面 3 4 5 又抢到了车位 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-CountDownLatch-CyclicBarrier-Semaphore使用&quot;&gt;&lt;a href=&quot;#7-CountDownLatch-CyclicBarrier-Semaphore使用&quot; class=&quot;headerlink&quot; title=&quot;7_CountD</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>6_Java 的锁</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/6-Java-%E7%9A%84%E9%94%81/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/6-Java-%E7%9A%84%E9%94%81/</id>
    <published>2021-02-17T06:06:09.000Z</published>
    <updated>2021-02-17T06:07:02.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-Java-的锁"><a href="#6-Java-的锁" class="headerlink" title="6_Java 的锁"></a>6_Java 的锁</h1><h2 id="Java-锁之-公平锁-和-非公平锁"><a href="#Java-锁之-公平锁-和-非公平锁" class="headerlink" title="Java 锁之 公平锁 和 非公平锁"></a>Java 锁之 公平锁 和 非公平锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序 [ 随机抢占 ]，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p><h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><p>synchronized 只能是非公平锁 。</p><p>并发包中 ReentrantLock 的创建可以指定析构函数的 boolean 类型来得到公平锁或者非公平锁，默认是非公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span><br><span class="line">*&#x2F;</span><br><span class="line">Lock lock &#x3D; new ReentrantLock(true);</span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后按照 FIFO 的规则从队列中取到自己</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>Java ReenttrantLock 通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，<code>对于synchronized 而言，也是一种非公平锁 </code>。</p><hr><h2 id="可重入锁-和-递归锁-ReentrantLock"><a href="#可重入锁-和-递归锁-ReentrantLock" class="headerlink" title="可重入锁 和 递归锁 ReentrantLock"></a>可重入锁 和 递归锁 ReentrantLock</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>理念：</strong> [ 可重入锁就是递归锁 ！！！] 指的是 <strong>同一线程</strong> 外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 。也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p><p>⽐如⼀个线程获得了某个对象的锁 [ 第一层方法 ]，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的 [ 第二层方法 ]</p><p><strong>实现：</strong> ReentrantLock / Synchronized  就是一个典型的可重入锁</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>可重入锁就是，在一个 method1 方法中加入一把锁，方法 2 也加锁了，那么他们拥有的是同一把锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method1() &#123;</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void method2() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们只需要进入 method1 后，那么它也能直接进入method2 方法，因为他们所拥有的锁，是同一把 。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可重入锁的最大作用就是避免死锁</p><h3 id="可重入锁验证"><a href="#可重入锁验证" class="headerlink" title="可重入锁验证"></a>可重入锁验证</h3><h4 id="证明-Synchronized"><a href="#证明-Synchronized" class="headerlink" title="证明 Synchronized"></a>证明 Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送短信</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoked sendSMS()&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在同步方法中，调用另外一个同步方法</span></span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot;\t invoked sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个线程操作资源列</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们编写了一个资源类 phone，拥有两个加了 synchronized 的同步方法，分别是 sendSMS 和 sendEmail，我们在 sendSMS 方法中，调用 sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()</span><br><span class="line">t1 invoked sendEmail()</span><br><span class="line">t2 invoked sendSMS()</span><br><span class="line">t2 invoked sendEmail()</span><br></pre></td></tr></table></figure><p>这就说明当 t1 线程进入sendSMS 的时候，拥有了一把锁，同时 t2 线程无法进入，直到 t1 线程拿着锁，执行了sendEmail 方法后，才释放锁，这样 t2 才能够进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()      t1线程在外层方法获取锁的时候</span><br><span class="line">t1 invoked sendEmail()    t1在进入内层方法会自动获取锁</span><br><span class="line"></span><br><span class="line">t2 invoked sendSMS()      t2线程在外层方法获取锁的时候</span><br><span class="line">t2 invoked sendEmail()    t2在进入内层方法会自动获取锁</span><br></pre></td></tr></table></figure><h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set 进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">            setLock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t set Lock&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为Phone实现了Runnable接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们使用 ReentrantLock 进行验证，首先资源类实现了 Runnable 接口，重写 Run 方法，里面调用 get 方法，get 方法在进入的时候，就加了锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在方法里面，又调用另外一个加了锁的 setLock 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t set Lock&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果我们能发现，结果和加 synchronized 方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br></pre></td></tr></table></figure><p><strong>注意 1：</strong> 当我们在 getLock 方法加两把锁会是什么情况呢？(阿里面试)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">            setLock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是<strong>同一把锁</strong>，也就是说用同一个钥匙都能够打开 。</p><p><strong>注意 2：</strong> 当我们在 getLock 方法加两把锁，但是只解一把锁会出现什么情况呢 ？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void getLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br></pre></td></tr></table></figure><p>也就是说程序直接卡死，线程不能出来，也就说明我们<strong>申请几把锁，最后需要解除几把锁</strong></p><p><strong>注意 3：</strong> 当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢 ？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，运行程序会直接报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br><span class="line">Exception in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><hr><h2 id="Java-锁之-自旋锁"><a href="#Java-锁之-自旋锁" class="headerlink" title="Java 锁之 自旋锁"></a>Java 锁之 自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗 [ 避免用户态与内核态之间的转换 ]，缺点是循环会消耗CPU 。</p><p>原来提到的 CAS 比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140615.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>**优点： **循环比较获取直到成功为止，没有类似于 wait 的阻塞</p><p>**缺点： **当不断自旋的线程越来越多的时候，会因为执行 while 循环不断的消耗 CPU 资源</p><h3 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h3><p>通过 CAS 操作完成自旋锁，A线程先进来调用 myLock 方法自己持有锁 5 秒，B 随后进来发现当前有线程持有锁，不是 null，所以只能通过自旋等待，直到 A 释放锁后 B 随后抢到 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在的泛型装的是[Thread]，原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt;  atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前进来的线程</span></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋</span></span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前进来的线程</span></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己用完了后，把atomicReference变成null</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoked myUnlock()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动t1线程，开始操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始占有锁</span></span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始释放锁</span></span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让main线程暂停1秒，使得t1线程，先执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1秒后，启动t2线程，开始占用这个锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始占有锁</span></span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="comment">// 开始释放锁</span></span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 come in </span><br><span class="line">.....五秒后.....</span><br><span class="line">t1 invoked myUnlock()</span><br><span class="line">t2 come in </span><br><span class="line">t2 invoked myUnlock()</span><br></pre></td></tr></table></figure><p>首先输出的是 t1 come in</p><p>然后1秒后，t2线程启动，发现锁被 t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到 t1释放锁后，也就是 5 秒后，t2 成功获取到锁，然后释放 。</p><hr><h2 id="独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="独占锁（写锁） / 共享锁（读锁） / 互斥锁"></a>独占锁（写锁） / 共享锁（读锁） / 互斥锁</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>**独占锁： **指该锁一次只能被一个线程所持有。对 ReentrantLock 和 Synchronized 而言都是独占锁</p><p><strong>共享锁：</strong> 指该锁可以被多个线程锁持有 。</p><p>对 ReentrantReadWriteLock 其读锁是共享，其写锁是独占；写的时候只能一个人写，但是读的时候，可以多个人同时读 。</p><h3 id="为什么会有写锁和读锁"><a href="#为什么会有写锁和读锁" class="headerlink" title="为什么会有写锁和读锁"></a>为什么会有写锁和读锁</h3><p>原来我们使用 ReentrantLock 创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读 。</p><p>多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写 。</p><ul><li>读-读：能共存</li><li>读-写：不能共存</li><li>写-写：不能共存</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// private Lock lock = null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义写操作</span></span><br><span class="line"><span class="comment">     * 满足：原子 + 独占</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取:&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object value = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">// 线程操作资源类，5个线程写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt +  <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程操作资源类， 5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别创建5个线程写入缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程操作资源类，5个线程写</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">    final int tempInt &#x3D; i;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5个线程读取缓存，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程操作资源类， 5个线程读</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">    final int tempInt &#x3D; i;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        myCache.get(tempInt + &quot;&quot;);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 正在写入：0</span><br><span class="line">4 正在写入：4</span><br><span class="line">3 正在写入：3</span><br><span class="line">1 正在写入：1</span><br><span class="line">2 正在写入：2</span><br><span class="line">0 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">2 写入完成</span><br><span class="line">4 写入完成</span><br><span class="line">4 读取完成：null</span><br><span class="line">0 写入完成</span><br><span class="line">3 读取完成：null</span><br><span class="line">0 读取完成：null</span><br><span class="line">1 写入完成</span><br><span class="line">3 写入完成</span><br><span class="line">1 读取完成：null</span><br><span class="line">2 读取完成：null</span><br></pre></td></tr></table></figure><p>我们可以看到，在写入的时候，写操作都没其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致！！！</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 创建一个读写锁</span><br><span class="line">* 它是一个读写融为一体的锁，在使用的时候，需要转换</span><br><span class="line">*&#x2F;</span><br><span class="line">private ReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();</span><br></pre></td></tr></table></figure><p>当我们在进行写操作的时候，就需要转换成写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个写锁</span><br><span class="line">rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写锁 释放</span><br><span class="line">rwLock.writeLock().unlock();</span><br></pre></td></tr></table></figure><p>当们在进行读操作的时候，在转换成读锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个读锁</span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读锁 释放</span><br><span class="line">rwLock.readLock().unlock();</span><br></pre></td></tr></table></figure><p>这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个读写锁</span></span><br><span class="line"><span class="comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义写操作</span></span><br><span class="line"><span class="comment">     * 满足：原子 + 独占</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            map.put(key, value);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 写锁 释放</span></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object value = map.get(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 读锁释放</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程操作资源类，5个线程写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt +  <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程操作资源类， 5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 正在写入：1</span><br><span class="line">1 写入完成</span><br><span class="line">2 正在写入：2</span><br><span class="line">2 写入完成</span><br><span class="line">3 正在写入：3</span><br><span class="line">3 写入完成</span><br><span class="line">4 正在写入：4</span><br><span class="line">4 写入完成</span><br><span class="line">5 正在写入：5</span><br><span class="line">5 写入完成</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">5 正在读取:</span><br><span class="line">2 读取完成：2</span><br><span class="line">1 读取完成：1</span><br><span class="line">4 读取完成：4</span><br><span class="line">3 读取完成：3</span><br><span class="line">5 读取完成：5</span><br></pre></td></tr></table></figure><p>从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作 。</p><hr><p><strong>补充：</strong></p><h2 id="为什么Synchronized无法禁止指令重排，却能保证有序性"><a href="#为什么Synchronized无法禁止指令重排，却能保证有序性" class="headerlink" title="为什么Synchronized无法禁止指令重排，却能保证有序性"></a>为什么Synchronized无法禁止指令重排，却能保证有序性</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p><ul><li>Java内存模型</li><li>并发编程有序性问题</li><li>指令重排</li><li>synchronized锁</li><li>可重入锁</li><li>排它锁</li><li>as-if-serial语义</li><li>单线程&amp;多线程</li></ul><h4 id="标准解答"><a href="#标准解答" class="headerlink" title="标准解答"></a>标准解答</h4><p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p><blockquote><p>先解释什么是有序性问题，也知道是什么原因导致的有序性问题</p></blockquote><p>我们也知道，最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样。</p><blockquote><p>表明你知道啥是指令重排，也知道他的实现原理</p></blockquote><p>但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义。</p><p>as-if-serial语义把<strong>单线程</strong>程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p><blockquote><p>重点！解释下什么是as-if-serial语义，因为这是这道题的第一个关键词，答上来就对了一半了</p></blockquote><p>再说下synchronized，他是Java提供的锁，可以通过他对Java中的对象加锁，并且他是一种排他的、可重入的锁。</p><p>所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p><blockquote><p>介绍synchronized的原理，这是本题的第二个关键点，到这里基本就可以拿满分了。</p></blockquote><p>synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是<strong>单线程</strong>，因为有as-if-serial语义保证，单线程的有序性就天然存在了。</p><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p><a href="https://mp.weixin.qq.com/s/Pd6dOXaMQFUHfAUnOhnwtw">https://mp.weixin.qq.com/s/Pd6dOXaMQFUHfAUnOhnwtw</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-Java-的锁&quot;&gt;&lt;a href=&quot;#6-Java-的锁&quot; class=&quot;headerlink&quot; title=&quot;6_Java 的锁&quot;&gt;&lt;/a&gt;6_Java 的锁&lt;/h1&gt;&lt;h2 id=&quot;Java-锁之-公平锁-和-非公平锁&quot;&gt;&lt;a href=&quot;#Java-锁之</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
    <category term="锁" scheme="http://jiangbk.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>5_TransferValue 是什么</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/5-TransferValue-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/5-TransferValue-%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2021-02-17T06:04:44.000Z</published>
    <updated>2021-02-17T06:05:28.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-TransferValue-是什么"><a href="#5-TransferValue-是什么" class="headerlink" title="5_TransferValue 是什么"></a>5_TransferValue 是什么</h1><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><h3 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String personName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personName = personName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferValueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.setPersonName(<span class="string">&quot;XXXX&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;XXX&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TransferValueDemo test = <span class="keyword">new</span> TransferValueDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义基本数据类型</span></span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        test.changeValue1(age);</span><br><span class="line">        System.out.println(<span class="string">&quot;age ----&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化person类</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        test.changeValue2(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;personName-----&quot;</span> + person.getPersonName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String</span></span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        test.changeValue3(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;string-----&quot;</span> + str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age ----20</span><br><span class="line">personName-----XXXX</span><br><span class="line">string-----abc</span><br></pre></td></tr></table></figure><h3 id="changeValue1-的执行过程"><a href="#changeValue1-的执行过程" class="headerlink" title="changeValue1 的执行过程"></a>changeValue1 的执行过程</h3><p>八种基本数据类型，在栈里面分配内存，属于值传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈管运行，堆管存储</span><br></pre></td></tr></table></figure><p>当们执行 changeValue1 的时候，因为 int 是基本数据类型，所以传递的是 int = 20 这个值，相当于传递的是一个副本，main 方法里面的 age 并没有改变，因此输出的结果  age 还是20，属于值传递 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140405.png"></p><h3 id="changeValue2-的执行过程"><a href="#changeValue2-的执行过程" class="headerlink" title="changeValue2 的执行过程"></a>changeValue2 的执行过程</h3><p>因为 Person 是属于对象，传递的是<strong>内存地址</strong>，当执行changeValue2的时候，会改变内存中的 Person 的值，属于引用传递，两个指针都是指向同一个地址 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140358.png"></p><h3 id="changeValue3-的执行过程"><a href="#changeValue3-的执行过程" class="headerlink" title="changeValue3 的执行过程"></a>changeValue3 的执行过程</h3><p>String 不属于基本数据类型，但是为什么执行完成后，还是 abc 呢？</p><p>这是因为 String 的特殊性，当我们执行 String str = “abc” 的时候，它会把 <code>abc</code> 放入常量池中</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140411.png"></p><p>当我们执行 changeValue3 的时候，会重新新建一个 xxx，并没有销毁 abc，然后指向xxx，然后最后我们输出的是 main 中的引用，还是指向的 abc，因此最后输出结果还是abc 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;5-TransferValue-是什么&quot;&gt;&lt;a href=&quot;#5-TransferValue-是什么&quot; class=&quot;headerlink&quot; title=&quot;5_TransferValue 是什么&quot;&gt;&lt;/a&gt;5_TransferValue 是什么&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
    <category term="值传递" scheme="http://jiangbk.top/tags/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>4_ Collection 线程不安全的举例</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/4-Collection-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/4-Collection-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/</id>
    <published>2021-02-17T06:02:35.000Z</published>
    <updated>2021-02-17T06:03:34.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-Collection-线程不安全的举例"><a href="#4-Collection-线程不安全的举例" class="headerlink" title="4_ Collection 线程不安全的举例"></a>4_ Collection 线程不安全的举例</h1><h2 id="单线程环境下"><a href="#单线程环境下" class="headerlink" title="单线程环境下"></a>单线程环境下</h2><p>单线程环境的 ArrayList 是不会有问题的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListNotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String element : list) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>为什么 ArrayList 是线程不安全的 ？因为在进行写操作的时候，方法上为了保证并发性，是没有添加 synchronized 修饰，所以并发写的时候，就会出现问题 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140149.png"></p><hr><h2 id="ArrayList-不安全的案列"><a href="#ArrayList-不安全的案列" class="headerlink" title="ArrayList 不安全的案列"></a>ArrayList 不安全的案列</h2><p>当我们同时启动 100个线程去操作 List 的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">![Snipaste_2020-<span class="number">11</span>-<span class="number">12_17</span>-<span class="number">53</span>-<span class="number">21</span>](../../../../../myBlog/source/_posts/大厂面试第二季_周阳老师/JUC/4_ArrayList 为什么线程不安全/images/Snipaste_2020-<span class="number">11</span>-<span class="number">12_17</span>-<span class="number">53</span>-<span class="number">21.</span>png)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="comment">//往集合中添加元素【add 方法并未 synchronized 修饰】</span></span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候出现了错误，也就是<code>java.util.ConcurrentModificationException</code>[ 并发修改的异常 ]</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140157.png"></p><h4 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h4><p>并发修改导致：一个人正在写入，另一个人过来抢夺，导致数据不一致异常 ！</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：Vector"><a href="#方案一：Vector" class="headerlink" title="方案一：Vector"></a>方案一：Vector</h5><p>第一种方法，就是不用 ArrayList 这种不安全的 List 实现类，而采用 Vector，线程安全的</p><p>关于 Vector 如何实现线程安全的，而是在方法上加了锁，即 synchronized </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140202.png"></p><p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致并发性下降 。</p><h5 id="方案二：Collections-synchronizedList"><a href="#方案二：Collections-synchronizedList" class="headerlink" title="方案二：Collections.synchronizedList()"></a>方案二：Collections.synchronizedList()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>采用 Collections 集合工具类，在 ArrayList 外面包装一层 同步 机制 。</p><h5 id="方案三：使用-JUC-工具类中的-CopyOnWriteArrayList-类"><a href="#方案三：使用-JUC-工具类中的-CopyOnWriteArrayList-类" class="headerlink" title="方案三：使用 JUC 工具类中的 CopyOnWriteArrayList 类"></a>方案三：使用 JUC 工具类中的 CopyOnWriteArrayList 类</h5><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p><p>CopyOnWrite 容器即写时复制的容器。往一个容器添加元素的时候，不会直接往当前容器添加，而是现将当前容器 Object [ ] 进行 Copy ，复制出一个新的容器 Object [ ] ，然后再往新的容器中添加元素，添加完元素后，再将原容器的引用指向新的容器；这样做的好处是可以对 CopyOnWrite 容器进行并发读，而不需要加锁，因为当前容器并不需要添加元素。所以 CopyOnWrite 容器也是一种读写分离的思想！</p><p>就是写的时候，把 ArrayList 扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList 的引用指向扩容后的</p><p><strong>查看底层 add 方法源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Object[] elements = getArray();</span><br><span class="line">          <span class="keyword">int</span> len = elements.length;</span><br><span class="line">          Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">          newElements[len] = e;</span><br><span class="line">          setArray(newElements);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先需要加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure><p>然后在末尾扩容一个单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] elements &#x3D; getArray();</span><br><span class="line">int len &#x3D; elements.length;</span><br><span class="line">Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br></pre></td></tr></table></figure><p>然后在把扩容后的空间，填写上需要 add 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newElements[len] &#x3D; e;</span><br></pre></td></tr></table></figure><p>最后把内容 set 到 Array 中</p><hr><h2 id="HashSet-线程不安全"><a href="#HashSet-线程不安全" class="headerlink" title="HashSet 线程不安全"></a>HashSet 线程不安全</h2><h4 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h4><p> 线程不安全。并发情况下也会发生 <code>ConcurrentModificationException</code> 异常；</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：Collections-synchronizedSet-new-HashSet-lt-gt"><a href="#方案一：Collections-synchronizedSet-new-HashSet-lt-gt" class="headerlink" title="方案一：Collections.synchronizedSet(new HashSet&lt;&gt;())"></a>方案一：<code>Collections.synchronizedSet(new HashSet&lt;&gt;())</code></h5><h5 id="方案二：使用-JUC-工具类中的-CopyOnWriteArraySet-类"><a href="#方案二：使用-JUC-工具类中的-CopyOnWriteArraySet-类" class="headerlink" title="方案二：使用 JUC 工具类中的 CopyOnWriteArraySet 类"></a>方案二：使用 JUC 工具类中的 CopyOnWriteArraySet 类</h5><p>底层还是使用 CopyOnWriteArrayList 进行实例化</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140209.png"></p><p><strong>补充：</strong></p><p>同理 HashSet 的底层结构就是 HashMap</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140214.png"></p><p><strong>思考：</strong> 但是为什么我调用 HashSet.add() 的方法，只需要传递一个元素，而 HashMap 是需要传递 key-value 键值对 ？</p><p>首先我们查看 hashSet 的 add 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们能发现但我们调用 add 的时候，存储一个值进入map中，只是作为key进行存储，而 value 存储的是一个Object 类型的常量，也就是说 HashSet 只关心key，而不关心 value 。</p><hr><h2 id="HashMap-线程不安全案列"><a href="#HashMap-线程不安全案列" class="headerlink" title="HashMap 线程不安全案列"></a>HashMap 线程不安全案列</h2><p>同理 HashMap 在多线程环境下，也是不安全的，并发情况下也会发生 <code>ConcurrentModificationException</code> 异常；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：使用-HashTable"><a href="#方案一：使用-HashTable" class="headerlink" title="方案一：使用 HashTable"></a>方案一：使用 HashTable</h5><p>与 Vector 类似，属于 HashMap 线程安全的实现类，里面方面同样加了 <code>synchronized</code>修饰，效率较低 。</p><h5 id="方案二：Collections-synchronizedMap-new-HashMap-lt-gt"><a href="#方案二：Collections-synchronizedMap-new-HashMap-lt-gt" class="headerlink" title="方案二：Collections.synchronizedMap(new HashMap&lt;&gt; ())"></a>方案二：Collections.synchronizedMap(new HashMap&lt;&gt; ())</h5><h5 id="方案三：使用-JUC-工具类下的-ConcurrentHashMap"><a href="#方案三：使用-JUC-工具类下的-ConcurrentHashMap" class="headerlink" title="方案三：使用 JUC 工具类下的  ConcurrentHashMap"></a>方案三：使用 JUC 工具类下的  ConcurrentHashMap</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-Collection-线程不安全的举例&quot;&gt;&lt;a href=&quot;#4-Collection-线程不安全的举例&quot; class=&quot;headerlink&quot; title=&quot;4_ Collection 线程不安全的举例&quot;&gt;&lt;/a&gt;4_ Collection 线程不安全的举例</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
    <category term="Collection" scheme="http://jiangbk.top/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>3_谈谈原子类的ABA问题</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/3-%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/3-%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/</id>
    <published>2021-02-17T02:54:34.000Z</published>
    <updated>2021-02-17T02:57:20.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-谈谈原子类的ABA问题"><a href="#3-谈谈原子类的ABA问题" class="headerlink" title="3_谈谈原子类的ABA问题"></a>3_谈谈原子类的ABA问题</h1><h2 id="原子类-AtomicInteger-的ABA问题"><a href="#原子类-AtomicInteger-的ABA问题" class="headerlink" title="原子类 AtomicInteger 的ABA问题"></a>原子类 AtomicInteger 的ABA问题</h2><h3 id="连环套路"><a href="#连环套路" class="headerlink" title="连环套路"></a>连环套路</h3><p>从 AtomicInteger 引出下面的问题：</p><p>CAS -&gt; Unsafe -&gt; CAS 底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避 ABA 问题</p><hr><h3 id="ABA-问题是什么"><a href="#ABA-问题是什么" class="headerlink" title="ABA 问题是什么"></a>ABA 问题是什么</h3><p>假设现在有两个线程，分别是 T1 和 T2，然后 T1 执行某个操作的时间为10 秒，T2 执行某个时间的操作是 2 秒，最开始 AB 两个线程，分别从主内存中获取 A 值，但是因为 B 的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105629.png"></p><p>所以 ABA 问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了 N 次，但是最终又改成原来的值了 。</p><h3 id="CAS-导致-ABA-问题"><a href="#CAS-导致-ABA-问题" class="headerlink" title="CAS 导致 ABA 问题"></a>CAS 导致 ABA 问题</h3><p>CAS 算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p><p>比如说一个线程 one 从内存位置 V 中取出A，这时候另外一个线程 two 也从内存中取出 A，并且线程 two进行了一些操作将值变成了B，然后线程 two 又将 V 位置的数据变成 A，这时候线程 one 进行CAS操作发现内存中仍然是 A，然后线程 one 操作成功 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的！！！</span><br></pre></td></tr></table></figure><hr><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>原子引用其实和原子包装类是差不多的概念，就是将一个 java 类，用原子引用类进行包装起来，那么这个类就具备了原子性 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User z3 = <span class="keyword">new</span> User(<span class="string">&quot;z3&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        User l4 = <span class="keyword">new</span> User(<span class="string">&quot;l4&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在主物理内存的共享变量，为z3</span></span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于原子引用的-ABA-问题"><a href="#基于原子引用的-ABA-问题" class="headerlink" title="基于原子引用的 ABA 问题"></a>基于原子引用的 ABA 问题</h4><p>我们首先创建了两个线程，然后 T1 线程，执行一次 ABA 的操作，T2 线程在一秒后修改主内存的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的原子引用包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，它能够成功的修改，这就是 ABA 问题</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105647.png"></p><hr><h3 id="解决-ABA-问题"><a href="#解决-ABA-问题" class="headerlink" title="解决 ABA 问题"></a>解决 ABA 问题</h3><p><strong>思路如下：</strong></p><p>新增一种机制，也就是修改版本号，类似于[ 时间戳 ]的概念</p><p>T1： 100 1 2019 2</p><p>T2： 100 1 101 2 100 3</p><p>如果 T1 修改的时候，版本号为 2，落后于现在的版本号 3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路 。</p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的原子引用包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递两个值，一个是初始值，一个是初始版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的产生==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t3一秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否：&quot;</span> + result + <span class="string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能够发现，线程 t3，在进行 ABA 操作后，版本号变更成了 3，而线程 t4 在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-谈谈原子类的ABA问题&quot;&gt;&lt;a href=&quot;#3-谈谈原子类的ABA问题&quot; class=&quot;headerlink&quot; title=&quot;3_谈谈原子类的ABA问题&quot;&gt;&lt;/a&gt;3_谈谈原子类的ABA问题&lt;/h1&gt;&lt;h2 id=&quot;原子类-AtomicInteger-的AB</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
    <category term="CAS" scheme="http://jiangbk.top/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/2-CAS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/2-CAS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2021-02-17T02:53:36.086Z</published>
    <updated>2021-02-17T06:00:50.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-CAS-底层原理"><a href="#2-CAS-底层原理" class="headerlink" title="2_CAS 底层原理"></a>2_CAS 底层原理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CAS 的全称是 Compare-And-Swap，它是 CPU 并发原语</p><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p><p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法。调用UnSafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于 CAS 是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，不会造成所谓的数据不一致的问题，也就是说 CAS 是线程安全的 。</p><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个原子类</span></span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span></span><br><span class="line"><span class="comment">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140025.png"></p><p>首先调用 AtomicInteger 创建了一个实例， 并初始化为 5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger(5);</span><br></pre></td></tr></table></figure><p>然后调用 CAS 方法，企图更新成 2019，这里有两个参数，一个是 5，表示期望值，第二个就是我们要更新的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(5, 2019)</span><br></pre></td></tr></table></figure><p>然后再次使用了一个方法，同样将值改成 1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(5, 1024)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了 2019，不满足期望值，因此返回了 false，本次写入失败！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135811.png"></p><hr><h2 id="CAS-底层原理"><a href="#CAS-底层原理" class="headerlink" title="CAS 底层原理"></a>CAS 底层原理</h2><p>首先我们先看看 atomicInteger.getAndIncrement() 方法的源码</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135820.png"></p><p>从这里能够看到，底层又调用了一个 unsafe 类的 getAndAddInt 方法</p><h3 id="1、unsafe-类"><a href="#1、unsafe-类" class="headerlink" title="1、unsafe 类"></a>1、unsafe 类</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135829.png"></p><p>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe 类存在sun.misc 包中，其内部方法操作可以像 C 的指针一样直接操作内存，因为 Java 中的 CAS 操作的执行依赖于 Unsafe 类的方法。</p><blockquote><p>注意 Unsafe 类的所有方法都是 native 修饰的，也就是说 unsafe 类中的方法都直接调用操作系统底层资源执行相应的任务！！！</p></blockquote><p>为什么 Atomic 修饰的包装类，能够保证原子性，依靠的就是底层的 unsafe 类</p><h3 id="2、变量-valueOffset"><a href="#2、变量-valueOffset" class="headerlink" title="2、变量 valueOffset"></a>2、变量 valueOffset</h3><p>表示该变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135835.png"></p><p>从这里我们能够看到，通过 valueOffset，直接通过内存地址，获取到值，然后进行加 1 的操作</p><h3 id="3、变量-value-用-volatile-修饰"><a href="#3、变量-value-用-volatile-修饰" class="headerlink" title="3、变量 value 用 volatile 修饰"></a>3、变量 value 用 volatile 修饰</h3><p>保证了多线程之间的内存可见性</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135844.png"></p><p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行 compareAndSwapInt() 在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p><p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p><p>假设执行 compareAndSwapInt 返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用 synchronized，而用 CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的 do while 循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作 。</p><p>假设线程 A 和线程 B 同时执行 getAndInt 操作（分别跑在不同的 CPU 上）</p><ol><li>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据JMM 模型，线程 A 和线程 B 各自持有一份价值为 3 的副本，分别存储在各自的工作内存</li><li>线程 A 通过 getIntVolatile(var1 , var2)  拿到 value 值3，这是线程 A 被挂起（该线程失去 CPU 执行权）</li><li>线程 B 也通过 getIntVolatile(var1, var2) 方法获取到 value 值也是3，此时刚好线程 B 没有被挂起，并执行了compareAndSwapInt 方法，比较内存的值也是 3，成功修改内存值为 4，线程B打完收工，一切OK</li><li>这是线程 A 恢复，执行 CAS 方法，比较发现自己手里的数字 3 和主内存中的数字 4 不一致，说明该值已经被其它线程抢先一步修改过了，那么 A 线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行 do while</li><li>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总能够看到，线程 A 继续执行 compareAndSwapInt 进行比较替换，直到成功。</li></ol><p>Unsafe 类 + CAS 思想： 也就是自旋，自我旋转！！！</p><p><strong>补充：</strong>上面说到的 Unsafe 类中的 compareAndSwapInt 是一个本地方法，该方法的实现位于unsafe.cpp 中</p><ul><li>先想办法拿到变量 value 在内存中的地址</li><li>通过 Atomic::cmpxchg 实现比较替换，其中参数 X 是即将更新的值，参数 e 是原内存的值</li></ul><hr><h2 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h2><p>CAS 是一种乐观锁，它避免了悲观锁独占锁对象的情况，同时也提高了并发性能</p><p>存在问题如下：</p><ul><li><p>乐观锁只能保证一个共享变量的原子操作。如果存在多个变量，乐观锁将显得力不从心【但互斥锁能轻易解决，不管对象数量的多少级对象颗粒的大小】</p></li><li><p><strong>长时间自旋可能导致开销大。</strong>加入 CAS 长时间操作不成功一直自旋，会给 CPU带来很大的开销。</p></li><li><p>*<em>ABA 问题  <em>。</em></em>CAS 的核心思想是通过比较内存值和预期值是否一样而判断内存值是否被更改过，但此判断逻辑不严谨，假如内存值为 A，后来一条线程修改为 B，最后又被另一个线程改成了 A，则 CAS 认为内存值并没有发生过改变，但实际情况是有被其他线程修改，这种情况对依赖过程值的情景的运算结果影响很大。</p><p>解决办法：<strong>引入版本号</strong>，每次变量更新都把版本号【时间戳】加一。</p></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的更新值 B。</p><p>CAS 是 compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止 ！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-CAS-底层原理&quot;&gt;&lt;a href=&quot;#2-CAS-底层原理&quot; class=&quot;headerlink&quot; title=&quot;2_CAS 底层原理&quot;&gt;&lt;/a&gt;2_CAS 底层原理&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1_谈谈volatile</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/1-%E8%B0%88%E8%B0%88volatile/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/1-%E8%B0%88%E8%B0%88volatile/</id>
    <published>2021-02-17T02:51:59.000Z</published>
    <updated>2021-02-17T02:55:01.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-谈谈Volatile"><a href="#1-谈谈Volatile" class="headerlink" title="1_谈谈Volatile"></a>1_谈谈Volatile</h1><h2 id="1-Volatile-和-JMM-内存模型的可见性"><a href="#1-Volatile-和-JMM-内存模型的可见性" class="headerlink" title="1_Volatile 和 JMM 内存模型的可见性"></a>1_Volatile 和 JMM 内存模型的可见性</h2><ul><li>JUC（java.util.concurrent）<ul><li>进程和线程<ul><li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li><li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li></ul></li><li>并发和并行<ul><li>并发：同时访问某个东西，就是并发</li><li>并行：一起做某些事情，就是并行</li></ul></li></ul></li><li>JUC 下的三个包<ul><li>java.util.concurrent<ul><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul></li></ul></li></ul><h3 id="谈谈你对-Volatile-的理解"><a href="#谈谈你对-Volatile-的理解" class="headerlink" title="谈谈你对 Volatile 的理解"></a>谈谈你对 Volatile 的理解</h3><p>volatile 在日常的单线程环境是应用不到的</p><p>volatile 是 Java 虚拟机提供的 <strong>轻量级</strong> 【乞丐版 synchronized】的同步机制。</p><p>volatile 修饰的变量具有三种特性：</p><ol><li>保证可见性</li><li><strong>不保证原子性</strong>【原子性：完整性，不可缺性，中间不可以被分割，要么成功，要么失败】</li><li>禁止指令重排序【计算机底层实现是：会在其前后加内存屏障，禁止内存屏障前后的指令进行重排序优化】</li></ol><h4 id="那你能否写一个-Demo-验证一下可见性-？"><a href="#那你能否写一个-Demo-验证一下可见性-？" class="headerlink" title="那你能否写一个 Demo 验证一下可见性 ？"></a>那你能否写一个 Demo 验证一下可见性 ？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始执行&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 线程睡眠3秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                date.setNumber();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟线程B：一直在这里等待循环，直到 number 的值不等于零</span></span><br><span class="line">        <span class="keyword">while</span> (date.number == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要变量的值被修改，就会执行下面的语句</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    <span class="comment">//volatile 保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程就是：</p><ul><li>线程 a 从主内存读取 共享变量 到对应的工作内存</li><li>对共享变量进行更改</li><li>线程 b 读取共享变量的值到对应的工作内存</li><li>线程 a 将修改后的值刷新到主内存，失效其他线程对 共享变量的副本</li><li>线程 b 对共享变量进行操作时，发现已经失效，重新从主内存读取最新值，放入到对应工作内存。</li></ul><h4 id="你能否写个-Demo-验证一下-不保证原子性？"><a href="#你能否写个-Demo-验证一下-不保证原子性？" class="headerlink" title="你能否写个 Demo 验证一下 不保证原子性？"></a>你能否写个 Demo 验证一下 不保证原子性？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Date2 date2 = <span class="keyword">new</span> Date2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启20个线程</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//每个线程执行1000次++操作</span></span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">0</span>;j &lt; <span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    date2.setNumberPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="built_in">String</span>.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让20个线程全部执行完</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123; <span class="comment">//main + GC</span></span><br><span class="line">            <span class="comment">//礼让线程</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看最终结果</span></span><br><span class="line">        System.out.println(date2.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date2</span></span>&#123;</span><br><span class="line">    volatile int number;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">setNumberPlus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//让其自增</span></span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程是：</p><ul><li><p>假设现在共享变量的值是 100 ，线程 A 需要对变量进行自增 1，首先它从主内存中读取变量值，由于 CPU 切换关系，此时切换到 B线程；  </p></li><li><p>B 线程也从主内存中读取变量值，此时读取到的变量值还是 100，然后在自己的工作内存中进行了 + 1 操作，但是还未刷新回主内存；</p></li><li><p>此时，CPU 又切换到了 A线程，由于 B 线程还未将工作内存中的值刷新回主内存，因此 A 线程中的值还是 100，A 线程对工作内存中的变量进行 + 1 操作；</p></li><li><p>线程 B 刷新 新的值 101 到主内存 ；</p></li><li><p>线程 A 刷新 新的值 101 到主内存；</p><p>结果就是：两次 +1 操作，却只进行了 1 次修改</p></li></ul><h4 id="那如何才能保证原子性呢-？"><a href="#那如何才能保证原子性呢-？" class="headerlink" title="那如何才能保证原子性呢 ？"></a>那如何才能保证原子性呢 ？</h4><p>方式1：使用 synchronized 【大材小用】</p><p>方式2：使用 JUC 下的 AtomicInteger 原子类【底层是基于 CAS】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Date3 date3 = <span class="keyword">new</span> Date3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启20个线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//每个线程执行1000次++操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    date3.setAtomic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让20个线程全部执行完</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123; <span class="comment">//主线程 + GC</span></span><br><span class="line">            Thread.yield();<span class="comment">//礼让线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看最终结果</span></span><br><span class="line">        System.out.println(date3.number); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date3</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个原子 Integer 包装类，默认为0</span></span><br><span class="line">    AtomicInteger number = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtomic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//相当于 atomicInter ++</span></span><br><span class="line">        number.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的-Demo-？"><a href="#什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的-Demo-？" class="headerlink" title="什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的 Demo ？"></a>什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的 Demo ？</h4><p>为了提高性能，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105309.png"></p><p>单线程环境里面确保最终执行结果和代码顺序的结果一致 。</p><blockquote><p>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></p></blockquote><p>但是，当多线程交替执行时，由于编译器优化重排，两个线程在使用的变量能否保住一致性是无法确定的，结果无法预测 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date4</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a; <span class="comment">//使用 volatile 禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">5</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;打印成功&quot;</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile-针对指令重排做了啥"><a href="#volatile-针对指令重排做了啥" class="headerlink" title="volatile 针对指令重排做了啥"></a>volatile 针对指令重排做了啥</h4><p>volatile 实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象</p><p>首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，它的作用有两个：</p><ul><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）</li></ul><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器 和 CPU，不管什么指令都不能和这条 Memory Barrier 指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是刷新出各种 CPU 的缓存数，因此任何 CPU 上的线程都能读取到这些数据的最新版本。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105310.png"></p><p>也就是过在 volatile 的写 和 读的时候，加入屏障，防止出现指令重排的！！！</p><h4 id="那么你在什么场景下有使用到-volatile-呢-？"><a href="#那么你在什么场景下有使用到-volatile-呢-？" class="headerlink" title="那么你在什么场景下有使用到 volatile 呢 ？"></a>那么你在什么场景下有使用到 volatile 呢 ？</h4><p><strong>单例模式中【双重检查机制</strong>】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.提供静态变量保存实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton6 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供获取对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一重检查：针对很多个线程同时想要创建对象的情况</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步代码块锁定</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton6.class)&#123;</span><br><span class="line">     <span class="comment">//第二重锁检查(针对比如A,B两个线程都为null，第一个线程创建完对象，第二个等待锁的线程拿到锁的情况)</span></span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请你说说为什么要在这里加上 volatile 呢？</strong></p><p>因为创建对象分为 3 步：</p><ol><li>分配内存空间；</li><li>初始化对象</li><li>设置实例执行刚分配的内存地址【正常流程走：instance ! = null】</li></ol><p>但是，由于这 3 步<strong>不存在数据依赖关系</strong> ，所以可能进行重排序优化，造成下列现象：</p><ol><li>分配内存空间</li><li>设置实例执行刚分配的内存地址【instance ! = null 有名无实，初始化并未完成！】</li><li>初始化对象</li></ol><p><strong>所有当另一条线程访问 instance 时 不为null，但是 instance实例化未必已经完成，也就造成线程安全问题！</strong></p><hr><h3 id="JMM-是什么"><a href="#JMM-是什么" class="headerlink" title="JMM  是什么"></a>JMM  是什么</h3><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105311.png" style="zoom:67%;" /><p>JMM （Java 内存模型）是一种抽象的概念 <strong>并不真实存在</strong>，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素，不包括局部变量和方法参数，这是线程私有的，不存在竞争关系）的访问方式。</p><ul><li><p>具体的 JMM 规定如下：</p><ol><li> 所有 共享变量 储存于 主内存 中；</li><li> 每条线程拥有自己的工作内存，保存了被线程使用的变量的副本拷贝；</li><li> 线程对变量的所有操作（读，写）都必须在自己的 工作内存 中完成，而不能直接读写 主内存 中的变量；</li><li> 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存中转来完成</li></ol></li></ul><p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU</p><p>两个概念：主内存 和 工作内存</p><ul><li><p>主内存：就是计算机的内存，也就是经常提到的 8G 内存，16G 内存</p></li><li><p>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中</p><ul><li>当同时有三个线程同时访问 student 中的 age 变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝 。</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105312.png"></p><p>即：JMM 内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><hr><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>为什么这里主线程中某个值被更改后，其它线程能马上知晓呢？其实这里是用到了<strong>总线嗅探技术</strong></p><p>在说嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一。</p><p><strong>为了解决缓存一致性的问题</strong>，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有 MSI、MESI 等等。</p><h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><p>当 CPU 写数据时，如果发现操作的变量是共享变量，即在其它 CPU中 也存在该变量的副本，会发出信号通知其它 CPU 将该内存变量的缓存行设置为无效，因此当其它 CPU 读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。</p><h4 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h4><p><strong>那么是如何发现数据是否失效呢？</strong></p><p>这里是用到了总线嗅探技术，就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p><h4 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h4><p><strong>总线嗅探技术有哪些缺点？</strong></p><p>由于 volatile 的 MESI 缓存一致性协议，需要不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用 volatile 关键字，至于什么时候使用 volatile、什么时候用锁以及 Syschonized 都是需要根据实际场景的。</p><hr><h3 id="线程安全获得保证"><a href="#线程安全获得保证" class="headerlink" title="线程安全获得保证"></a>线程安全获得保证</h3><p><strong>工作内存与主内存同步延迟现象导致的可见性问题</strong></p><ul><li>可通过 synchronized 或 volatile 关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见 。</li></ul><p><strong>对于指令重排导致的可见性问题和有序性问题</strong></p><ul><li>可以使用 volatile 关键字解决，因为 volatile 关键字的另一个作用就是禁止重排序优化 。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-谈谈Volatile&quot;&gt;&lt;a href=&quot;#1-谈谈Volatile&quot; class=&quot;headerlink&quot; title=&quot;1_谈谈Volatile&quot;&gt;&lt;/a&gt;1_谈谈Volatile&lt;/h1&gt;&lt;h2 id=&quot;1-Volatile-和-JMM-内存模型的可见性</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JUC" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/"/>
    
    
    <category term="JUC" scheme="http://jiangbk.top/tags/JUC/"/>
    
    <category term="volatile" scheme="http://jiangbk.top/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>5_垃圾收集器</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2021-02-17T02:48:55.000Z</published>
    <updated>2021-02-17T02:50:33.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5_垃圾收集器"></a>5_垃圾收集器</h1><blockquote><p>问题5：GC垃圾回收算法和垃圾收集器关系？分别是什么请你谈谈？</p><ul><li>天上飞的理念，要有落地的实现（垃圾收集器就是GC垃圾回收算法的实现）</li><li>GC算法是内存回收的方法论，垃圾收集器就是算法的落地实现</li></ul></blockquote><p><strong>GC算法主要有以下几种：</strong></p><ul><li><del>引用计数（几乎不用，无法解决循环引用的问题）</del></li><li>复制拷贝（用于新生代）</li><li>标记清除（用于老年代）</li><li>标记整理（用于老年代）</li><li>因为目前为止还没有完美的收集器出现，更没有万能的收集器，只是针对具体应用最合适的收集器，进行<font color='red'>;</font></li></ul><hr><p> <strong>四种主要的垃圾收集器：</strong></p><ul><li>Serial：串行回收 <code>-XX:+UseSeriallGC</code></li><li>Parallel：并行回收 <code>-XX:+UseParallelGC</code></li><li>CMS：并发标记清除</li><li>G1</li><li>ZGC：（java 11 出现的）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105011.png"></p><hr><h2 id="四种主要的垃圾收集器"><a href="#四种主要的垃圾收集器" class="headerlink" title="四种主要的垃圾收集器"></a>四种主要的垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><blockquote><p>串行垃圾回收器，它为单线程环境设计且值<code>使用一个线程进行垃圾收集，会暂停所有的用户线程</code>，只有当垃圾回收完成时，才会重新唤醒主线程继续执行。所以不适合服务器环境</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105012.png"></p><hr><h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><blockquote><p>并行垃圾收集器，<code>多个垃圾收集线程并行工作，此时用户线程也是阻塞的</code>，适用于科学计算 / 大数据处理等弱交互场景，</p><p>也就是说Serial 和 Parallel其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停，但是并行垃圾收集器处理时间，<strong>肯定比串行的垃圾收集器要更短</strong></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105013.png"></p><hr><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><blockquote><p>并发标记清除，<code>用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程</code>，互联网公司都在使用，适用于响应时间有要求的场景。</p><p>并发是可以有交互的，也就是说可以一边进行收集，一边执行应用程序。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105014.png"></p><hr><h3 id="串行-并行-并发-垃圾收集器总结"><a href="#串行-并行-并发-垃圾收集器总结" class="headerlink" title="串行/并行/并发 垃圾收集器总结"></a>串行/并行/并发 垃圾收集器总结</h3><p>注意：并行垃圾回收在单核CPU下可能会更慢</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105015.png"></p><hr><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><blockquote><p>G1垃圾回收器将堆内存<code>分割成不同区域，然后并发的进行垃圾回收</code>.</p><p>Java 7 和 Java 8 开始使用G1，Java 11开始换成了ZGC</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105016.png"></p><hr><h2 id="默认垃圾收集器"><a href="#默认垃圾收集器" class="headerlink" title="默认垃圾收集器"></a>默认垃圾收集器</h2><blockquote><p>问题7：怎么查看服务器的默认GC收集器？生产上如何配置GC收集器？谈谈你的GC收集器的理解？</p></blockquote><h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><p>使用下面JVM命令，查看配置的初始参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure><p>然后运行一个程序后，能够看到它的一些初始配置信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105017.png"></p><p>移动到最后一句，就能看到 <code>-XX:+UseParallelGC</code> 说明使用的是并行垃圾回收。</p><hr><h3 id="默认垃圾收集器种类"><a href="#默认垃圾收集器种类" class="headerlink" title="默认垃圾收集器种类"></a>默认垃圾收集器种类</h3><p>Java中一共有7大垃圾收集器</p><ul><li>UserSerialGC：串行垃圾收集器</li><li>UserParallelGC：并行垃圾收集器</li><li>UseConcMarkSweepGC：（CMS）并发标记清除</li><li>UseParNewGC：年轻代的并行垃圾回收器</li><li>UseParallelOldGC：老年代的并行垃圾回收器</li><li>UseG1GC：G1垃圾收集器</li><li><del>UserSerialOldGC：串行老年代垃圾收集器（已经被移除）</del></li></ul><hr><p><strong>底层源码：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105018.png"></p><hr><h3 id="各垃圾收集器的使用范围"><a href="#各垃圾收集器的使用范围" class="headerlink" title="各垃圾收集器的使用范围"></a>各垃圾收集器的使用范围</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105019.png"></p><p>新生代使用的：</p><ul><li>Serial Copying： UserSerialGC，串行垃圾回收器</li><li>Parallel Scavenge：UserParallelGC，并行垃圾收集器</li><li>ParNew：UserParNewGC，新生代并行垃圾收集器</li></ul><p>老年区使用的：</p><ul><li><del>Serial Old：UseSerialOldGC，老年代串行垃圾收集器</del></li><li>Parallel Compacting（Parallel Old）：UseParallelOldGC，老年代并行垃圾收集器</li><li>CMS：UseConcMarkSwepp，并行标记清除垃圾收集器</li></ul><p>各区都能使用的：</p><p>G1：UseG1GC，G1垃圾收集器</p><blockquote><p><font color='red'>垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大</font></p></blockquote><hr><p>HotSpot中包含的收集器如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105020.png"></p><h3 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h3><ul><li>DefNew：Default New Generation</li><li>Tenured：Old</li><li>ParNew：Parallel New Generation</li><li>PSYoungGen：Parallel Scavenge</li><li>ParOldGen：Parallel Old Generation</li></ul><hr><h3 id="Java中的Server和Client模式"><a href="#Java中的Server和Client模式" class="headerlink" title="Java中的Server和Client模式"></a>Java中的Server和Client模式</h3><blockquote><p>使用范围：一般使用Server模式，Client模式基本不会使用</p></blockquote><p>操作系统</p><ul><li>32位的Window操作系统，不论硬件如何都默认使用Client的JVM模式</li><li>32位的其它操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式</li><li>64位只有Server模式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105021.png"></p><hr><h2 id="新生代下的垃圾收集器"><a href="#新生代下的垃圾收集器" class="headerlink" title="新生代下的垃圾收集器"></a>新生代下的垃圾收集器</h2><h3 id="串行GC-Serial"><a href="#串行GC-Serial" class="headerlink" title="串行GC(Serial)"></a>串行GC(Serial)</h3><blockquote><p>串行GC（Serial）（Serial Copying）：是一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105022.png"></p><p>串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在垃圾收集过程中可能会产生较长的停顿(Stop-The-World 状态)。 虽然在收集垃圾过程中需要暂停所有其它的工作线程，但是它<strong>简单高效</strong>，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是Java虚拟机运行在Client模式下默认的新生代垃圾收集器</p><p><font color='red'>对应JVM参数是：-XX:+UseSerialGC</font></p><p><font color='red'>开启后会使用：Serial(Young区用) + Serial Old(Old区用) 的收集器组合</font></p><p><strong>表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法</strong></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105023.png"></p><p>对应： DefNew + Tenured</p><hr><h3 id="并行GC-ParNew"><a href="#并行GC-ParNew" class="headerlink" title="并行GC(ParNew)"></a>并行GC(ParNew)</h3><blockquote><p>并行收集器，使用<code>多线程进行垃圾回收</code>，在垃圾收集，会 Stop-the-World 暂停其他所有的工作线程直到它收集结束</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105024.png"></p><p>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景时配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。<strong>它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</strong></p><p><font color='red'>常见对应JVM参数：-XX:+UseParNewGC 启动ParNew收集器，只影响新生代的收集，不影响老年代</font></p><p><font color='red'>开启上述参数后，会使用：ParNew（Young区用） + Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</font></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParNewGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105025.png"></p><p>但是会出现警告，即 ParNew 和 Serial Old 这样搭配，Java8已经不再被推荐</p><p>对应： ParNew + Tenured</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105020.png"></p><p>备注： -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数</p><hr><h3 id="并行回收GC（Parallel）-（Parallel-Scavenge）"><a href="#并行回收GC（Parallel）-（Parallel-Scavenge）" class="headerlink" title="并行回收GC（Parallel）/ （Parallel Scavenge）"></a>并行回收GC（Parallel）/ （Parallel Scavenge）</h3><blockquote><p>因为Serial 和 ParNew都不推荐使用了，因此现在新生代默认使用的是Parallel Scavenge，也就是新生代和老年代都是使用并行</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105026.png"></p><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。一句话：<strong>串行收集器在新生代和老年代的并行化</strong></p><p>它关注的重点是：</p><p><font color='red'>可控制的吞吐量（Thoughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。</font>高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。</p><p><font color='red'>自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。</font>（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间( -XX:MaxGCPauseMills)）或最大的吞吐量。</p><p><font color='red'>常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC（可互相激活）使用Parallel Scanvenge收集器</font></p><p><strong>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</strong></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105027.png"></p><p>对应：PSYoungGen + ParOldGen</p><hr><h2 id="老年代下的垃圾收集器"><a href="#老年代下的垃圾收集器" class="headerlink" title="老年代下的垃圾收集器"></a>老年代下的垃圾收集器</h2><h3 id="并行GC（Parallel-Old）-（Parallel-MSC）"><a href="#并行GC（Parallel-Old）-（Parallel-MSC）" class="headerlink" title="并行GC（Parallel Old）/ （Parallel MSC）"></a>并行GC（Parallel Old）/ （Parallel MSC）</h3><blockquote><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p></blockquote><p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。<font color='red'>在JDK1.6以前(Parallel Scavenge + Serial Old)</font></p><p>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以考虑新生代Parallel Scavenge和老年代Parallel Old 收集器的搭配策略。<font color='red'>在JDK1.8及后（Parallel Scavenge + Parallel Old）</font></p><p><font color='red'>JVM常用参数：-XX +UseParallelOldGC：使用Parallel Old收集器，设置该参数后，新生代Parallel+老年代 Parallel Old</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105028.png"></p><hr><p>实例：</p><p>使用老年代并行收集器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelOldlGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105029.png"></p><p>对应：PSYoungGen + ParOldGen</p><hr><h3 id="并发标记清除GC（CMS）"><a href="#并发标记清除GC（CMS）" class="headerlink" title="并发标记清除GC（CMS）"></a>并发标记清除GC（CMS）</h3><blockquote><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以最短回收停顿时间为目标的收集器适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，<strong>希望系统停顿时间最短。</strong></p><p>CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105030.png"></p><p>Concurrent Mark Sweep：并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行</p><p><font color='red'>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后，会自动将 -XX:+UseParNewGC打开，开启该参数后，使用ParNew(young 区用）+ CMS（Old 区用） + Serial Old 的收集器组合，Serial Old将作为CMS出错的后备收集器</font></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105031.png"></p><hr><h4 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h4><ul><li>初始标记（CMS initial mark）<ul><li>只是标记一个GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程</li></ul></li><li>并发标记（CMS concurrent mark）和用户线程一起<ul><li>进行GC Roots跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象</li></ul></li><li>重新标记（CMS remark）<ul><li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，在做修正</li></ul></li><li>并发清除（CMS concurrent sweep）和用户线程一起<ul><li>清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105032.png"></p><hr><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li><font color='red'>并发收集低停顿</font></li></ul><p>缺点：</p><ul><li>并发执行，对CPU资源压力大，采用的标记清除算法<font color='red'>会导致大量碎片</font></li></ul><p>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW方式进行一次GC，从而造成较大的停顿时间</p><p>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩，CMS也提供了参数 -XX:CMSFullGCSBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</p><hr><h3 id="串行GC（Serial-Old）-Serial-MSC"><a href="#串行GC（Serial-Old）-Serial-MSC" class="headerlink" title="串行GC（Serial Old） / (Serial MSC)"></a>串行GC（Serial Old） / (Serial MSC)</h3><blockquote><p>Serial Old是Serial垃圾收集器老年代版本，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机中默认的老年代垃圾收集器</p></blockquote><p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）</p><ul><li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用（Parallel Scavenge + Serial Old）</li><li>作为老年代版中使用CMS收集器的后备垃圾收集方案。</li></ul><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialOldlGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105033.png"></p><p><del><font color='red'>该垃圾收集器，目前已经不推荐使用了！！！</font></del></p><hr><h2 id="为什么新生代采用复制算法，老年代采用标整算法"><a href="#为什么新生代采用复制算法，老年代采用标整算法" class="headerlink" title="为什么新生代采用复制算法，老年代采用标整算法"></a>为什么新生代采用复制算法，老年代采用标整算法</h2><p><strong>新生代使用复制算法</strong></p><blockquote><p>因为新生代对象的生存时间比较短，80%的都要回收的对象，采用标记-清除算法则内存碎片化比较严重，采用复制算法可以灵活高效，且便与整理空间。</p></blockquote><p><strong>老年代采用标记整理</strong></p><blockquote><p>标记整理算法主要是为了解决标记清除算法存在内存碎片的问题，又解决了复制算法两个Survivor区的问题，因为老年代的空间比较大，不可能采用复制算法，特别占用内存空间</p></blockquote><h2 id="垃圾收集器如何选择"><a href="#垃圾收集器如何选择" class="headerlink" title="垃圾收集器如何选择"></a>垃圾收集器如何选择</h2><p><strong>组合的选择</strong></p><ul><li>单CPU或者小内存，单机程序<ul><li>-XX:+UseSerialGC</li></ul></li><li>多CPU，需要最大的吞吐量，如后台计算型应用<ul><li>-XX:+UseParallelGC（这两个相互激活）</li><li>-XX:+UseParallelOldGC</li></ul></li><li>多CPU，追求低停顿时间，需要快速响应如互联网应用<ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+ParNewGC</li></ul></li></ul><table><thead><tr><th>参数</th><th>新生代垃圾收集器</th><th>新生代算法</th><th>老年代垃圾收集器</th><th>老年代算法</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>SerialGC</td><td>复制</td><td>SerialOldGC</td><td>标记整理</td></tr><tr><td>-XX:+UseParNewGC</td><td>ParNew</td><td>复制</td><td>SerialOldGC</td><td>标记整理</td></tr><tr><td>-XX:+UseParallelGC</td><td>Parallel [Scavenge]</td><td>复制</td><td>Parallel Old</td><td>标记整理</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>ParNew</td><td>复制</td><td>CMS + Serial Old的收集器组合，Serial Old作为CMS出错的后备收集器</td><td><strong>标记清除</strong></td></tr><tr><td>-XX:+UseG1GC</td><td>G1整体上采用标记整理算法</td><td>局部复制</td><td></td><td></td></tr></tbody></table><hr><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><blockquote><p>问题8：G1垃圾收集器</p></blockquote><p>开启G1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><p><strong>以前收集器的特点：</strong></p><ul><li>年轻代和老年代是各自独立且连续的内存块</li><li>年轻代收集使用单eden + S0 + S1 进行复制算法</li><li>老年代收集必须扫描珍整个老年代区域</li><li>都是以尽可能少而快速地执行GC为设计原则</li></ul><hr><h3 id="G1是什么"><a href="#G1是什么" class="headerlink" title="G1是什么"></a>G1是什么</h3><blockquote><p>G1：Garbage-First 收集器，是一款面向服务端应用的收集器，应用在多处理器和大容量内存环境中，<code>在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求。</code></p></blockquote><p>另外，它还具有一下特征：</p><ul><li>像CMS收集器一样，能与应用程序并发执行</li><li>整理空闲空间更快</li><li>需要更多的时间来预测GC停顿时间</li><li>不希望牺牲大量的吞吐量性能</li><li>不需要更大的Java Heap</li></ul><p>G1收集器设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色</p><ul><li>G1是一个有整理内存过程的垃圾收集器，<font color='red'>不会产生很多内存碎片。</font></li><li>G1的Stop The World（STW）更可控，<font color='red'>G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</font></li></ul><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器</p><p>G1是在2012才在JDK1.7中可用，Oracle官方计划在JDK9中将G1变成默认的垃圾收集器以替代CMS，它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换Java8以前的CMS收集器</p><p><font color='orange'>主要改变时：Eden，Survivor 和 Tenured 等内存区域不再是连续了，而是变成一个个大小一样的region，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</font></p><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW</li><li>G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片</li><li>宏观上看G1之中不再区分年轻代和老年代。把内存划分成多个独立的子区域（Region），可以近似理解为一个围棋的棋盘</li><li>G1收集器里面将整个内存区域都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但他们不再是物理隔离的，而是通过一部分Region的集合且不需要Region是连续的，也就是说依然会采取不同的GC方式来处理不同的区域</li><li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的Survivor（to space）堆做复制准备，<strong>G1只有逻辑上的分代概念</strong>，或者说每个分区都可能随G1的运行在不同代之间前后切换。</li></ul><hr><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><blockquote><p>Region区域化垃圾收集器，化整为零，打破了原来新生区和老年区的壁垒，<code>避免了全内存扫描，只需要按照区域来进行扫描即可。</code></p></blockquote><p>区域化内存划片Region，整体遍为了一些列不连续的内存区域，避免了全内存区的GC操作。</p><p>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置子区域大小</p><p><strong>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可</strong>，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code> 可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。</p><p>大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048 = 64G内存</p><p>Region区域化垃圾收集器</p><h4 id="Region区域化垃圾收集器"><a href="#Region区域化垃圾收集器" class="headerlink" title="Region区域化垃圾收集器"></a>Region区域化垃圾收集器</h4><p>G1将新生代、老年代的物理空间划分取消了</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105034.png"></p><p>同时对内存进行了区域划分</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105035.png" alt="image-20200326120130427"></p><p>G1算法将堆划分为若干个区域（Reign），它仍然属于分代收集器，这些Region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</p><p>这些Region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片的问题存在了。</p><p>在G1中，还有一种特殊的区域，叫做Humongous（巨大的）区域，如果一个对象占用了空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象，这些巨型对象默认直接分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p><hr><h4 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h4><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是<strong>小区域收集 + 形成连续的内存块</strong>，避免内碎片</p><ul><li>Eden区的数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会晋升到Old区</li><li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区</li><li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105036.png" alt="image-20200326121409237"></p><p>回收完成后</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105037.png" alt="image-20200326121622208"></p><p>小区域收集 + 形成连续的内存块，最后在收集完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p><hr><h4 id="四步过程"><a href="#四步过程" class="headerlink" title="四步过程"></a>四步过程</h4><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105038.png"></p><hr><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>开发人员仅仅需要申明以下参数即可</p><p>三步归纳：<code>-XX:+UseG1GC -Xmx32G -XX:MaxGCPauseMillis=100</code></p><p>-XX:MaxGCPauseMillis=n：最大GC停顿时间单位毫秒，这是个软目标，JVM尽可能停顿小于这个时间 </p><p><strong>常用配置（了解）：</strong></p><ul><li>-XX:UseG1GC：使用G1垃圾回收器</li><li>-XX:G1HeapRegionSize=n：划分region大小</li><li>-XX:MaxGCPauseMillis：最大GC停顿时间，是个软目标，尽量达到。</li><li>-XX:InitiatingHeapOccupancyPercent：堆占用了多少执行GC，默认45%</li><li>-XX:ConcGCThreads：并发GC使用的线程数</li><li>-XX:G1ReservePercent：设置为空闲空间的预留内存比</li></ul><hr><h3 id="G1和CMS比较"><a href="#G1和CMS比较" class="headerlink" title="G1和CMS比较"></a>G1和CMS比较</h3><ul><li>G1不会产生内碎片</li><li>是可以精准控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。</li></ul><hr><h2 id="SpringBoot结合JVMGC"><a href="#SpringBoot结合JVMGC" class="headerlink" title=" SpringBoot结合JVMGC"></a><font color='red'> SpringBoot结合JVMGC</font></h2><p>启动微服务时候，就可以带上JVM和GC的参数</p><ul><li>IDEA开发完微服务工程</li><li>maven进行clean package：打成jar包或者war包</li><li>要求微服务启动的时候，同时配置我们的JVM/GC的调优参数<ul><li>我们就可以根据具体的业务配置我们启动的JVM参数</li></ul></li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xms1024m -Xmx1024 -XX:UseG1GC -jar   xxx.jar</span><br></pre></td></tr></table></figure><p>可以使用<code>jps -l</code>查看端口号，使用<code>jinfo -flags 端口号</code>查看我们配置的参数</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;5-垃圾收集器&quot;&gt;&lt;a href=&quot;#5-垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;5_垃圾收集器&quot;&gt;&lt;/a&gt;5_垃圾收集器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;问题5：GC垃圾回收算法和垃圾收集器关系？分别是什么请你谈谈？&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JVM" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>4_Java内存溢出OOM</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/4-Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAOOM/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/4-Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAOOM/</id>
    <published>2021-02-17T02:47:57.000Z</published>
    <updated>2021-02-17T02:48:31.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-Java内存溢出OOM"><a href="#4-Java内存溢出OOM" class="headerlink" title="4_Java内存溢出OOM"></a>4_Java内存溢出OOM</h1><p>JVM中常见的两个错误</p><p>StackoverFlowError ：栈溢出</p><p>OutofMemoryError: java heap space：堆溢出</p><p>除此之外，还有以下的错误</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><hr><p><strong>架构：</strong></p><p>OutOfMemoryError和StackOverflowError是属于Error，不是Exception</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104822.png"></p><h2 id="StackoverFlowError"><a href="#StackoverFlowError" class="headerlink" title="StackoverFlowError"></a>StackoverFlowError</h2><blockquote><p>堆栈溢出，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p></blockquote><p>栈一般是512K，不断的深度调用，直到栈被撑破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowErrorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈一般是512K，不断的深度调用，直到栈被撑破</span><br><span class="line">     * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void stackOverflowError() &#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.moxi.interview.study.oom.StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:17)</span><br></pre></td></tr></table></figure><hr><h2 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h2><blockquote><p><code>java heap space</code></p><p>创建了很多对象，导致堆空间不够存储</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Java堆内存不足</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JavaHeapSpaceDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 堆空间的大小 -Xms10m -Xmx10m</span><br><span class="line">        &#x2F;&#x2F; 创建一个 80M的字节数组</span><br><span class="line">        byte [] bytes &#x3D; new byte[80 * 1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个80M的数组，会直接出现Java heap space</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><hr><h2 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h2><blockquote><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，<font color='red'>超过了98%的时间用来做GC，并且回收了不到2%的堆内存</font></p></blockquote><p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p><p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104823.png"></p><hr><p><strong>代码演示：</strong></p><p>为了更快的达到效果，我们首先需要设置JVM启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br></pre></td></tr></table></figure><p>这个异常出现的步骤就是，我们不断的向list中插入String对象，直到启动GC回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * GC 回收超时</span><br><span class="line"> * JVM参数配置: -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class GCOverheadLimitDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                list.add(String.valueOf(++i).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;***************i:&quot; + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7106K-&gt;7106K(7168K)] 9154K-&gt;9154K(9728K), [Metaspace: 3504K-&gt;3504K(1056768K)], 0.0311093 secs] [Times: user&#x3D;0.13 sys&#x3D;0.00, real&#x3D;0.03 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7136K-&gt;667K(7168K)] 9184K-&gt;667K(9728K), [Metaspace: 3540K-&gt;3540K(1056768K)], 0.0058093 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 114K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 5% used [0x00000000ffd00000,0x00000000ffd1c878,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 667K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a6ff8,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3605K, capacity 4540K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 399K, capacity 428K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">at java.lang.Integer.toString(Integer.java:403)</span><br><span class="line">at java.lang.String.valueOf(String.java:3099)</span><br><span class="line">at com.moxi.interview.study.oom.GCOverheadLimitDemo.main(GCOverheadLimitDemo.java:18)</span><br></pre></td></tr></table></figure><p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 <code>GC overhead limit</code></p><hr><h2 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h2><blockquote><p>Netty + NIO：<code>这是由于NIO引起的</code></p><p>写NIO程序的时候经常会使用ByteBuffer来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</p></blockquote><p>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><ul><li>ByteBuffer.allocate(capability)：第一种方式是<font color='red'>分配JVM堆内存，属于GC管辖范围</font>，由于需要拷贝所以速度相对较慢</li><li>ByteBuffer.allocteDirect(capability)：第二种方式是<font color='red'>分配OS本地内存，不属于GC管辖范围</font>，由于不需要内存的拷贝，所以速度相对较快</li></ul><p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104824.png"></p><p><font color='orange'>一句话说：本地内存不足，但是堆内存充足的时候，就会出现这个问题</font></p><hr><p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br></pre></td></tr></table></figure><p>然后我们申请一个6M的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只设置了5M的物理内存使用，但是却分配 6M的空间</span><br><span class="line">ByteBuffer bb &#x3D; ByteBuffer.allocateDirect(6 * 1024 * 1024);</span><br></pre></td></tr></table></figure><p>这个时候，运行就会出现问题了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">配置的maxDirectMemory：5.0MB</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2030K-&gt;488K(2560K)] 2030K-&gt;796K(9728K), 0.0008326 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 308K-&gt;712K(7168K)] 796K-&gt;712K(9728K), [Metaspace: 3512K-&gt;3512K(1056768K)], 0.0052052 secs] [Times: user&#x3D;0.09 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:693)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">at com.moxi.interview.study.oom.DIrectBufferMemoryDemo.main(DIrectBufferMemoryDemo.java:19)</span><br></pre></td></tr></table></figure><hr><h2 id="unable-to-create-new-native-thread"><a href="#unable-to-create-new-native-thread" class="headerlink" title="unable to create new native thread"></a>unable to create new native thread</h2><blockquote><p>不能够创建更多的新的线程了，也就是说<code>创建线程的上限达到了</code></p></blockquote><p>在高并发场景的时候，会应用到</p><p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p><p><strong>导致原因：</strong></p><ul><li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li><li>服务器并不允许你的应用程序创建这么多线程，linux系统默认运行单个进程可以创建的线程为1024个，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li></ul><p><strong>解决方法：</strong></p><ol><li>想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li><li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过修改linux服务器配置，扩大linux默认限制</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">![4](images&#x2F;4.png)&#x2F;**</span><br><span class="line"> * 无法创建更多的线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UnableCreateNewThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; ; i++) &#123;</span><br><span class="line">            System.out.println(&quot;************** i &#x3D; &quot; + i);</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，就会出现下列的错误，线程数大概在 900多个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to cerate new native thread</span><br></pre></td></tr></table></figure><p>如何查看线程数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -u</span><br></pre></td></tr></table></figure><p>修改配置方法：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104825.png"></p><hr><h2 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h2><blockquote><p>元空间内存不足，Matespace元空间应用的是本地内存</p><p><code>-XX:MetaspaceSize</code> 的初始化化大小为20M</p></blockquote><h3 id="元空间是什么"><a href="#元空间是什么" class="headerlink" title="元空间是什么"></a>元空间是什么</h3><p><strong>元空间就是我们的方法区，存放的是类模板，类信息，常量池等</strong></p><p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p><p>永久代（java8后背元空间Metaspace取代了）存放了以下信息：</p><ul><li>虚拟机加载的类信息</li><li>常量池</li><li>静态变量</li><li>即时编译后的代码</li></ul><hr><p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;8m -XX:MaxMetaspaceSize&#x3D;8m</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 元空间溢出</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MetaspaceOutOfMemoryDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态类</span><br><span class="line">    static class OOMTest &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟计数多少次以后发生异常</span><br><span class="line">        int i &#x3D;0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                &#x2F;&#x2F; 使用Spring的动态字节码技术</span><br><span class="line">                Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">                enhancer.setSuperclass(OOMTest.class);</span><br><span class="line">                enhancer.setUseCache(false);</span><br><span class="line">                enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">                        return methodProxy.invokeSuper(o, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;发生异常的次数:&quot; + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发生异常的次数: 201</span><br><span class="line">java.lang.OutOfMemoryError:Metaspace</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-Java内存溢出OOM&quot;&gt;&lt;a href=&quot;#4-Java内存溢出OOM&quot; class=&quot;headerlink&quot; title=&quot;4_Java内存溢出OOM&quot;&gt;&lt;/a&gt;4_Java内存溢出OOM&lt;/h1&gt;&lt;p&gt;JVM中常见的两个错误&lt;/p&gt;
&lt;p&gt;Stackov</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JVM" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>3_Java中的引用</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/3-Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/3-Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</id>
    <published>2021-02-17T02:47:01.000Z</published>
    <updated>2021-02-17T02:47:30.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-Java中的引用"><a href="#3-Java中的引用" class="headerlink" title="3_Java中的引用"></a>3_Java中的引用</h1><p>在原来的时候，我们谈到一个类的实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; new Person()</span><br></pre></td></tr></table></figure><p>在等号的左边，就是一个对象的引用，存储在栈中</p><p>而等号右边，就是实例化的对象，存储在堆中</p><p>其实这样的一个引用关系，就被称为强引用</p><hr><p> 整体架构</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104721.png"></p><hr><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><blockquote><p>当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，<font color='red'>就算是出现了OOM也不会对该对象进行回收，打死也不回收~！</font></p></blockquote><p>强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。</p><p>在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，<strong>因此强引用是造成Java内存泄漏的主要原因之一。</strong></p><p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用于或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p><hr><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这样定义的默认就是强应用</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用第二个引用，指向刚刚创建的Object对象</span></span><br><span class="line">        Object obj2 = obj1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置空</span></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并没有将该对象进行垃圾回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">java.lang.Object@14ae5a5</span><br></pre></td></tr></table></figure><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><blockquote><p>软引用是一种相对弱化了一些的引用，需要用<code>Java.lang.ref.SoftReference</code>类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p><ul><li><font color='red'>当系统内存充足时，它不会被回收</font></li><li><font color='red'>当系统内存不足时，它会被回收</font></li></ul></blockquote><p>软引用通常在对内存敏感的程序中，比如高速缓存就用到了软引用，<strong>内存够用 的时候就保留，不够用就回收</strong></p><hr><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存够用的时候</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个强应用</span></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个软引用</span></span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span></span><br><span class="line"><span class="comment">     * -Xms5m -Xmx5m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryNoEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个强应用</span></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个软引用</span></span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟OOM自动GC</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建30M的大对象</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        softRefMemoryEnough();</span><br><span class="line"></span><br><span class="line">        softRefMemoryNoEnough();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>情况一：</strong></p><p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p><p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p><p>然后我们把o1设置为null，执行手动GC后，我们发现softReference的值还存在，说明内存充足的时候，软引用的对象不会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1396K-&gt;504K(1536K)] 1504K-&gt;732K(5632K), <span class="number">0.0007842</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 504K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 228K-&gt;651<span class="title">K</span><span class="params">(4096K)</span>] 732K-&gt;651<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3480K-&gt;3480<span class="title">K</span><span class="params">(1056768K)</span>], 0.0058450 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">java.lang.Object@14ae5a5</span><br></pre></td></tr></table></figure><hr><p><strong>情况二：</strong></p><p>下面我们看当内存不够的时候，我们使用了JVM启动参数配置，给初始化堆内存为5M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms5m -Xmx5m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>但是在创建对象的时候，我们创建了一个30M的大对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建30M的大对象</span><br><span class="line">byte[] bytes &#x3D; new byte[30 * 1024 * 1024];</span><br></pre></td></tr></table></figure><p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明，软引用在内存不足的时候，会自动回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@7f31245a</span><br><span class="line">java.lang.Object@7f31245a</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 31K-&gt;160K(1536K)] 682K-&gt;811K(5632K), <span class="number">0.0003603</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 160K-&gt;96K(1536K)] 811K-&gt;747K(5632K), <span class="number">0.0006385</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 96K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 651K-&gt;646<span class="title">K</span><span class="params">(4096K)</span>] 747K-&gt;646<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3488K-&gt;3488<span class="title">K</span><span class="params">(1056768K)</span>], 0.0067976 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 646K-&gt;646K(5632K), <span class="number">0.0004024</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 646K-&gt;627<span class="title">K</span><span class="params">(4096K)</span>] 646K-&gt;627<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3488K-&gt;3488<span class="title">K</span><span class="params">(1056768K)</span>], 0.0065506 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><hr><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><blockquote><p><font color='red'>不管内存是否够，只要有GC操作就会进行回收</font></p><p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的空间。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看结果，能够发现，我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5246K-&gt;808K(76288K)] 5246K-&gt;816K(251392K), 0.0008236 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;675K(175104K)] 816K-&gt;675K(251392K), [Metaspace: 3494K-&gt;3494K(1056768K)], 0.0035953 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line"></span><br><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure><hr><h2 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h2><blockquote><p>场景：假如有一个应用需要读取大量的本地图片</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能</li><li>如果一次性全部加载到内存中，又可能造成内存溢出</li></ul><p>说明：下面方式使用<code>弱引用</code>也可以完成！</p></blockquote><p>此时使用软引用可以解决这个问题</p><p><strong>设计思路：</strong> 使用HashMap来保存图片的路径和相应图片<code>对象关联的软引用</code>之间的映射关系，<font color='red'>在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache &#x3D; new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure><hr><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>比如一些常常和底层打交道的，mybatis等，底层都应用到了WeakHashMap</p><blockquote><p>WeakHashMap和HashMap类似，只不过它的Key是使用了弱引用的，也就是说，当执行GC的时候，HashMap中的key会进行回收，</p></blockquote><p>下面我们使用例子来测试一下</p><p>我们使用了两个方法，一个是普通的HashMap方法</p><p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    String value = <span class="string">&quot;HashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    System.gc();</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个是使用了WeakHashMap，完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        myHashMap();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        myWeakHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        String value = <span class="string">&quot;HashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        String value = <span class="string">&quot;WeakHashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;1&#x3D;HashMap&#125;</span><br><span class="line">&#123;1&#x3D;HashMap&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#123;1&#x3D;WeakHashMap&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p><p>但是WeakHashMap，在进行GC操作后，弱引用的就会被回收</p><hr><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><blockquote><p>虚引用又称为幽灵引用，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p><p>顾名思义，就是<code>形同虚设</code>，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p><p>如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，<strong>虚引用必须和引用队列ReferenceQueue联合使用。</strong></p><p><font color='red'>虚引用的主要作用和跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</font></p><p><strong>PhantomReference的get方法总是返回null</strong>，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>换句话说，设置虚引用关联的唯一目的，<strong>就是在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</strong></p><p>这个就相当于Spring AOP里面的后置通知</p></blockquote><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><blockquote><p>一般用于在回收时候做通知相关操作</p></blockquote><p>软引用，弱引用，虚引用在回收之前，需要在引用队列保存一下</p><p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object o1 &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建引用队列</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个弱引用</span><br><span class="line">WeakReference&lt;Object&gt; weakReference &#x3D; new WeakReference&lt;&gt;(o1, referenceQueue);</span><br></pre></td></tr></table></figure><p>那么在进行GC回收的时候，弱引用和虚引用的对象都会被回收，但是在回收之前，它会被送至引用队列中</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个弱引用</span></span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个弱引用</span></span><br><span class="line"><span class="comment">//        PhantomReference&lt;Object&gt; weakReference = new PhantomReference&lt;&gt;(o1, referenceQueue);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        <span class="comment">// 取队列中的内容</span></span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行GC操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        <span class="comment">// 取队列中的内容</span></span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">null</span><br><span class="line">执行GC操作</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">java.lang.ref.WeakReference@7f3124</span><br></pre></td></tr></table></figure><p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例被放置引用队列中了，我们可以通过引用队列进行一些后置操作</p><hr><h2 id="GCRoots和四大引用小总结"><a href="#GCRoots和四大引用小总结" class="headerlink" title="GCRoots和四大引用小总结"></a>GCRoots和四大引用小总结</h2><ul><li>红色部分在垃圾回收之外，也就是强引用的</li><li>蓝色部分：属于软引用，在内存不够的时候，才回收</li><li>虚引用和弱引用：每次垃圾回收的时候，都会被干掉，但是它在干掉之前还会存在引用队列中，我们可以通过引用队列进行一些通知机制</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104722.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-Java中的引用&quot;&gt;&lt;a href=&quot;#3-Java中的引用&quot; class=&quot;headerlink&quot; title=&quot;3_Java中的引用&quot;&gt;&lt;/a&gt;3_Java中的引用&lt;/h1&gt;&lt;p&gt;在原来的时候，我们谈到一个类的实例化&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JVM" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2_JVM参数调优</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/2-JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/2-JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/</id>
    <published>2021-02-17T02:45:47.000Z</published>
    <updated>2021-02-17T02:46:40.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-JVM参数调优"><a href="#2-JVM参数调优" class="headerlink" title="2_JVM参数调优"></a>2_JVM参数调优</h1><blockquote><p>题目2：你说你做过JVM调优和参数配置，请问如何盘点查看 <code>JVM系统默认值</code>？</p></blockquote><p>使用 jps 和 jinfo 进行查看</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 调整JVM初始化参数（-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收）</span></span><br><span class="line">-Xms：初始堆空间</span><br><span class="line">-Xmx：堆最大值</span><br><span class="line">-Xss：栈空间</span><br></pre></td></tr></table></figure><hr><h2 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h2><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><blockquote><p>从JDK1.0 - Java12都在，很稳定</p></blockquote><ul><li>-version</li><li>-help</li><li>java -showversion</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104624.png"></p><hr><h3 id="X参数（了解）"><a href="#X参数（了解）" class="headerlink" title="X参数（了解）"></a>X参数（了解）</h3><ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104625.png"></p><hr><h3 id="XX参数（重点）"><a href="#XX参数（重点）" class="headerlink" title="XX参数（重点）"></a><font color='red'>XX参数（重点）</font></h3><h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><blockquote><p>公式：</p><ul><li>-XX:+ 或者-某个属性</li><li>+表示开启，-表示关闭</li></ul></blockquote><hr><h5 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h5><blockquote><p>-XX:-PrintGCDetails：表示关闭了GC详情输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps：查看java的后台进程</span><br><span class="line">jinfo：查看正在运行的java程序</span><br></pre></td></tr></table></figure><p><strong>查看运行的Java程序，JVM参数是否开启，具体值为多少？</strong></p></blockquote><p>首先我们运行一个HelloGC的 Java 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-27 13:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello GC&quot;</span>);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104626.png"></p><hr><p>然后查看java的后台进程：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 得到进程号</span></span><br><span class="line">jps -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104627.png"></p><hr><p>然后查看是否开启PrintGCDetails这个参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># + 表示开启，-号 表示没开启</span></span><br><span class="line">jinfo -flag PrintGCDetails 9936</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104628.png"></p><p>结果表明：-号表示关闭，即没有开启PrintGCDetails这个参数</p><hr><p>最后：需要在启动HelloGC的时候，增加 PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104629.png"></p><p>在VM Options中加入下面的代码，现在+号表示开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104630.png"></p><hr><p>重启启动程序，使用 <code>jps -l</code>得到进程号，使用<code>jinfo -flag PrintGCDetails 进程号</code>得到配置结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104631.png"></p><p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p><hr><p>也可以使用下列命令，会把jvm的全部默认参数输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags 进程号</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104632.png"></p><hr><h4 id="KV设值类型"><a href="#KV设值类型" class="headerlink" title="KV设值类型"></a>KV设值类型</h4><blockquote><p>-XX:属性key=值value</p></blockquote><h5 id="Case-1"><a href="#Case-1" class="headerlink" title="Case"></a>Case</h5><blockquote><p>-XX:MetaspaceSize=128m   调整元空间大小</p><p>-XX:MaxTenuringThreshold=15  调整存活年龄</p></blockquote><p>还是刚刚那个程序，首先我们查看默认的元空间大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看进程号</span></span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看默认空间（此时是键值对类型）</span></span><br><span class="line">jinfo -flag MetaspaceSize 11080</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104633.png"></p><hr><p>配置元空间大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 配置元空间大小为1024m</span></span><br><span class="line">-XX:MetaspaceSize=1024m</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104634.png"></p><p>重新启动程序，查看：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104635.png"></p><p>配置生效！</p><hr><p>同样操作：配置存活年龄</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold&#x3D;10</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104636.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104637.png"></p><hr><h4 id="jinfo：如何查看当前程序运行的配置"><a href="#jinfo：如何查看当前程序运行的配置" class="headerlink" title="jinfo：如何查看当前程序运行的配置"></a><font color='red'>jinfo：如何查看当前程序运行的配置</font></h4><blockquote><p>jinfo -flag 某个参数 pid </p><p>或者</p><p>jinfo -flags pid 显示所有参数</p></blockquote><h5 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看堆内存初始化大小</span></span><br><span class="line">jinfo -flag InitialHeapSize  15276</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104638.png"></p><hr><h5 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看全部配置信息</span></span><br><span class="line">jinfo -flags 15276</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 结果：</span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=<span class="number">12</span> -XX:InitialHeapSize=<span class="number">268435456</span> -XX:MaxHeapSize=<span class="number">4278190080</span> -XX:MaxNewSize=<span class="number">1426063360</span></span><br><span class="line">-XX:MetaspaceSize=<span class="number">1073741824</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">89128960</span> -XX:OldSize=<span class="number">179306496</span> -XX:+</span><br><span class="line">UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndivi</span><br><span class="line">dualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><hr><h4 id="题外话（坑题）"><a href="#题外话（坑题）" class="headerlink" title="题外话（坑题）"></a><font color='red'>题外话（坑题）</font></h4><blockquote><p>两个经典参数：<code>-Xms </code>和 <code>-Xmx</code>，这两个参数 如何解释？</p></blockquote><p>这两个参数，还是属于XX参数，因为取了别名</p><ul><li>-Xms 等价于 -XX:InitialHeapSize ：初始化堆内存（默认只会用最大物理内存的64分1）</li><li>-Xmx 等价于 -XX:MaxHeapSize ：最大堆内存（默认只会用最大物理内存的4分1）</li></ul><hr><p>与机器本身配置有关：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104639.png"></p><p>我们进行重新配置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 设置初始化大小200m，最大3g</span></span><br><span class="line">-Xms200m -Xmx3g</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104640.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104641.png"></p><hr><h4 id="查看JVM默认参数"><a href="#查看JVM默认参数" class="headerlink" title="查看JVM默认参数"></a>查看JVM默认参数</h4><blockquote><p>-XX:+PrintFlagsInitial</p></blockquote><h5 id="方式一：查看初始默认值"><a href="#方式一：查看初始默认值" class="headerlink" title="方式一：查看初始默认值"></a>方式一：查看<code>初始默认值</code></h5><blockquote><p>公式：</p><ul><li>java -XX:+PrintFlagsInitial -version</li><li>java -XX:+PrintFlagsInitial（重要参数）</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104642.png"></p><hr><h5 id="方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）"><a href="#方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）" class="headerlink" title="方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）"></a>方式二：<code>查看修改后的，最终的值</code>（可能是JVM，也可能是人为修改）</h5><blockquote><p>公式：</p><ul><li>-XX:+PrintFlagsFinal -version</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104643.png"></p><p>会将JVM的各个结果都进行打印</p><p><font color='red'>如果有 := 表示修改过的， = 表示没有修改过的</font></p><p>以初始化堆内存为例：我的机器是16G内存，所以JVM会划内存的1/64给堆初始化，即270m左右</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104644.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104645.png"></p><p>实例2：运行java<strong>命令的同时打印出参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -Xss128k javaClass</span><br></pre></td></tr></table></figure><hr><h5 id="方式三：查看一些常见的参数"><a href="#方式三：查看一些常见的参数" class="headerlink" title="方式三：查看一些常见的参数"></a><font color='red'>方式三：查看一些<code>常见的参数</code></font></h5><blockquote><p> -XX:+PrintCommandLineFlags</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104646.png"></p><p>该命令主要是用来查看当前使用的垃圾回收器</p><hr><h2 id="工作中常用的JVM基本配置参数"><a href="#工作中常用的JVM基本配置参数" class="headerlink" title="工作中常用的JVM基本配置参数"></a>工作中常用的JVM基本配置参数</h2><blockquote><p>题目3：用过的JVM常用基本配置参数有哪些？</p></blockquote><p>知识复习：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104647.png"></p><hr><h3 id="查看堆内存"><a href="#查看堆内存" class="headerlink" title="查看堆内存"></a>查看堆内存</h3><blockquote><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p></blockquote><p>代码方式查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-27 13:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中内存的总量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回Java虚拟机中试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="string">&quot;(字节)、&quot;</span> + (totalMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="string">&quot;(字节)、&quot;</span> + (maxMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104648.png"></p><p>-Xms 初始堆内存为：物理内存的1/64 -Xmx 最大堆内存为：系统物理内存的 1/4</p><hr><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><h4 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h4><blockquote><p>-Xms：<code>初始化堆内存</code>，默认为物理内存的1/64，</p><p>等价于 -XX:initialHeapSize</p></blockquote><hr><h4 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h4><blockquote><p>-Xmx：<code>最大堆内存</code>，默认为物理内存的1/4，</p><p>等价于-XX:MaxHeapSize</p></blockquote><hr><h4 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h4><blockquote><p>-Xss：设计<code>单个线程栈的大小</code>，一般默认为512K~1024K，</p><p>等价于 -XX:ThreadStackSize</p></blockquote><p>使用 jinfo -flag ThreadStackSize 会发现 -XX:ThreadStackSize = 0</p><p>原因：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 官网解释（JDK8）</span></span><br><span class="line">Linux/x64:1024KB</span><br><span class="line">OS X：1024KB</span><br><span class="line">Oracle Solaris：1024KB</span><br><span class="line">Windows：取决于虚拟内存的大小</span><br></pre></td></tr></table></figure><hr><h4 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h4><blockquote><p>设置<code>元空间大小</code>。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。</p><p>元空间与永久代的最大区别在于，永久代在虚拟机中（占用堆内存），而元空间在本地内存中（占用物理内存）。</p><p>为了防止在频繁的实例化对象的时候，让元空间出现OOM，因此可以把元空间设置的大一些</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看默认配置大小(大约21m)</span></span><br><span class="line">java -XX:+PrintFlagsFinal -version</span><br><span class="line"></span><br><span class="line"><span class="section"># 设置元空间大小</span></span><br><span class="line">-XX:+MetaspaceSize=1024m</span><br></pre></td></tr></table></figure><hr><h4 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a><font color='red'>-XX:+PrintGCDetails</font></h4><blockquote><p>输出GC收集<code>日志信息</code></p><p>分为：</p><ul><li>GC</li><li>Full GC</li></ul></blockquote><p>我们使用一段代码，制造出垃圾回收的过程</p><p>首先我们设置一下程序的启动配置: 设置初始堆内存为10M，最大堆内存为10M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>然后用下列代码，创建一个 非常大空间的byte类型数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte [] byteArray &#x3D; new byte[50 * 1024 * 1024];</span><br></pre></td></tr></table></figure><p>运行后，发现会出现下列错误，这就是OOM：<code>java内存溢出，也就是堆空间不足</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104649.png"></p><p>同时还打印出了GC垃圾回收时候的详情</p><p>问题发生的原因：因为们通过 -Xms10m 和 -Xmx10m 只给Java堆栈设置了10M的空间，但是创建了50M的对象，因此就会出现空间不足，而导致出错</p><p>同时在垃圾收集的时候，我们看到有两个对象：GC 和 Full GC</p><hr><h6 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h6><blockquote><p>GC垃圾回收发生在<code>新生代</code>。</p></blockquote><hr><p><strong>参数图：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104650.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># GC信息（GC (Allocation Failure)：表示分配失败，那么就需要触发年轻代空间中的内容被回收）</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1580K-&gt;504K(2560K)] 1580K-&gt;764K(9728K), 0.0167268 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] </span><br></pre></td></tr></table></figure><hr><h6 id="Full-GC垃圾回收"><a href="#Full-GC垃圾回收" class="headerlink" title="Full GC垃圾回收"></a>Full GC垃圾回收</h6><blockquote><p>Full GC大部分发生在<code>养老区</code></p></blockquote><p><strong>参数图：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104651.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Full GC</span></span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 592K-&gt;574K(7168K)] 592K-&gt;574K(9728K), [Metaspace: 3158K-&gt;3158K(1056768K)], 0.0040996 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br></pre></td></tr></table></figure><hr><p><font color='red'>规律：</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[名称： GC前内存占用 -&gt; GC后内存占用 (该区内存总大小)]</span><br></pre></td></tr></table></figure><p><font color='red'>当我们出现了老年代都扛不住的时候，就会出现OOM异常</font></p><hr><h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><p>VM综合配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss1024k -Xms200m -Xmx4g -XX:MetaspaceSize&#x3D;1024m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><ul><li>-Xss1024k  栈大小</li><li>-Xms200m  堆初始化大小</li><li>-Xmx4g   堆最大值</li><li>-XX:MetaspaceSize=1024m  元空间大小</li><li>-XX:+PrintCommandLineFlags  打印常用配置</li><li>-XX:+PrintGCDetails   打印日志信息</li><li>-XX:+UseSerialGC   使用垃圾回收器的名称（串行回收器）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104652.png"></p><hr><h4 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h4><blockquote><p>调节新生代中<code> eden 和 S0、S1的空间比例，</code></p></blockquote><p>默认为 -XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104653.png"></p><p>我们设置如下参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 分配堆内存为10m（此时新生代大约占2~3m）</span></span><br><span class="line">-Xms10m -Xmx10m  -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><hr><p>假如设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p><p>SurvivorRatio值就是设置eden区的比例占多少？S0和S1相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m  -XX:+PrintGCDetails -XX:SurvivorRatio&#x3D;4</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104654.png"></p><hr><h4 id="XX-NewRatio（了解）"><a href="#XX-NewRatio（了解）" class="headerlink" title="-XX:NewRatio（了解）"></a>-XX:NewRatio（了解）</h4><blockquote><p>配置<code>年轻代new 和老年代old 在堆结构的占比</code></p><p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p></blockquote><p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p><p><font color='orange'>新生代特别小，会造成频繁的进行GC收集</font></p><hr><h4 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h4><blockquote><p>设置<code>垃圾最大年龄</code></p><p>SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代。</p><p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看默认进入老年代年龄：</span></span><br><span class="line">jinfo -flag MaxTenuringThreshold 进程号</span><br><span class="line"></span><br><span class="line"><span class="section"># 设置年龄：</span></span><br><span class="line"> -XX:MaxTenuringThreshold=15</span><br></pre></td></tr></table></figure><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-JVM参数调优&quot;&gt;&lt;a href=&quot;#2-JVM参数调优&quot; class=&quot;headerlink&quot; title=&quot;2_JVM参数调优&quot;&gt;&lt;/a&gt;2_JVM参数调优&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目2：你说你做过JVM调优和参数配置，请问如何盘点查看 </summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JVM" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>1_GC Roots分析</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/1-GC-Roots%E5%88%86%E6%9E%90/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/1-GC-Roots%E5%88%86%E6%9E%90/</id>
    <published>2021-02-17T02:44:35.000Z</published>
    <updated>2021-02-17T02:45:27.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-GC-Roots分析"><a href="#1-GC-Roots分析" class="headerlink" title="1_GC Roots分析"></a>1_GC Roots分析</h1><blockquote><p>题目1：JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots</p></blockquote><hr><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><blockquote><p>简单来说就是：内存中已经不再被使用的空间就是垃圾</p></blockquote><hr><h2 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><del>引用计数法</del></h3><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收</p><p>简单说，给对象中添加一个<code>引用计数器</code>，每当有一个地方引用它，计数器值加1，每当有一个引用失效，计数器值减1，任何时刻计数器值<code>为零</code>的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104521.png"></p><p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它<code>很难解决对象之间相互循环引用的问题</code>。该算法存在但目前无人用了，解决不了循环引用的问题，了解即可。</p><hr><h3 id="枚举根节点做可达性分析"><a href="#枚举根节点做可达性分析" class="headerlink" title="枚举根节点做可达性分析"></a>枚举根节点做可达性分析</h3><blockquote><p><code>根搜索路径算法</code>：为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法</p><p>所谓 GC Roots 或者说 Tracing Roots的“根集合” 就是<font color='red'>一组必须活跃的引用 </font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104522.png"></p><p>基本思路：就是通过<font color='red'>一系列名为 GC Roots的对象作为起始点</font>，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的对象就被判定为死亡</p><hr><p><strong>举例1说明：</strong></p><blockquote><p>必须从<code>GC Roots对象</code>开始，这个类似于linux的 / 也就是根目录：</p><ul><li>蓝色部分是从GC Roots出发，能够循环可达</li><li>而白色部分未从GC Roots出发，无法到达</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104523.png"></p><hr><p><strong>举例2说明：</strong></p><blockquote><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p></blockquote><p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p><p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p><p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p><hr><h2 id="哪些对象可以当做GC-Roots"><a href="#哪些对象可以当做GC-Roots" class="headerlink" title="哪些对象可以当做GC Roots"></a>哪些对象可以当做GC Roots</h2><ul><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li><li>本地方法栈中的JNI（Native方法）的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><hr><p> <strong>代码说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Java中，可以作为GC Roots的对象有：</span></span><br><span class="line"><span class="comment"> * - 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</span></span><br><span class="line"><span class="comment"> * - 方法区中的类静态属性引用的对象</span></span><br><span class="line"><span class="comment"> * - 方法区中常量引用的对象</span></span><br><span class="line"><span class="comment"> * - 本地方法栈中的JNI（Native方法）的引用对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法区中的类静态属性引用的对象</span></span><br><span class="line">    <span class="comment">// private static GCRootDemo2 t2;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span></span><br><span class="line">    <span class="comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种，虚拟机栈中的引用对象</span></span><br><span class="line">        GCRootDemo t1 = <span class="keyword">new</span> GCRootDemo();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-GC-Roots分析&quot;&gt;&lt;a href=&quot;#1-GC-Roots分析&quot; class=&quot;headerlink&quot; title=&quot;1_GC Roots分析&quot;&gt;&lt;/a&gt;1_GC Roots分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目1：JVM垃圾回收的时候如何确</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JVM" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>0_JVM体系结构</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/0-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/0-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2021-02-17T02:42:42.000Z</published>
    <updated>2021-02-17T02:43:53.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-JVM体系结构"><a href="#0-JVM体系结构" class="headerlink" title="0_JVM体系结构"></a>0_JVM体系结构</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104258.jpg"></p><hr><p>Java gc 主要回收的是 <strong>方法区</strong> 和 <strong>堆</strong> 中的内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104259.png"></p><hr><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>常考考点：</p><ul><li>类加载器是什么</li><li>双亲委派机制</li><li>Java类加载的沙箱安全机制</li></ul><hr><h2 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a><del>引用计数</del></h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104300.png"></p><hr><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><blockquote><p>复制算法在<code>年轻代</code>的时候，进行使用，复制时候有交换</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104301.png"></p><p>优点：没有内存碎片</p><p>缺点：消耗内存</p><hr><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><blockquote><p>先标记，后清除。用于<code>老年代</code>多一些</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104302.png"></p><p>优点：不会消耗那么多内存</p><p>缺点：会产生内存碎片</p><hr><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><blockquote><p>也叫标记清除整理，多用于<code>老年代</code></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104303.png"></p><p>优点：不会消耗太多内存；不会有内存碎片</p><p>缺点：比较耗时</p><hr><p>总结：没有完美的算法，只有合适的算法，一般采用<code>分代收集算法</code></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-JVM体系结构&quot;&gt;&lt;a href=&quot;#0-JVM体系结构&quot; class=&quot;headerlink&quot; title=&quot;0_JVM体系结构&quot;&gt;&lt;/a&gt;0_JVM体系结构&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="JVM" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux诊断原因</title>
    <link href="http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Linux/Linux%E8%AF%8A%E6%96%AD%E5%8E%9F%E5%9B%A0/"/>
    <id>http://jiangbk.top/2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Linux/Linux%E8%AF%8A%E6%96%AD%E5%8E%9F%E5%9B%A0/</id>
    <published>2021-02-17T02:41:10.000Z</published>
    <updated>2021-02-17T02:42:09.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux诊断原因"><a href="#Linux诊断原因" class="headerlink" title="Linux诊断原因"></a>Linux诊断原因</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><blockquote><p>问题9：生产环境服务器变慢，诊断思路和性能评估谈谈？</p></blockquote><p>运行服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xms xxx参数名字 -jar </span><br></pre></td></tr></table></figure><hr><h3 id="top：查看整机系统新能"><a href="#top：查看整机系统新能" class="headerlink" title="top：查看整机系统新能"></a>top：查看整机系统新能</h3><blockquote><ul><li>load average三个指标：分别代表1、5、15分钟的负载情况</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104152.png"></p><p>重点关注的是 %CPU、%MEM 、load average 三个指标</p><p>在这个命令下，按1的话，可以看到每个CPU的占用情况</p><hr><h3 id="uptime精简版"><a href="#uptime精简版" class="headerlink" title="uptime精简版"></a>uptime精简版</h3><blockquote><p>系统性能命令的精简版</p></blockquote><hr><h3 id="CPU：vmstat"><a href="#CPU：vmstat" class="headerlink" title="CPU：vmstat"></a>CPU：vmstat</h3><blockquote><p>查看CPU（包含但是不限于）</p><p>查看额外</p><ul><li>查看所有CPU核信息：mpstat -p ALL 2</li><li>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</li></ul></blockquote><hr><p>命令格式：<code>vmstat -n 2 3</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104153.png"></p><p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数（单位秒），第二个参数是采样的次数</p><p><strong>procs</strong></p><ul><li> r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了2，说明现在压力过大</li><li> b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等</li></ul><p><strong>cpu</strong></p><ul><li> us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序</li><li> sy：内核进程消耗的CPU时间百分比</li><li> us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明CPU消耗不是很高</li><li> id：处于空闲的CPU百分比</li><li> wa：系统等待IO的CPU时间百分比</li><li> st：来自于一个虚拟机偷取的CPU时间比</li></ul><hr><h3 id="内存：free"><a href="#内存：free" class="headerlink" title="内存：free"></a>内存：free</h3><p>应用程序可用内存数：free -m</p><ul><li>应用程序可用内存/系统物理内存 &gt; 70% 内存充足</li><li>应用程序可用内存/系统物理内存 &lt; 20% 内存不足，需要增加内存</li><li>20% &lt; 应用程序可用内存/系统物理内存 &lt; 70%，表示内存基本够用</li></ul><hr><p>free -h：以人类能看懂的方式查看物理内存</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104154.png"></p><hr><p>free -m：以MB为单位，查看物理内存</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104155.png"></p><hr><p>free -g：以GB为单位，查看物理内存</p><hr><h3 id="硬盘：df"><a href="#硬盘：df" class="headerlink" title="硬盘：df"></a>硬盘：df</h3><blockquote><p>格式：<code>df -h /</code> (-h：human，表示以人类能看到的方式换算)</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104156.png"></p><hr><h3 id="硬盘IO：iostat"><a href="#硬盘IO：iostat" class="headerlink" title="硬盘IO：iostat"></a>硬盘IO：iostat</h3><blockquote><p>系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作</p></blockquote><p>格式：<code>iostat -xdk 2 3</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104157.png" alt="image-20200326170522559"></p><p>磁盘块设备分布：</p><ul><li>rkB /s：每秒读取数据量kB；</li><li>wkB/s：每秒写入数据量kB；</li><li>svctm I/O：请求的平均服务时间，单位毫秒</li><li>await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好</li><li>util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘；</li><li>rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</li><li>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘</li></ul><hr><h3 id="网络IO：ifstat"><a href="#网络IO：ifstat" class="headerlink" title="网络IO：ifstat"></a>网络IO：ifstat</h3><blockquote><p>默认本地没有，下载ifstat</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104158.png"></p><hr><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><blockquote><p>问题10：假如生产环境CPU占用过高，谈谈分析思路和定位？</p></blockquote><p>分析步骤：</p><ol><li><p>先用top命令找出CPU占比最高的进程</p></li><li><p>ps -ef或者jps查看进程编号</p></li><li><p>定位到具体的线程或者代码</p><blockquote><p>ps -mp 进程 -o THREAD，tid，time</p><p>参数：</p><ul><li>-m：显示所有的线程</li><li>-p：pid进程使用CPU的时间</li><li>-o：该参数后是用户自定义格式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104159.png"></p></blockquote></li><li><p>将线程的id转换为16进制</p><blockquote><p>printf “%x\n” 有问题的线程ID</p></blockquote></li><li><p>jstack 线程id | grep tid （16进制） 得到java程序详细信息，定位到第几行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104200.png"></p><hr></li></ol><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><blockquote><p>问题11：对于JDK自带的JVM监控和性能分析工具用过哪些？一般怎么用的？</p></blockquote><ul><li>jps 进程状态工具</li><li>jinfo java配置信息工具</li><li>jmap 内存映像工具</li><li>jstat 统计信息监视工具</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux诊断原因&quot;&gt;&lt;a href=&quot;#Linux诊断原因&quot; class=&quot;headerlink&quot; title=&quot;Linux诊断原因&quot;&gt;&lt;/a&gt;Linux诊断原因&lt;/h1&gt;&lt;h2 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="面试汇总" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    <category term="大厂面试第二季_周阳老师" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/"/>
    
    <category term="Linux" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3-%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Linux/"/>
    
    
    <category term="Linux" scheme="http://jiangbk.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>10_Docker 私有仓库</title>
    <link href="http://jiangbk.top/2021/02/17/Docker/10-Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://jiangbk.top/2021/02/17/Docker/10-Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2021-02-17T02:22:19.000Z</published>
    <updated>2021-02-17T02:29:13.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10-Docker-私有仓库"><a href="#10-Docker-私有仓库" class="headerlink" title="10_Docker 私有仓库"></a>10_Docker 私有仓库</h1><p>Docker官方的Docker hub（<a href="https://hub.docker.com)是一个用于管理公共镜像的仓库,我们可以从上面拉/">https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉</a> 取镜像 到本地，也可以把我们自己的镜像推送上去。但是，有时候我们不希望将自己的镜 像放到公网当中， 那么这时我们就需要搭建自己的私有仓库来存储和管理自己的镜像 </p><h2 id="私有仓库搭建"><a href="#私有仓库搭建" class="headerlink" title="私有仓库搭建"></a>私有仓库搭建</h2><p><strong>步骤：</strong></p><h3 id="1、拉取私有仓库镜像"><a href="#1、拉取私有仓库镜像" class="headerlink" title="1、拉取私有仓库镜像"></a>1、拉取私有仓库镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><h3 id="2、启动私有仓库容器"><a href="#2、启动私有仓库容器" class="headerlink" title="2、启动私有仓库容器"></a>2、启动私有仓库容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure><h3 id="3、访问仓库"><a href="#3、访问仓库" class="headerlink" title="3、访问仓库"></a>3、访问仓库</h3><p>打开浏览器 输入地址：http://私有仓库服务器ip:5000/v2/_catalog，看到{“repositories”:[]} 表示私有仓 库 搭建成功 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102238.png"></p><h3 id="4、修改-daemon-json"><a href="#4、修改-daemon-json" class="headerlink" title="4、修改 daemon.json"></a>4、修改 daemon.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p># 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器 ip 修改为自 己私有仓库服务器真实 ip </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125;</span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.220.12:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102239.png"></p><p><strong>我的文件源码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;y1ye9vg6.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;:[&quot;192.168.77.138:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、重启docker-服务"><a href="#5、重启docker-服务" class="headerlink" title="5、重启docker 服务"></a>5、重启docker 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker </span><br></pre></td></tr></table></figure><h3 id="6、重启-私有仓库容器"><a href="#6、重启-私有仓库容器" class="headerlink" title="6、重启 私有仓库容器"></a>6、重启 私有仓库容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure><hr><h2 id="将镜像上传至私有仓库"><a href="#将镜像上传至私有仓库" class="headerlink" title="将镜像上传至私有仓库"></a>将镜像上传至私有仓库</h2><p>下面以 上传 nginx 镜像为例，</p><h3 id="1、标记镜像为私有仓库的镜像"><a href="#1、标记镜像为私有仓库的镜像" class="headerlink" title="1、标记镜像为私有仓库的镜像"></a>1、标记镜像为私有仓库的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><h3 id="2、上传标记的镜像"><a href="#2、上传标记的镜像" class="headerlink" title="2、上传标记的镜像"></a>2、上传标记的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><h3 id="3、查看私有仓库"><a href="#3、查看私有仓库" class="headerlink" title="3、查看私有仓库"></a>3、查看私有仓库</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102240.png"></p><hr><h2 id="从私有仓库拉取镜像"><a href="#从私有仓库拉取镜像" class="headerlink" title="从私有仓库拉取镜像"></a>从私有仓库拉取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;10-Docker-私有仓库&quot;&gt;&lt;a href=&quot;#10-Docker-私有仓库&quot; class=&quot;headerlink&quot; title=&quot;10_Docker 私有仓库&quot;&gt;&lt;/a&gt;10_Docker 私有仓库&lt;/h1&gt;&lt;p&gt;Docker官方的Docker hub（&lt;a</summary>
      
    
    
    
    <category term="Docker" scheme="http://jiangbk.top/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://jiangbk.top/tags/Docker/"/>
    
  </entry>
  
</feed>
