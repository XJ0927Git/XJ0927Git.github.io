<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Teach_Jiang</title>
  
  
  <link href="http://jiangbk.top/atom.xml" rel="self"/>
  
  <link href="http://jiangbk.top/"/>
  <updated>2021-02-19T04:25:27.411Z</updated>
  <id>http://jiangbk.top/</id>
  
  <author>
    <name>guojiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>9_RabbitMQ高级特性</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/9-RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/9-RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</id>
    <published>2021-02-19T04:19:51.000Z</published>
    <updated>2021-02-19T04:25:27.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-RabbitMQ高级特性"><a href="#9-RabbitMQ高级特性" class="headerlink" title="9_RabbitMQ高级特性"></a>9_RabbitMQ高级特性</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>生产端向rabbitmq发送消息时，由于网络等原因可能导致消息发送失败。所以，rabbitmq必须有机制确保消息能准确到达mq，如果不能到达，必须反馈给生产端进行重发。</p><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>RabbitMQ消息的可靠性投递主要两种实现：<br>1、通过实现消费的重试机制，通过@Retryable来实现重试，可以设置重试次数和重试频率；<br>2、生产端实现消息可靠性投递。</p><p>两种方法消费端都可能收到重复消息，要求消费端必须实现幂等性消费。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121939.png"></p><hr><h2 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h2><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式</p><ul><li>confirm 确认模式 </li><li>return 退回模式</li></ul><hr><h4 id="消息投递到exchange的确认模式"><a href="#消息投递到exchange的确认模式" class="headerlink" title="消息投递到exchange的确认模式"></a>消息投递到exchange的确认模式</h4><p>rabbitmq的消息投递的过程为：</p><p>producer ——&gt; rabbitmq broker cluster ——&gt; exchange ——&gt; queue ——&gt; consumer</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121940.png"></p><ul><li>生产端发送消息到rabbitmq broker cluster后，异步接受从rabbitmq返回的ack确认信息</li><li>生产端收到返回的ack确认消息后，根据ack是true还是false，调用confirmCallback接口进行处理</li></ul><h5 id="1、改yml"><a href="#1、改yml" class="headerlink" title="1、改yml"></a>1、改yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># rabbitmq 连接配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启confirm确认模式</span></span><br></pre></td></tr></table></figure><h5 id="2、实现confirm方法"><a href="#2、实现confirm方法" class="headerlink" title="2、实现confirm方法"></a>2、实现confirm方法</h5><p>实现ConfirmCallback接口中的confirm方法，消息只要被 rabbitmq broker接收到就会触ConfirmCallback 回调，ack为true表示消息发送成功，ack为false表示消息发送失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 实现ConfirmCallback接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-13 12:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmCallbackService</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 相关配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack exchange交换机 是否成功收到了消息。true 成功，false代表失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            <span class="comment">//接收成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成功发送到交换机&lt;===&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//接收失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;失败原因:===&gt;&quot;</span> + cause);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//TODO 做一些处理:消息再次发送等等</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h5><h6 id="定义-Exchange-和-Queue"><a href="#定义-Exchange-和-Queue" class="headerlink" title="定义 Exchange 和 Queue"></a>定义 Exchange 和 Queue</h6><p>定义交换机 <code>confirmTestExchange</code> 和队列 <code>confirm_test_queue</code> ，并将队列绑定在交换机上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  队列与交换机绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-13 12:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;confirmTestQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmTestQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;confirm_test_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;confirmTestExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">confirmTestExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;confirmTestExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">confirmTestFanoutExchangeAndQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Qualifier(&quot;confirmTestExchange&quot;)</span> FanoutExchange confirmTestExchange,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Qualifier(&quot;confirmTestQueue&quot;)</span> Queue confirmTestQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmTestQueue).to(confirmTestExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = RabbitmqApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfirmCallbackService confirmCallbackService; <span class="comment">//注入ConfirmCallback对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallbackService);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;confirmTestExchange1&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;hello,ConfirmCallback你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确情况，ack返回true，表示投递成功。</p><p>现在我们改变交换机名字，发送到一个不存在的交换机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送消息</span><br><span class="line"> rabbitTemplate.convertAndSend(&quot;confirmTestExchange1&quot;, &quot;&quot;, &quot;hello,ConfirmCallback你好&quot;);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121941.png"></p><hr><h4 id="消息未投递到queue的退回模式"><a href="#消息未投递到queue的退回模式" class="headerlink" title="消息未投递到queue的退回模式"></a>消息未投递到queue的退回模式</h4><p>消息从 exchange–&gt;queue 投递失败则会返回一个 returnCallback</p><p>生产端通过实现ReturnCallback接口，启动消息失败返回，消息路由不到队列时会触发该回调接口</p><h5 id="1、改yml-1"><a href="#1、改yml-1" class="headerlink" title="1、改yml"></a>1、改yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># rabbitmq 连接配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启退回模式</span></span><br></pre></td></tr></table></figure><h5 id="2、设置投递失败的模式"><a href="#2、设置投递失败的模式" class="headerlink" title="2、设置投递失败的模式"></a>2、设置投递失败的模式</h5><p> 如果消息没有路由到Queue，则丢弃消息（默认） </p><p>如果消息没有路由到Queue，返回给消息发送方ReturnCallBack（开启后）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setMandatory(true);</span><br></pre></td></tr></table></figure><h5 id="2、实现returnedMessage方法"><a href="#2、实现returnedMessage方法" class="headerlink" title="2、实现returnedMessage方法"></a>2、实现returnedMessage方法</h5><p>启动消息失败返回，消息路由不到队列时会触发该回调接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-13 12:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnCallbackService</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyCode  错误码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyText  错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange   交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息对象===&gt;:&quot;</span> + message);</span><br><span class="line">        System.out.println(<span class="string">&quot;错误码===&gt;:&quot;</span> + replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;错误信息===&gt;:&quot;</span> + replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的交换器===&gt;:&quot;</span> + exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的路由key===&gt;:&quot;</span> + routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO ===&gt;做业务处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3、测试-1"><a href="#3、测试-1" class="headerlink" title="3、测试"></a>3、测试</h5><h6 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = RabbitmqApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfirmCallbackService confirmCallbackService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ReturnCallbackService returnCallbackService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确保消息发送失败后可以重新返回到队列中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息投递到队列失败回调处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(returnCallbackService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息投递确认模式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallbackService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;confirmTestExchange&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;hello,ConfirmCallback你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不存在路由key”dire”，会调用ReturnCallback接口</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121942.png"></p><hr><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><h4 id="消息确认机制ack"><a href="#消息确认机制ack" class="headerlink" title="消息确认机制ack"></a>消息确认机制ack</h4><p>ack指Acknowledge确认。 表示消费端收到消息后的确认方式</p><p>消费端消息的确认分为：自动确认（默认）、手动确认、不确认</p><ul><li>AcknowledgeMode.NONE：不确认</li><li>AcknowledgeMode.AUTO：自动确认</li><li>AcknowledgeMode.MANUAL：手动确认</li></ul><p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息 缓存中移除。</p><p>但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了 手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用 channel.basicNack()方法，让其自动重新发送消息。</p><hr><h6 id="1、改yml-2"><a href="#1、改yml-2" class="headerlink" title="1、改yml"></a>1、改yml</h6><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment"># 手动确认</span></span><br></pre></td></tr></table></figure><h6 id="2、确认配置"><a href="#2、确认配置" class="headerlink" title="2、确认配置"></a>2、确认配置</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;confirm_test_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processHandler</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息内容===&gt;&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//TODO 具体业务逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//手动签收[参数1:消息投递序号,参数2:批量签收]</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//拒绝签收[参数1:消息投递序号,参数2:批量拒绝,参数3:是否重新加入队列]</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel.basicNack 方法与 channel.basicReject 方法区别在于basicNack可以批量拒绝多条消息，而basicReject一次只能拒绝一条消息。</p><h6 id="3、测试-2"><a href="#3、测试-2" class="headerlink" title="3、测试"></a>3、测试</h6><p>正常情况</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121943.png"></p><p>异常情况</p><p>在业务处理模块增加异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;TODO 具体业务逻辑</span><br><span class="line">System.out.println(&quot;开始处理业务逻辑代码:&#x3D;&#x3D;&gt;&quot;);</span><br><span class="line">int i &#x3D; 3&#x2F;0;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121944.png"></p><p>发生异常，拒绝确认，重新加入队列，一直循环，知道确认消息。</p><hr><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>假设一个场景，首先，我们 Rabbitmq 服务器积压了有上万条未处理的消息，我们随便打开一个消费者客户端，会出现这样情况: 巨量的消息瞬间全部推送过来，但是我们单个客户端无法同时处理这么多数据!</p><p>当数据量特别大的时候，我们对生产端限流肯定是不科学的，因为有时候并发量就是特别大，有时候并发量又特别少，我们无法约束生产端，这是用户的行为。所以我们应该对消费端限流，用于保持消费端的稳定，当消息数量激增的时候很有可能造成资源耗尽，以及影响服务的性能，导致系统的卡顿甚至直接崩溃。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121945.png"></p><hr><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>Time To Live，消息过期时间设置</p><p>声明队列时，指定即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121946.png"></p><p>TTL:过期时间 </p><ol><li>队列统一过期 </li><li>消息单独过期</li></ol><p>如果设置了消息的过期时间，也设置了队列的过期时间，它以时间短的为准。 </p><p>​    * 队列过期后，会将队列所有消息全部移除</p><p>​    * 消息过期后，只有消息在队列顶端，才会判断其是否过期(移除掉)</p><hr><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以 </p><p>被重新发送到另一个交换机，这个交换机就是DLX</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121947.png"></p><p><strong>消息成为死信的三种情况：</strong> </p><ol><li><p>队列消息长度到达限制； </p></li><li><p>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false； </p></li><li><p>原队列存在消息过期设置，消息到达超时时间未被消费；</p></li></ol><p><strong>队列绑定死信交换机：</strong> </p><p>给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key</p><p>也就是说此时Queue作为”生产者”</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121948.png"></p><hr><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费</p><p><strong>需求：</strong></p><ol><li><p>下单后，30分钟未支付，取消订单，回滚库存。 </p></li><li><p>新用户注册成功7天后，发送短信问候。 </p></li></ol><p><strong>实现方式：</strong> </p><ol><li><p>定时器 （×）</p></li><li><p>延迟队列 （√）</p></li></ol><hr><p><strong>实现步骤：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121949.png"></p><p>在RabbitMQ中并未提供延迟队列功能</p><p><strong>替代实现：</strong> TTL+死信队列 组合实现延迟队列的效果</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121950.png"></p><p>设置队列过期时间30分钟，当30分钟过后，消息未被消费，进入死信队列，路由到指定队列，调用库存系统，判断订单状态。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9-RabbitMQ高级特性&quot;&gt;&lt;a href=&quot;#9-RabbitMQ高级特性&quot; class=&quot;headerlink&quot; title=&quot;9_RabbitMQ高级特性&quot;&gt;&lt;/a&gt;9_RabbitMQ高级特性&lt;/h1&gt;&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>8_RabbitMQ 集群</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/8-RabbitMQ-%E9%9B%86%E7%BE%A4/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/8-RabbitMQ-%E9%9B%86%E7%BE%A4/</id>
    <published>2021-02-19T04:19:07.000Z</published>
    <updated>2021-02-19T04:25:22.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-RabbitMQ-集群"><a href="#8-RabbitMQ-集群" class="headerlink" title="8_RabbitMQ 集群"></a>8_RabbitMQ 集群</h1><h2 id="普通集群-副本集群"><a href="#普通集群-副本集群" class="headerlink" title="普通集群(副本集群)"></a>普通集群(副本集群)</h2><p>默认情况下: RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121824.png"></p><p><strong>核心解决问题:</strong>  <font color='orange'>当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份</font></p><hr><h4 id="1、克隆三台主机"><a href="#1、克隆三台主机" class="headerlink" title="1、克隆三台主机"></a>1、克隆三台主机</h4><p>这里为了方便，我已经在克隆的主机上安装过rabbitmq，所以克隆的三台主机都已安装好rabbitmq</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 0.集群规划</span></span><br><span class="line">node1: 192.168.77.139 mq1  master 主节点</span><br><span class="line">node2: 192.168.77.140 mq2  repl1  副本节点</span><br><span class="line">node3: 192.168.77.131 mq3  repl2  副本节点</span><br></pre></td></tr></table></figure><h4 id="2、修改ip地址"><a href="#2、修改ip地址" class="headerlink" title="2、修改ip地址"></a>2、修改ip地址</h4><p>3台均是如此操作，分别修改为对应的ip</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看网络配置文件</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="section"># 修改配置文件</span></span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line"><span class="section"># 修改ip如下：</span></span><br><span class="line">IPADDR=192.168.77.139</span><br><span class="line"></span><br><span class="line"><span class="section"># 重启网络</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><hr><h4 id="3、修改主机名和ip映射"><a href="#3、修改主机名和ip映射" class="headerlink" title="3、修改主机名和ip映射"></a>3、修改主机名和ip映射</h4><h5 id="修改ip映射"><a href="#修改ip映射" class="headerlink" title="修改ip映射"></a>修改ip映射</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.77.139 mq1 </span><br><span class="line">192.168.77.140 mq2 </span><br><span class="line">192.168.77.131 mq3</span><br></pre></td></tr></table></figure><p>三台都要如此操作</p><hr><h5 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># node1:</span></span><br><span class="line">vim /etc/hostname</span><br><span class="line">加入:  mq1</span><br><span class="line"><span class="section"># node2: </span></span><br><span class="line">vim /etc/hostname </span><br><span class="line">加入:  mq2</span><br><span class="line"><span class="section"># node3: </span></span><br><span class="line">vim /etc/hostname </span><br><span class="line">加入:  mq3</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 重启机器生效</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><hr><h4 id="4、同步cookie文件"><a href="#4、同步cookie文件" class="headerlink" title="4、同步cookie文件"></a>4、同步cookie文件</h4><p>因为rabbitmq是基于erlang语言开发的，集群开发要求cookie必须一致</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看cookie是否一致:</span></span><br><span class="line">node1: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line">node2: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line">node3: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line"></span><br><span class="line"><span class="section"># 如果不一致,在node1上执行:[同步cookie]</span></span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/</span><br></pre></td></tr></table></figure><hr><h4 id="5、测试各节点rabbitmq是否搭建成功"><a href="#5、测试各节点rabbitmq是否搭建成功" class="headerlink" title="5、测试各节点rabbitmq是否搭建成功"></a>5、测试各节点rabbitmq是否搭建成功</h4><h6 id="启动rabbitmq"><a href="#启动rabbitmq" class="headerlink" title="启动rabbitmq"></a>启动rabbitmq</h6><p>三台机器分别执行如下命令：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 启动插件管理</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq<span class="emphasis">_management</span></span><br><span class="line"><span class="emphasis"># 启动rabbitmq</span></span><br><span class="line"><span class="emphasis">systemctl start rabbitmq-server</span></span><br></pre></td></tr></table></figure><p>注意：关闭防火墙</p><hr><h6 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 分别访问</span></span><br><span class="line">http://192.168.77.139:15672/</span><br><span class="line">http://192.168.77.140:15672/</span><br><span class="line">http://192.168.77.141:15672/</span><br></pre></td></tr></table></figure><p>至此，rabbitmq各个节点环境搭建成功</p><hr><h4 id="6、后台启动rabbitmq所有节点"><a href="#6、后台启动rabbitmq所有节点" class="headerlink" title="6、后台启动rabbitmq所有节点"></a>6、后台启动rabbitmq所有节点</h4><p>如果你有使用管理插件方式启动rabbitmq，一定要先关掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure><p>再以后台方式启动<strong>rabbitmq</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached </span><br></pre></td></tr></table></figure><p>注意：这种方式启动没有使用插件管理，所以还不能访问web界面</p><hr><h4 id="7、备节点加入集群"><a href="#7、备节点加入集群" class="headerlink" title="7、备节点加入集群"></a>7、备节点加入集群</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在node2和node3执行加入集群命令:</span></span><br><span class="line"></span><br><span class="line"><span class="code">1.关闭       rabbitmqctl stop_app</span></span><br><span class="line"><span class="code">2.加入集群    rabbitmqctl join_cluster rabbit@mq1</span></span><br><span class="line"><span class="code">3.启动服务    rabbitmqctl start_app</span></span><br></pre></td></tr></table></figure><p>往哪个节点加，那个被加入的节点就是主节点</p><hr><h4 id="8、查看集群状态"><a href="#8、查看集群状态" class="headerlink" title="8、查看集群状态,"></a>8、查看集群状态,</h4><p>任意节点执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 如果出现如下显示,集群搭建成功:</span></span><br><span class="line">Cluster status of node rabbit@mq3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;]&#125;,</span><br><span class="line">&#123;running<span class="emphasis">_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;,</span></span><br><span class="line"><span class="emphasis">&#123;cluster_</span>name,&lt;&lt;&quot;rabbit@mq1&quot;&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions,[]&#125;,</span><br><span class="line">&#123;alarms,[&#123;rabbit@mq1,[]&#125;,&#123;rabbit@mq2,[]&#125;,&#123;rabbit@mq3,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure><hr><h4 id="9、登录管理界面"><a href="#9、登录管理界面" class="headerlink" title="9、登录管理界面"></a>9、登录管理界面</h4><p>访问任意一台主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.139:15672</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121825.png"></p><hr><h4 id="10、测试"><a href="#10、测试" class="headerlink" title="10、测试"></a>10、测试</h4><p>在node1上,创建队列，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121826.png"></p><p>查看node2和node3节点，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121827.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121828.png"></p><p>可以发现：主节点上创建队列，备节点node2和node3也可以看到相应队列</p><hr><p>给主节点node1发送消息，查看node2和node3，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121829.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121830.png"></p><p>从node2或者node3上消费消息，</p><p>可以发现：可以消费消息，它最终也是从主节点node1上获取消息，它本身不提供消息</p><hr><p>关闭node1节点,执行如下命令,查看node2和node3，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121831.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121832.png"></p><p>可以发现：主节点宕掉后，备节点可以看见队列，但不能提供服务，也即不能代替主节点做故障转移！</p><hr><h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a><font color='orange'>镜像集群</font></h2><p>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。</p><p>注意：实际生产中使用还要配合LVS和负载均衡使用</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121833.png"></p><hr><p><strong>注意：</strong> 镜像集群是在普通集群的基础上添加策略形成的，所以以下操作是在前面搭建好的普通集群上进行的</p><hr><p><strong>策略说明：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 命令格式</span></span><br><span class="line">rabbitmqctl set<span class="emphasis">_policy [-p <span class="xml"><span class="tag">&lt;<span class="name">vhost</span>&gt;</span></span>] [--priority <span class="xml"><span class="tag">&lt;<span class="name">priority</span>&gt;</span></span>] [--apply-to <span class="xml"><span class="tag">&lt;<span class="name">apply-to</span>&gt;</span></span>] <span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span>  <span class="xml"><span class="tag">&lt;<span class="name">definition</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 参数说明</span></span><br><span class="line"><span class="emphasis">-p Vhost： 可选参数，针对指定vhost下的queue进行设置</span></span><br><span class="line"><span class="emphasis">Name:     policy的名称</span></span><br><span class="line"><span class="emphasis">Pattern: queue的匹配模式(正则表达式)</span></span><br><span class="line"><span class="emphasis">Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span></span><br><span class="line"><span class="emphasis">            ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span></span><br><span class="line"><span class="emphasis">                        all：表示在集群中所有的节点上进行镜像</span></span><br><span class="line"><span class="emphasis">                        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span></span><br><span class="line"><span class="emphasis">                        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span></span><br><span class="line"><span class="emphasis">             ha-params：ha-mode模式需要用到的参数</span></span><br><span class="line"><span class="emphasis">                ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</span></span><br><span class="line"><span class="emphasis">                priority：可选参数，policy的优先级</span></span><br></pre></td></tr></table></figure><hr><h4 id="1、查看当前策略"><a href="#1、查看当前策略" class="headerlink" title="1、查看当前策略"></a>1、查看当前策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_policies</span><br></pre></td></tr></table></figure><h4 id="2、添加策略"><a href="#2、添加策略" class="headerlink" title="2、添加策略"></a>2、添加策略</h4><p>说明: 策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列</p><p>这里我的队列hello与/ems虚拟主机进行了一个绑定，所以我在设置策略时，就针对该虚拟主机下的队列进行设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all -p  &#39;&#x2F;ems&#39;  &#39;^hello&#39; &#39;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#39; </span><br></pre></td></tr></table></figure><hr><h4 id="3、查看界面"><a href="#3、查看界面" class="headerlink" title="3、查看界面"></a>3、查看界面</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121834.png"></p><hr><h4 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h4><p>向主节点发送消息，其他节点也可以进行同步。</p><p>现关闭主节点，查看另外两个节点node2和node3，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121835.png">可以发现：备节点node2代替成为主节点。</p><p>消费节点node2或者node3的消息，可以正常消费消息</p><hr><p>再次启动节点node1，发现主节点还是node2节点，node1成为备用节点</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121836.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;8-RabbitMQ-集群&quot;&gt;&lt;a href=&quot;#8-RabbitMQ-集群&quot; class=&quot;headerlink&quot; title=&quot;8_RabbitMQ 集群&quot;&gt;&lt;/a&gt;8_RabbitMQ 集群&lt;/h1&gt;&lt;h2 id=&quot;普通集群-副本集群&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>7_MQ的应用场景</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/7-MQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/7-MQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2021-02-19T04:17:50.000Z</published>
    <updated>2021-02-19T04:25:18.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-MQ的应用场景"><a href="#7-MQ的应用场景" class="headerlink" title="7_MQ的应用场景"></a>7_MQ的应用场景</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p><strong>场景说明：</strong> 用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式</p><p><font color='orange'>串行方式：</font>将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121737.png"></p><p><font color='orange'>并行方式：</font> 将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121738.png"></p><hr><p><font color='orange'>消息队列：</font>[可以使用广播模式]</p><p>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回. </p><p> 消息队列: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121739.png"></p><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍</p><hr><h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><p><strong>场景：</strong> 双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121740.png"></p><p>这种做法有一个缺点:</p><p>当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  </p><p><font color='orange'>引入消息队列： </font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121741.jpg"></p><ul><li><p><strong>订单系统:</strong> 用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</p></li><li><p><strong>库存系统:</strong> 订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.</p></li></ul><hr><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p><strong>场景:</strong>  秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  </p><p> <strong>作用:</strong></p><p>​            1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) </p><p>​            2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121742.png"></p><p><strong>流程：</strong></p><p>用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  </p><p>秒杀业务根据消息队列中的请求信息，再做后续处理.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-MQ的应用场景&quot;&gt;&lt;a href=&quot;#7-MQ的应用场景&quot; class=&quot;headerlink&quot; title=&quot;7_MQ的应用场景&quot;&gt;&lt;/a&gt;7_MQ的应用场景&lt;/h1&gt;&lt;h2 id=&quot;异步处理&quot;&gt;&lt;a href=&quot;#异步处理&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>6_SpringBoot 实现RabbitMQ</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/6-SpringBoot-%E5%AE%9E%E7%8E%B0RabbitMQ/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/6-SpringBoot-%E5%AE%9E%E7%8E%B0RabbitMQ/</id>
    <published>2021-02-19T04:16:33.000Z</published>
    <updated>2021-02-19T04:25:06.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-SpringBoot-实现RabbitMQ"><a href="#6-SpringBoot-实现RabbitMQ" class="headerlink" title="6_SpringBoot 实现RabbitMQ"></a>6_SpringBoot 实现RabbitMQ</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="1、建项目"><a href="#1、建项目" class="headerlink" title="1、建项目"></a>1、建项目</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121620.png"></p><h3 id="2、改pom"><a href="#2、改pom" class="headerlink" title="2、改pom"></a>2、改pom</h3><p>如果你没有使用springboot快速构建的方式启动项目，而是使用maven的方式进行构建，需要引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、建yml"><a href="#3、建yml" class="headerlink" title="3、建yml"></a>3、建yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 应用名称[非必须]</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springboot_rabbitmq</span></span><br><span class="line">  <span class="comment"># rabbitmq 连接配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.77</span><span class="number">.138</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># tcp端口</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ems</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 用户密码</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/ems</span> <span class="comment"># 虚拟主机</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>springboot提供的操作rabbitmq的对象为：<font color='orange'>RabbitTemplate</font></p><p>使用时候直接在项目中注入即可使用</p><hr><h2 id="第一种hello-world模型"><a href="#第一种hello-world模型" class="headerlink" title="第一种hello world模型"></a>第一种hello world模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121621.png"></p><p>直接发送给队列，不使用交换机</p><h4 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//helloworld 直连模式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发送消息[注意此时并不会立即创建队列，因为没有消费者存在]</span></span><br><span class="line">    <span class="comment">//参数1:队列名字</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello 模型&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//注入容器</span></span><br><span class="line"><span class="comment">//监听rabbitmq,参数1:队列名称,参数2:是否持久化,参数3:是否独占,参数4:是否自动删除</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;hello&quot;, durable = &quot;true&quot;, exclusive = &quot;false&quot;, autoDelete = &quot;false&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span> <span class="comment">//加上此注解后，会自动回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二种work模型"><a href="#第二种work模型" class="headerlink" title="第二种work模型"></a>第二种work模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121622.png"></p><h4 id="1-开发生产者-1"><a href="#1-开发生产者-1" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//work 任务模型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;work&quot;</span>, <span class="string">&quot;work 模型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者-1"><a href="#2-开发消费者-1" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//注入容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者1号</span></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span> <span class="comment">//@RabbitListener 也可以直接写在方法上进行回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者2号</span></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span>  <span class="comment">//@RabbitListener 也可以直接写在方法上进行回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置</p><hr><h2 id="第三种Fanout-广播模型"><a href="#第三种Fanout-广播模型" class="headerlink" title="第三种Fanout 广播模型"></a>第三种Fanout 广播模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121623.png"></p><p>只要临时队列绑定到了交换机，一发送消息，所有消费者都可以接收</p><h4 id="1-开发生产者-2"><a href="#1-开发生产者-2" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fanout 广播模型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不指定队列</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;logs&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;fanout模型&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者-2"><a href="#2-开发消费者-2" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">![<span class="number">5</span>](images/<span class="number">5.</span>png)<span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定临时队列与交换机</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;logs&quot;, type = &quot;fanout&quot;)//交换机名字与类型</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定临时队列与交换机</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;logs&quot;, type = &quot;fanout&quot;)//交换机名字与类型</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第四种Route-路由模型"><a href="#第四种Route-路由模型" class="headerlink" title="第四种Route 路由模型"></a>第四种Route 路由模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121624.png"></p><p>指定路由key，只有拥有相匹配路由的队列才能接收到消息</p><h4 id="1-开发生产者-3"><a href="#1-开发生产者-3" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//route 路由模型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需指定路由key</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;directs&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;direct模型&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者-3"><a href="#2-开发消费者-3" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;directs&quot;, type = &quot;direct&quot;),//交换机名字和类型</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;info&quot;, &quot;error&quot;&#125;//路由key</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;directs&quot;, type = &quot;direct&quot;),//交换机名字和类型</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;error&quot;&#125;//路由key</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="第五种Topic-订阅模型-动态路由模型"><a href="#第五种Topic-订阅模型-动态路由模型" class="headerlink" title="第五种Topic 订阅模型(动态路由模型)"></a>第五种Topic 订阅模型(动态路由模型)</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121625.png"></p><p>与route类型，只是需要指定动态的路由key</p><h4 id="1-开发生产者-4"><a href="#1-开发生产者-4" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//topic 订阅模型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需指定路由key</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;topics&quot;</span>, <span class="string">&quot;order.add&quot;</span>, <span class="string">&quot;指定的路由key为:user.add[topic模型]&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者-4"><a href="#2-开发消费者-4" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;topics&quot;,type = &quot;topic&quot;),//交换机名称和类型</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;user.*&quot;&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;topics&quot;,type = &quot;topic&quot;),//交换机名称和类型</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;user.*&quot;,&quot;produce.#&quot;,&quot;order.*&quot;&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-SpringBoot-实现RabbitMQ&quot;&gt;&lt;a href=&quot;#6-SpringBoot-实现RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;6_SpringBoot 实现RabbitMQ&quot;&gt;&lt;/a&gt;6_SpringBoot 实现Ra</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>5_RabbitMQ连接工具类封装</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/5-RabbitMQ%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/5-RabbitMQ%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85/</id>
    <published>2021-02-19T04:15:30.000Z</published>
    <updated>2021-02-19T04:24:53.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-RabbitMQ连接工具类封装"><a href="#5-RabbitMQ连接工具类封装" class="headerlink" title="5_RabbitMQ连接工具类封装"></a>5_RabbitMQ连接工具类封装</h1><h3 id="定义工具类"><a href="#定义工具类" class="headerlink" title="定义工具类"></a>定义工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> Created in 2021-01-08 15:54</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块：类加载时执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.77.138&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭通道连接和连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">(Channel channel, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="使用工具类"><a href="#使用工具类" class="headerlink" title="使用工具类"></a>使用工具类</h3><h4 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象===&gt;使用工具类</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接中通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定对应消息队列</span></span><br><span class="line">        <span class="comment">//参数1:  队列名称 如果队列不存在自动创建</span></span><br><span class="line">        <span class="comment">//参数2:  用来定义队列特性是否要持久化 true 持久化队列   false 不持久化</span></span><br><span class="line">        <span class="comment">//参数3:  exclusive 是否独占队列  true 独占队列   false  不独占</span></span><br><span class="line">        <span class="comment">//参数4:  autoDelete: 是否在消费完成后自动删除队列  true 自动删除  false 不自动删除</span></span><br><span class="line">        <span class="comment">//参数5:  额外附加参数</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        <span class="comment">//参数1: 交换机名称 参数2:队列名称  参数3:传递息额外设置  参数4:消息的具体内容</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接===&gt;使用工具类</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2. 开发消费者"></a>2. 开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象===&gt;使用工具类</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定队列：与生产端一致</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取消息</span></span><br><span class="line">        <span class="comment">//参数1: 消费那个队列的消息 队列名称</span></span><br><span class="line">        <span class="comment">//参数2: 开始消息的自动确认机制</span></span><br><span class="line">        <span class="comment">//参数3: 消费时的回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;取出消息:===&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;5-RabbitMQ连接工具类封装&quot;&gt;&lt;a href=&quot;#5-RabbitMQ连接工具类封装&quot; class=&quot;headerlink&quot; title=&quot;5_RabbitMQ连接工具类封装&quot;&gt;&lt;/a&gt;5_RabbitMQ连接工具类封装&lt;/h1&gt;&lt;h3 id=&quot;定义工具类</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>4_Java 实现RabbitMQ</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/4-Java-%E5%AE%9E%E7%8E%B0RabbitMQ/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/4-Java-%E5%AE%9E%E7%8E%B0RabbitMQ/</id>
    <published>2021-02-19T04:14:18.000Z</published>
    <updated>2021-02-19T04:24:36.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-Java-实现RabbitMQ"><a href="#4-Java-实现RabbitMQ" class="headerlink" title="4_Java 实现RabbitMQ"></a>4_Java 实现RabbitMQ</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h4 id="1、新建-java-web-项目"><a href="#1、新建-java-web-项目" class="headerlink" title="1、新建 java web 项目"></a>1、新建 java web 项目</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121421.png"></p><h4 id="2、改pom"><a href="#2、改pom" class="headerlink" title="2、改pom"></a>2、改pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.7.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>同时去掉测试依赖的<code>&lt;scope&gt;test&lt;/scope&gt;</code>，不然一会不能进行单元测试</p><hr><h2 id="第一种模型-直连"><a href="#第一种模型-直连" class="headerlink" title="第一种模型(直连)"></a>第一种模型(直连)</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121422.png"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息</li></ul><hr><p><strong>前提：</strong></p><ul><li>创建好虚拟主机</li><li>创建好用户</li><li>虚拟主机与用户进行绑定</li></ul><h3 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="comment">//创建连接mq的连接工厂对象</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置连接rabbitmq主机</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.77.138&quot;</span>);</span><br><span class="line">        <span class="comment">//设置端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置访问虚拟主机的用户名和密码</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接那个虚拟主机</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取连接中通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定对应消息队列</span></span><br><span class="line">        <span class="comment">//参数1:  队列名称 如果队列不存在自动创建</span></span><br><span class="line">        <span class="comment">//参数2:  用来定义队列特性是否要持久化 true 持久化队列   false 不持久化</span></span><br><span class="line">        <span class="comment">//参数3:  exclusive 是否独占队列  true 独占队列   false  不独占</span></span><br><span class="line">        <span class="comment">//参数4:  autoDelete: 是否在消费完成后自动删除队列  true 自动删除  false 不自动删除</span></span><br><span class="line">        <span class="comment">//参数5:  额外附加参数</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        <span class="comment">//参数1: 交换机名称 参数2:队列名称  参数3:传递息额外设置  参数4:消息的具体内容</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产消息到队列：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121423.png"></p><hr><h3 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2. 开发消费者"></a>2. 开发消费者</h3><p>消费者端不能使用单元测试，需要一直监听</p><p>同时不关闭连接消息通道与连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.77.138&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定队列：与生产端一致</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取消息</span></span><br><span class="line">        <span class="comment">//参数1: 消费那个队列的消息 队列名称</span></span><br><span class="line">        <span class="comment">//参数2: 开始消息的自动确认机制[只要消费就从队列删除消息]</span></span><br><span class="line">        <span class="comment">//参数3: 消费时的回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;取出消息:===&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-API参数的说明"><a href="#3-API参数的说明" class="headerlink" title="3. API参数的说明"></a>3. API参数的说明</h3><p>注意：生产方队列的声明与消费方队列的声明要一致</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(&quot;hello&quot;,true,false,false,null);</span><br><span class="line"></span><br><span class="line"><span class="section"># &#x27;参数1&#x27;: 用来声明通道对应的队列 [ 如果不存在队列,会自动创建]</span></span><br><span class="line"><span class="section"># &#x27;参数2&#x27;: 用来指定是否持久化队列 [D: 指定后 rabbitmq 重启后不会消失 ]</span></span><br><span class="line"><span class="section"># &#x27;参数3&#x27;: 用来指定是否独占队列 [ 只允许当特定的连接]</span></span><br><span class="line"><span class="section"># &#x27;参数4&#x27;: 用来指定是否自动删除队列 [A：消息方消费完成后,队列自动删除]</span></span><br><span class="line"><span class="section"># &#x27;参数5&#x27;: 对队列的额外配置</span></span><br></pre></td></tr></table></figure><hr><h2 id="第二种模型-work-queue"><a href="#第二种模型-work-queue" class="headerlink" title="第二种模型(work queue)"></a>第二种模型(work queue)</h2><p>Work queues，也被称为（Task queues），<strong>任务模型</strong>。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用 work 模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121424.png"></p><p>角色：</p><ul><li>P：生产者：任务的发布者</li><li>C1：消费者-1，领取任务并且完成任务，假设完成速度较慢</li><li>C2：消费者-2：领取任务并完成任务，假设完成速度快</li></ul><hr><h3 id="1-开发生产者-1"><a href="#1-开发生产者-1" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;work&quot;</span>, <span class="keyword">null</span>, (i + <span class="string">&quot;号消息&quot;</span>).getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-开发消费者-1"><a href="#2-开发消费者-1" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//绑定队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理消息比较慢 2秒处理一个消息</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1号:==&gt;消费&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-开发消费者-2"><a href="#3-开发消费者-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//绑定队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2号:==&gt;消费&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4.测试结果"></a>4.测试结果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121425.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121426.png"></p><p><strong>总结:</strong> 默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为<font color='orange'>循环。</font></p><hr><h3 id="5-消息自动确认机制"><a href="#5-消息自动确认机制" class="headerlink" title="5.消息自动确认机制"></a>5.消息自动确认机制</h3><p>如果想要实现消费快的多消费，消费慢的少消费，就需要对rabbitmq的消息确认机制进行配置</p><p>同时避免消息丢失</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121427.png"></p><p>两点：</p><ul><li><p>设置通道一次只能消费一个消息</p></li><li><p>关闭消息的自动确认,开启手动确认消息</p></li></ul><p><strong>消费方：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤一:一次只接受一条未确认的消息</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤二：[参数2:关闭自动确认消费]</span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:==&gt;消费&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        <span class="comment">//消费完成后,手动确认消息 [ 参数1:确认标识,参数2:是否一次确认多条消息]</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：消费方都需要进行手动确认，否则队列中不会确认删除</p><p><strong>生产方：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次只发送一条消息</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><p>消费者1号消费一条消息，2s后确认消息，消费者2号消费一条消息，手动确认，消息从队列删除，继续从队列取得一条进行消费，直到队列不存在消息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121428.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121429.png"></p><hr><h2 id="第三种模型-fanout"><a href="#第三种模型-fanout" class="headerlink" title="第三种模型(fanout)"></a>第三种模型(fanout)</h2><p>中文翻译：fanout 扇出 ，也称为<font color='orange'>广播</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121430.png"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li> 可以有多个消费者</li><li> 每个<strong>消费者有自己的queue</strong>（队列）</li><li> 每个<strong>队列都要绑定到Exchange</strong>（交换机）</li><li> <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li><li> 交换机把消息发送给绑定过的所有队列</li><li> 队列的消费者都能拿到消息。<strong>实现一条消息被多个消费者消费</strong></li></ul><hr><h3 id="1-开发生产者-2"><a href="#1-开发生产者-2" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h3><p>广播 ：一条消息多个消费者同时消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机 [ 参数一:交换机名字,参数2:交换机类型:fanout(广播模式) 固定]</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息[参数1:交换机名字,参数2:路由,参数3:消息持久化,参数4:消息内容]</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;fanout...&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开发消费者-1-1"><a href="#2-开发消费者-1-1" class="headerlink" title="2. 开发消费者-1"></a>2. 开发消费者-1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[绑定]=&gt;临时队列和交换机 [参数1:临时队列,参数2:交换机,参数3:路由]</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;register&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-开发消费者-2-1"><a href="#3-开发消费者-2-1" class="headerlink" title="3. 开发消费者-2"></a>3. 开发消费者-2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列和交换机 [参数1:临时队列,参数2:交换机,参数3:路由]</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;register&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-开发消费者-3"><a href="#4-开发消费者-3" class="headerlink" title="4.开发消费者-3"></a>4.开发消费者-3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列和交换机 [参数1:临时队列,参数2:交换机,参数3:路由]</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;register&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者3号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5. 测试结果"></a>5. 测试结果</h3><p>启动消费者，再启动生产者往交换机发送消息，三个消费者同时接收到消息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121431.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121432.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121433.png"></p><hr><h2 id="第四种模型-Routing"><a href="#第四种模型-Routing" class="headerlink" title="第四种模型(Routing)"></a>第四种模型(Routing)</h2><p>Routing 之订阅模型-Direct(直连)</p><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121434.png"></p><p> 在Direct模型中，流程如下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 <font color='orange'>RoutingKey</font>（路由key）</li><li>消息的发送方在向 Exchange发送消息时，也必须指定消息的 <font color='orange'>RoutingKey</font></li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的 <font color='orange'>RoutingKey</font> 进行判断，只有队列的Routingkey与消息的 Routing key 完全一致，才会接收到消息</li></ul><p><strong>图解：</strong></p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与 routing key 完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要 routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息</li></ul><hr><h3 id="1-开发生产者-3"><a href="#1-开发生产者-3" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机[参数1：交换机名字, 参数2:交换机类型,direct路由模式]=&gt;基于指令的 Routing key 转发</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布的路由名称==&gt;根据路由key的不同发送到不同的绑定队列中</span></span><br><span class="line">        String key = <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息[参数1:交换机名字,参数2:路由名字,参数3:消息内容]</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;logs_direct&quot;</span>, key, <span class="keyword">null</span>, (<span class="string">&quot;发送给指定路由&quot;</span> + key + <span class="string">&quot;的消息&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开发消费者-1-2"><a href="#2-开发消费者-1-2" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机[参数1：交换机名字, 参数2:交换机类型,direct路由模式]</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列与交换机并设置指定路由名称</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;warn&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-开发消费者-2-2"><a href="#3-开发消费者-2-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机[参数1：交换机名字, 参数2:交换机类型,direct路由模式]</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列与交换机并设置指定路由名称</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><h4 id="测试生产者发送Route-key为error的消息时"><a href="#测试生产者发送Route-key为error的消息时" class="headerlink" title="测试生产者发送Route key为error的消息时"></a>测试生产者发送Route key为error的消息时</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121435.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121436.png"></p><hr><h4 id="测试生产者发送Route-key为info的消息时"><a href="#测试生产者发送Route-key为info的消息时" class="headerlink" title="测试生产者发送Route key为info的消息时"></a>测试生产者发送Route key为info的消息时</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121437.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121436.png"></p><hr><h2 id="第五种模型-Topic"><a href="#第五种模型-Topic" class="headerlink" title="第五种模型(Topic)"></a>第五种模型(Topic)</h2><p>Routing 之订阅模型-Topic</p><p>Topic 类型的 Exchange 与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列</p><p>只不过<code>Topic</code>类型 Exchange 可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p>这种模型 Routingkey 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121438.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 统配符</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*(star) can substitute for exactly one word.    匹配不多不少恰好1个词</span></span><br><span class="line"><span class="emphasis">#(hash) can substitute for zero or more words.  匹配一个或多个词</span></span><br><span class="line"><span class="emphasis"> </span></span><br><span class="line"><span class="emphasis"># 如:</span></span><br><span class="line"><span class="emphasis">audit.#    匹配audit.irs.corporate或者 audit.irs 等</span></span><br><span class="line"><span class="emphasis">audit.*</span>   只能匹配 audit.irs</span><br></pre></td></tr></table></figure><hr><h3 id="1-开发生产者-4"><a href="#1-开发生产者-4" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机[交换机名字+交换机类型]</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息==&gt;使用动态路由(通配符方式)</span></span><br><span class="line">        String key = <span class="string">&quot;user.update&quot;</span>; <span class="comment">//指定发布的路由key</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;topics&quot;</span>, key, <span class="keyword">null</span>, (<span class="string">&quot;发送消息给指定的路由key&quot;</span> + key).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开发消费者-1-3"><a href="#2-开发消费者-1-3" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h3><p>Routing Key中使用*通配符方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列与交换机并设置获取交换机中动态路由</span></span><br><span class="line">        String key = <span class="string">&quot;user.*&quot;</span>;<span class="comment">//使用通配符指定路由key</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;topics&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-开发消费者-2-3"><a href="#3-开发消费者-2-3" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h3><p>Routing Key中使用*通配符方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列与交换机</span></span><br><span class="line">        String key = <span class="string">&quot;user.#&quot;</span>;<span class="comment">//使用通配符指定路由key</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;topics&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试结果-1"><a href="#4-测试结果-1" class="headerlink" title="4.测试结果"></a>4.测试结果</h3><h5 id="生产者发送user-update时"><a href="#生产者发送user-update时" class="headerlink" title="生产者发送user.update时"></a>生产者发送user.update时</h5><p>两个消费者都可以消费消息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121439.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121440.png"></p><h5 id="生产者发送user-update-to时"><a href="#生产者发送user-update-to时" class="headerlink" title="生产者发送user.update.to时"></a>生产者发送user.update.to时</h5><p>仅消费者2号可以消费消息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121439.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121441.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-Java-实现RabbitMQ&quot;&gt;&lt;a href=&quot;#4-Java-实现RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;4_Java 实现RabbitMQ&quot;&gt;&lt;/a&gt;4_Java 实现RabbitMQ&lt;/h1&gt;&lt;h2 id=&quot;环境搭建&quot;</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>3_RabbitMQ协议与消息模型</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/3-RabbitMQ%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/3-RabbitMQ%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-02-19T04:13:16.000Z</published>
    <updated>2021-02-19T04:24:23.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-RabbitMQ协议与消息模型"><a href="#3-RabbitMQ协议与消息模型" class="headerlink" title="3_RabbitMQ协议与消息模型"></a>3_RabbitMQ协议与消息模型</h1><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>RabbitMQ是基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</p><p>AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。</p><p>顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121320.png"></p><hr><h3 id="RabbitMQ支持的消息模型"><a href="#RabbitMQ支持的消息模型" class="headerlink" title="RabbitMQ支持的消息模型"></a>RabbitMQ支持的消息模型</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121321.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121322.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-RabbitMQ协议与消息模型&quot;&gt;&lt;a href=&quot;#3-RabbitMQ协议与消息模型&quot; class=&quot;headerlink&quot; title=&quot;3_RabbitMQ协议与消息模型&quot;&gt;&lt;/a&gt;3_RabbitMQ协议与消息模型&lt;/h1&gt;&lt;h3 id=&quot;AMQP协</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>2_web管理界面介绍</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/2-web%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/2-web%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-02-19T04:12:26.000Z</published>
    <updated>2021-02-19T04:24:12.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-web管理界面介绍"><a href="#2-web管理界面介绍" class="headerlink" title="2_web管理界面介绍"></a>2_web管理界面介绍</h1><h3 id="overview概览"><a href="#overview概览" class="headerlink" title="overview概览"></a>overview概览</h3><p>web界面连接rabbitmq的端口是15672</p><p>Java连接rabbitmq使用的是http端口5672</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121213.png"></p><ul><li><p><strong>connections：</strong> 无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况</p></li><li><p><strong>channels：</strong> 通道，建立连接后，会形成通道，消息的投递获取依赖通道</p></li><li><p><strong>Exchanges：</strong> 交换机，用来实现消息的路由</p></li><li><p><strong>Queues：</strong> 队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列</p></li></ul><hr><h3 id="Admin用户和虚拟主机管理"><a href="#Admin用户和虚拟主机管理" class="headerlink" title="Admin用户和虚拟主机管理"></a>Admin用户和虚拟主机管理</h3><h4 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1.添加用户"></a>1.添加用户</h4><p>Tags选项，其实是指定用户的角色，可选的有以下几个：</p><ul><li><strong>超级管理员(administrator)：</strong>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作</li><li><strong>监控者(monitoring)：</strong>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li><strong>策略制定者(policymaker)：</strong>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)</li><li><strong>普通管理者(management)：</strong>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理</li><li><strong>其他：</strong>无法登陆管理控制台，通常就是普通的生产者和消费者</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121214.png"></p><hr><h4 id="2-创建虚拟主机"><a href="#2-创建虚拟主机" class="headerlink" title="2. 创建虚拟主机"></a>2. 创建虚拟主机</h4><p>为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121215.png"></p><hr><h4 id="3-绑定虚拟主机和用户"><a href="#3-绑定虚拟主机和用户" class="headerlink" title="3. 绑定虚拟主机和用户"></a>3. 绑定虚拟主机和用户</h4><p>创建好虚拟主机，我们还要给用户添加访问权限</p><p>点击添加好的虚拟主机：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121216.png"></p><p>进入虚拟机设置界面:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121217.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-web管理界面介绍&quot;&gt;&lt;a href=&quot;#2-web管理界面介绍&quot; class=&quot;headerlink&quot; title=&quot;2_web管理界面介绍&quot;&gt;&lt;/a&gt;2_web管理界面介绍&lt;/h1&gt;&lt;h3 id=&quot;overview概览&quot;&gt;&lt;a href=&quot;#overvie</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>1_RabbitMQ的安装</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/1-RabbitMQ-%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/1-RabbitMQ-%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2021-02-19T04:11:07.000Z</published>
    <updated>2021-02-19T04:24:02.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-RabbitMQ-的安装"><a href="#1-RabbitMQ-的安装" class="headerlink" title="1_RabbitMQ 的安装"></a>1_RabbitMQ 的安装</h1><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>官网下载地址: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;download.html</span><br></pre></td></tr></table></figure><p>百度网盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1cngvGgR_EMlBLxFhSAM72w </span><br><span class="line">提取码：0n6a </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121053.png"></p><p>需要的安装包如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121054.png"></p><p><strong>注意:</strong> 这里的安装包是centos7安装的包</p><hr><h4 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.将rabbitmq安装包上传到linux系统中</span></span><br><span class="line">erlang-22.0.7-1.el7.x86<span class="emphasis">_64.rpm</span></span><br><span class="line"><span class="emphasis">rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.安装Erlang依赖包</span></span><br><span class="line">rpm -ivh erlang-22.0.7-1.el7.x86<span class="emphasis">_64.rpm</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 安装erlang开发环境包</span></span><br><span class="line"><span class="emphasis">rpm -ivh socat-1.7.3.2-2.el7.x86_</span>64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.安装RabbitMQ安装包(在线安装方式：需要联网)</span></span><br><span class="line">yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.本地安装</span></span><br><span class="line">rpm -ivh rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><hr><h4 id="3、复制配置文件"><a href="#3、复制配置文件" class="headerlink" title="3、复制配置文件"></a>3、复制配置文件</h4><p><strong>注意:</strong> </p><p>默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,</p><p>需要将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 4.复制配置文件</span></span><br><span class="line">cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br><span class="line"></span><br><span class="line"><span class="section"># 5.查看配置文件位置</span></span><br><span class="line">ls /etc/rabbitmq/rabbitmq.config</span><br></pre></td></tr></table></figure><h4 id="4、修改配置文件"><a href="#4、修改配置文件" class="headerlink" title="4、修改配置文件"></a>4、修改配置文件</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 6.修改配置文件(参见下图:)</span></span><br><span class="line">vim /etc/rabbitmq/rabbitmq.config </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121055.png"></p><p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121056.png"></p><hr><h4 id="5、启动管理插件"><a href="#5、启动管理插件" class="headerlink" title="5、启动管理插件"></a>5、启动管理插件</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 执行如下命令,启动rabbitmq中的插件管理</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq<span class="emphasis">_management</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">    出现如下说明:</span></span><br><span class="line"><span class="emphasis">    Enabling plugins on node rabbit@localhost:</span></span><br><span class="line"><span class="emphasis">    rabbitmq_</span>management</span><br><span class="line"><span class="code">    The following plugins have been configured:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    rabbitmq_management_agent</span></span><br><span class="line"><span class="code">    rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code">    Applying plugin configuration to rabbit@localhost...</span></span><br><span class="line"><span class="code">    The following plugins have been enabled:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    rabbitmq_management_agent</span></span><br><span class="line"><span class="code">    rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">set 3 plugins.</span></span><br><span class="line"><span class="code">Offline change; changes will take effect at broker restart.</span></span><br></pre></td></tr></table></figure><hr><h4 id="6、启动RabbitMQ的服务"><a href="#6、启动RabbitMQ的服务" class="headerlink" title="6、启动RabbitMQ的服务"></a>6、启动RabbitMQ的服务</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 8.启动RabbitMQ的服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="section"># 重启RabbitMQ的服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line"><span class="section"># 停止RabbitMQ的服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"><span class="section"># 查看服务状态(见下图:)</span></span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121057.png"></p><h4 id="7、关闭防火墙"><a href="#7、关闭防火墙" class="headerlink" title="7、关闭防火墙"></a>7、关闭防火墙</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 关闭防火墙服务</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld   </span><br></pre></td></tr></table></figure><hr><h4 id="8、访问web管理界面"><a href="#8、访问web管理界面" class="headerlink" title="8、访问web管理界面"></a>8、访问web管理界面</h4><p>访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:15672</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121058.png"></p><hr><h4 id="9、登录管理界面"><a href="#9、登录管理界面" class="headerlink" title="9、登录管理界面"></a>9、登录管理界面</h4><p>默认账户密码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 登录管理界面</span></span><br><span class="line">username:  guest</span><br><span class="line">password:  guest</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121059.png"></p><p>至此，RabbitMQ的安装到此完成！</p><hr><h4 id="10、RabiitMQ-配置"><a href="#10、RabiitMQ-配置" class="headerlink" title="10、RabiitMQ 配置"></a>10、RabiitMQ 配置</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.服务启动相关 [启动|重启|停止]</span></span><br><span class="line">systemctl start|restart|stop|status rabbitmq-server</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ</span></span><br><span class="line">rabbitmqctl  help  可以查看更多命令</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.插件管理命令行</span></span><br><span class="line">rabbitmq-plugins enable|list|disable </span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-RabbitMQ-的安装&quot;&gt;&lt;a href=&quot;#1-RabbitMQ-的安装&quot; class=&quot;headerlink&quot; title=&quot;1_RabbitMQ 的安装&quot;&gt;&lt;/a&gt;1_RabbitMQ 的安装&lt;/h1&gt;&lt;h4 id=&quot;1、下载安装包&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>0_RabbitMQ简介</title>
    <link href="http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/0-RabbitMQ%E7%AE%80%E4%BB%8B/"/>
    <id>http://jiangbk.top/2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/0-RabbitMQ%E7%AE%80%E4%BB%8B/</id>
    <published>2021-02-19T04:10:01.000Z</published>
    <updated>2021-02-19T04:10:41.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-RabbitMQ简介"><a href="#0-RabbitMQ简介" class="headerlink" title="0_RabbitMQ简介"></a>0_RabbitMQ简介</h1><p>👉：来源于哔哩哔哩”编程不良人”视频：<a href="https://www.bilibili.com/video/BV1dE411K7MG?p=1">MQ消息中间件之RabbitMQ以及整合SpringBoot2.x实战教程,已完结!</a></p><hr><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>MQ(Message Quene) :  翻译为 <code>消息队列</code>,通过典型的 <code>生产者</code>和<code>消费者</code>模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 <code>消息中间件</code>    通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p><hr><h2 id="MQ种类"><a href="#MQ种类" class="headerlink" title="MQ种类"></a>MQ种类</h2><p>当今市面上有很多主流的消息中间件，如老牌的 ActiveMQ、RabbitMQ，炙手可热的 Kafka，阿里巴巴自主开发RocketMQ等。</p><p>不同MQ特点：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.ActiveMQ</span></span><br><span class="line"><span class="code">ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.Kafka</span></span><br><span class="line"><span class="code">Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，</span></span><br><span class="line"><span class="code">追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，</span></span><br><span class="line"><span class="code">适合产生大量数据的互联网服务的数据收集业务。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 3.RocketMQ</span></span><br><span class="line"><span class="code">RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起</span></span><br><span class="line"><span class="code">源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消</span></span><br><span class="line"><span class="code">息推送、日志流式处理、binglog分发等场景。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 4.RabbitMQ</span></span><br><span class="line"><span class="code">RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在</span></span><br></pre></td></tr></table></figure><p><font color='orange'>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</font></p><hr><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一</p><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;</span><br></pre></td></tr></table></figure><p>官方教程: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;#getstarted</span><br></pre></td></tr></table></figure><p> AMQP 协议：AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219120945.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-RabbitMQ简介&quot;&gt;&lt;a href=&quot;#0-RabbitMQ简介&quot; class=&quot;headerlink&quot; title=&quot;0_RabbitMQ简介&quot;&gt;&lt;/a&gt;0_RabbitMQ简介&lt;/h1&gt;&lt;p&gt;👉：来源于哔哩哔哩”编程不良人”视频：&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="http://jiangbk.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/"/>
    
    
    <category term="中间件" scheme="http://jiangbk.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>9_ GC 四大算法详解</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/9-GC-%E5%9B%9B%E5%A4%A7%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/9-GC-%E5%9B%9B%E5%A4%A7%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-02-19T03:58:39.000Z</published>
    <updated>2021-02-19T04:04:35.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-GC-四大算法详解"><a href="#9-GC-四大算法详解" class="headerlink" title="9_ GC 四大算法详解"></a>9_ GC 四大算法详解</h1><h2 id="GC垃圾收集机制"><a href="#GC垃圾收集机制" class="headerlink" title="GC垃圾收集机制"></a>GC垃圾收集机制</h2><p>对于GC垃圾收集机制，我们需要记住以下几点：</p><ol><li>次数上频繁收集Young区。</li><li>次数上较少收集Old区。</li><li>基本不动元空间。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115842.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115843.png"></p><p><font color='red'>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。</font></p><p>因此GC按照回收的区域又分了两种类型：</p><ul><li><strong>普通GC（minor GC）：</strong> 只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。</li><li><strong>全局GC（major GC or Full GC）：</strong> 指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上</li></ul><hr><h2 id="GC日志信息详解"><a href="#GC日志信息详解" class="headerlink" title="GC日志信息详解"></a>GC日志信息详解</h2><h3 id="YGC相关参数"><a href="#YGC相关参数" class="headerlink" title="YGC相关参数"></a>YGC相关参数</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115844.png"></p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1580K-&gt;504K(2560K)] 1580K-&gt;764K(9728K), 0.0167268 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.02 secs] </span><br></pre></td></tr></table></figure><hr><h3 id="FGC相关参数"><a href="#FGC相关参数" class="headerlink" title="FGC相关参数"></a>FGC相关参数</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115845.png"></p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 592K-&gt;574K(7168K)] 592K-&gt;574K(9728K), [Metaspace: 3158K-&gt;3158K(1056768K)], 0.0040996 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br></pre></td></tr></table></figure><hr><p>使用规律：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115846.png"></p><hr><h2 id="判断-Java-对象存活算法"><a href="#判断-Java-对象存活算法" class="headerlink" title="判断 Java 对象存活算法"></a>判断 Java 对象存活算法</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a><del>1. 引用计数算法</del></h3><blockquote><p>引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器 +1，当引用失效的时候，计数器 -1，当计数器为 0 的时候，JVM 就认为对象不再被使用，即判定为“垃圾”了。</p></blockquote><p>优点：</p><ul><li>引用计数器实现简单，效率高</li></ul><p>缺点：</p><ul><li>不能解决循环引用问问题 （A对象引用B对象，B对象又引用A对象，但是 A,B 对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在 JDK 1.1 之后，这个算法已经不再使用了。</li></ul><hr><h3 id="2-根搜索方法"><a href="#2-根搜索方法" class="headerlink" title="2. 根搜索方法"></a>2. 根搜索方法</h3><blockquote><p>也叫可达性分析算法 。</p></blockquote><p><font color='red'>根搜索方法是通过一些 “GCRoots” 对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain），当一个对象没有被 GCRoots 的引用链连接的时候，说明这个对象是不可用的 。</font></p><p><strong>GCRoots对象包括：</strong></p><ol><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法栈中JNI（<code>Native</code>方法）的引用的对象。</li><li>方法区域中的类静态属性引用的对象。</li><li>方法区域中常量引用的对象。</li></ol><hr><p>实例：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115847.png"> </p><hr><h2 id="四大算法"><a href="#四大算法" class="headerlink" title="四大算法"></a>四大算法</h2><h3 id="1-复制算法-Copying"><a href="#1-复制算法-Copying" class="headerlink" title="1. 复制算法(Copying)"></a>1. 复制算法(Copying)</h3><blockquote><p>适用于<code>新生代</code></p></blockquote><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>年轻代中的 GC,主要是复制算法（Copying）。 HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫 from 和 to）。默认比例为 8:1:1,一般情况下，新创建的对象都会被分配到 Eden 区(一些大对象特殊处理),这些对象经过第一次 Minor GC 后，如果仍然存活，将会被移到 Survivor 区。对象在 Survivor 区中每熬过一次 Minor GC，年龄就会增加 1 岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，<strong>所以在年轻代的垃圾回收算法使用的是复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块(from)，当这一块内存用完，就将还活着的对象复制到另外一块上面。</p><hr><p>在 GC 开始的时候，对象只会存在于 Eden 区和名为“ From ”的 Survivor 区，Survivor区“ To ”是空的。紧接着进行 GC，Eden 区中所有存活的对象都会被复制到 “ To ”，而在“ From ”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到 “ To ”区域。<strong>经过这次GC后，Eden 区和 From 区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“ To ”就是上次 GC 前的“From”，新的“From”就是上次GC前的“To”</strong>。不管怎样，都会保证名为 To 的Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“ To ”区被填满，“ To ”区被填满之后，会将所有对象移动到年老代中。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115848.png"></p><p>因为 Eden 区对象一般存活率较低，一般的，使用两块 10% 的内存作为空闲和活动区间，而另外 80% 的内存，则是用来给新建对象分配内存的。一旦发生 GC，将 10% 的 from 活动区间与另外80%中存活的 eden 对象转移到 10% 的 to 空闲区间，接下来，将之前 90% 的内存全部释放，以此类推。</p><blockquote><p><code>-XX:MaxTenuringThreshold </code>：— 设置对象在新生代中存活的次数</p></blockquote><hr><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong> ：不会产生内存碎片，效率高。<br><strong>缺点</strong> ：耗费内存空间。</p><p>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。</p><p>所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p><hr><h3 id="2-标记清除-Mark-Sweep"><a href="#2-标记清除-Mark-Sweep" class="headerlink" title="2 .标记清除(Mark-Sweep)"></a>2 .标记清除(Mark-Sweep)</h3><blockquote><p>适用于<code>老年代</code></p></blockquote><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>标记清除算法，主要分成标记和清除两个阶段，<font color='red'>先标记出要回收的对象，然后统一回收这些对象</font>，如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115849.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115850.gif"></p><p>用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC 线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。</p><p>主要进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li>标记：从引用根节点开始标记遍历所有的GC Roots， 先标记出要回收的对象。</li><li>清除：遍历整个堆，把标记的对象清除。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115851.png"></p><hr><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong> ：不需要额外的内存空间。<br><strong>缺点</strong> ：需要暂停整个应用，会产生内存碎片；两次扫描，耗时严重。</p><p>简单来说，它的缺点就是<strong>效率比较低</strong>（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲。</p><p>而且这种方式<strong>清理出来的空闲内存是不连续</strong>的，这点不难理解，我们的死亡对象都是随机分布在内存当中，现在把它们清除之后，内存的布局自然会零碎不连续。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。并且在分配数组对象的时候，需要去内存寻找连续的内存空间，但此时的内存空间太过零碎分散，因此资源耗费加大。</p><hr><h3 id="3-标记压缩-Mark-Compact"><a href="#3-标记压缩-Mark-Compact" class="headerlink" title="3. 标记压缩(Mark-Compact)"></a>3. 标记压缩(Mark-Compact)</h3><blockquote><p>适用于<code>老年代</code></p><p>标记压缩(Mark-Compact)又叫标记清除压缩(Mark-Sweep-Compact)，或者标记清除整理算法</p></blockquote><h4 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h4><p>简单来说，就是<strong>先标记，后整理</strong>，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115852.gif"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115853.png"></p><hr><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong> ：没有内存碎片。<br><strong>缺点</strong> ：需要移动对象的成本，效率也不高（不仅要标记所有存活对象，还要整理所有存活对象的引用地址）。</p><p>标记清除压缩（Mark-Sweep-Compact）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115854.png"></p><hr><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.  分代收集算法"></a>4.  分代收集算法</h3><blockquote><p>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，<font color='red'>一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。</font></p><p>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用<code>复制算法</code>，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用<code>“标记清理”或者“标记整理”算法</code>来进行回收。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115855.png"></p><p>图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="年轻代（Young-Gen）"><a href="#年轻代（Young-Gen）" class="headerlink" title="年轻代（Young Gen）"></a>年轻代（Young Gen）</h4><blockquote><p><strong>年轻代特点是内存空间相对老年代较小，对象存活率低。</strong></p></blockquote><p>复制算法的效率只和当前存活对象大小有关，因而很适用于年轻代的回收。而复制算法的内存利用率不高的问题，可以通过虚拟机中的两个<code>Survivor</code>区设计得到缓解。</p><hr><h4 id="老年代（Tenure-Gen）"><a href="#老年代（Tenure-Gen）" class="headerlink" title="老年代（Tenure Gen）"></a>老年代（Tenure Gen）</h4><blockquote><p><strong>老年代的特点是内存空间较大，对象存活率高。</strong></p></blockquote><p>这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</p><p>（1）<strong>标记阶段（Mark）</strong> 的开销与存活对象的数量成正比。这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。<br>（2）<strong>清除阶段（Sweep）</strong> 的开销与所管理内存空间大小形正相关。但Sweep“就地处决”的特点，回收的过程没有对象的移动。使其相对其他有对象移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。<br>（3）<strong>整理阶段（Compact）</strong> 的开销与存活对象的数据成开比。如上一条所描述，对于大量对象的移动是很大开销的，做为老年代的第一选择并不合适。</p><p>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以虚拟机中的CMS回收器为例，CMS是基于<code>Mark-Sweep</code>实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于<code>Mark-Compact</code>算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的<code>Concurrent Mode Failure</code>时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p><hr><p>常见面试问题：</p><blockquote><p>问题1：GC四种算法哪个好？</p></blockquote><p>没有哪个算法是能一次性解决所有问题的，因为JVM垃圾回收使用的是分代收集算法，没有最好的算法，只有根据每一代他的垃圾回收的特性用对应的算法。例如新生代使用复制算法，老年代使用标记清除和标记整理算法。<br>所以说，没有最好的垃圾回收机制，只有最合适的。</p><blockquote><p>问题2：请说出各个垃圾回收算法的优缺点</p></blockquote><p><strong>（1）内存效率：</strong> 复制算法 &gt; 标记清除算法 &gt; 标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。<br><strong>（2）内存整齐度：</strong> 复制算法 = 标记整理算法 &gt; 标记清除算法。<br><strong>（3）内存利用率：</strong> 标记整理算法 = 标记清除算法 &gt; 复制算法。</p><p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记清除多了一个整理内存的过程。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9-GC-四大算法详解&quot;&gt;&lt;a href=&quot;#9-GC-四大算法详解&quot; class=&quot;headerlink&quot; title=&quot;9_ GC 四大算法详解&quot;&gt;&lt;/a&gt;9_ GC 四大算法详解&lt;/h1&gt;&lt;h2 id=&quot;GC垃圾收集机制&quot;&gt;&lt;a href=&quot;#GC垃圾收集机</summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>8_Java堆</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/8-Java%E5%A0%86/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/8-Java%E5%A0%86/</id>
    <published>2021-02-19T03:57:40.000Z</published>
    <updated>2021-02-19T03:58:18.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-Java堆"><a href="#8-Java堆" class="headerlink" title="8_Java堆"></a>8_Java堆</h1><blockquote><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。</p></blockquote><h2 id="堆体系结构"><a href="#堆体系结构" class="headerlink" title="堆体系结构"></a>堆体系结构</h2><p><strong>JDK 1.7：</strong>  <font color='red'>永久代使用的是堆空间内存</font></p><p>类加载器读取了类文件之后，需要把类、方法、常量变量放到堆内存中，保持所以引用类型的真实信息，方便执行器执行。</p><p>其中，堆内存分为3个部分：</p><ul><li>Young Generation Space，新生区、新生代</li><li>Tenure Generation Space，老年区、老年代</li><li>Permanent Space，永久区、元空间</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115747.jpg"></p><hr><p><strong>JDK 1.8：</strong>  <font color='red'>将永久区变成了元空间，使用的是物理内存</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115748.jpg"></p><hr><h2 id="对象在堆中的生命周期"><a href="#对象在堆中的生命周期" class="headerlink" title="对象在堆中的生命周期"></a>对象在堆中的生命周期</h2><p>那么如何直观的了解对象在堆中的生命周期呢？</p><ul><li><p>首先，新生区是类的诞生、成长、消亡的区域。一个类在这里被创建并使用，最后被垃圾回收器收集，结束生命。</p></li><li><p>其次，所有的类都是 <font color='green'>在Eden Space被new出来的</font>。而当Eden Space的空间用完时，程序又需要创建对象，JVM的垃圾回收器则会将Eden Space中不再被其他对象所引用的对象进行销毁，也就是垃圾回收（Minor GC）。此时的GC可以认为是<font color='red'>轻量级GC</font>。</p></li><li><p>然后将Eden Space中剩余的未被回收的对象，移动到 <strong>Survivor 0 Space</strong>，以此往复，直到Survivor 0 Space也满了的时候，再对Survivor 0 Space进行垃圾回收，剩余的未被回收的对象，则再移动到 <strong>Survivor 1 Space</strong>。Survivor 1 Space也满了的话，再移动至 <strong>Tenure Generation Space</strong>。</p></li><li><p>最后，如果Tenure Generation Space也满了的话，那么这个时候就会被垃圾回收（Major GC or Full GC）并将该区的内存清理。此时的GC可以认为是<font color='red'><strong>重量级GC</strong></font>。如果Tenure Generation Space被GC垃圾回收之后，依旧处于占满状态的话，就会产生我们场景的OOM异常，即 <code>OutOfMemoryError</code>。</p></li></ul><hr><h3 id="Minor-GC的过程"><a href="#Minor-GC的过程" class="headerlink" title="Minor GC的过程"></a>Minor GC的过程</h3><p>前提：</p><ul><li>Survivor 0 Space，幸存者0区，也叫from区</li><li>Survivor 1 Space，幸存者1区，也叫to区</li><li>新生区：养老区=1：2</li><li>Eden：s0：s1=8：1：1</li><li><strong>每次从伊甸园区经过GC幸存的对象，年龄(代数)会+1</strong></li></ul><p>其中，from区和to区的区分不是固定的，是互相交换的，意思是说，在每次GC之后，两者会进行交换，谁空谁就是to区。</p><hr><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115749.png"></p><ol><li><strong>Eden Space、from复制到to，年龄+1。</strong><br>首先，当Eden Space满时，会触发第一次GC，把还活着的对象拷贝到from区。而当Eden Space再次触发GC时，会扫描Eden Space和from，对这两个区进行垃圾回收，经过此次回收后依旧存活的对象，则直接复制到to区（如果对象的年龄已经达到老年的标准，则移动至老年代区），同时把这些对象的年龄+1。</li><li><strong>清空Eden Space、from</strong><br>然后，清空Eden Space和from中的对象，此时的from是空的。</li><li><strong>from和to互换</strong><br>最后，from和to进行互换，原from成为下一次GC时的to，原to成为下一次GC时的from。部分对象会在from和to中来回进行交换复制，如果交换15次（由JVM参数MaxTenuringThreshold决定，默认15），最终依旧存活的对象就会移动至老年代。</li></ol><blockquote><p>总结一句话：<font color='red'>GC之后有交换，谁空谁是to</font></p><p>这样也是为了保证内存中没有碎片，所以Survivor 0 Space和Survivor 1 Space有一个要是空的</p></blockquote><hr><h2 id="HotSpot虚拟机的内存管理"><a href="#HotSpot虚拟机的内存管理" class="headerlink" title="HotSpot虚拟机的内存管理"></a>HotSpot虚拟机的内存管理</h2><blockquote><p>不同对象的生命周期不同，其中98%的对象都是临时对象，即这些对象的生命周期大多只存在于Eden区。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115750.png"></p><p>实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等。</p><p><strong>虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做<code>Non-Heap</code>（非堆内存），目的就是要和堆区分开。</strong></p><p>对于HotSpot虚拟机而言，很多开发者习惯将方法区称为 “永久代（Permanent Gen）” 。但严格来说两者是不同的，或者说只是使用永久代来实现方法区而已，永久代是方法区（可以理解为一个接口<code>interface</code>）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。（字符串常量池，JDK1.6在方法区，JDK1.7在堆，JDK1.8在元空间。）<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115751.png" alt="在这里插入图片描述"></p><p>如果没有明确指明，Java虚拟机的名字就叫做<code>HotSpot</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115752.png" alt="在这里插入图片描述"></p><hr><h2 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h2><blockquote><p>永久区是一个常驻内存区域，用于存放JDK自身所携带的<code>Class</code>，<code>Interface</code>的元数据（也就是上面文章提到的<code>rt.jar</code>等），也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。</p></blockquote><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115753.png" alt="在这里插入图片描述"></p><hr><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115754.png" alt="在这里插入图片描述"></p><p>在JDK1.8中，永久代已经被移除，被一个称为<strong>元空间</strong>的区域所取代。元空间的本质和永久代类似。</p><hr><p><font color='red'>元空间与永久代之间最大的区别在于： 永久带使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存。</font></p><p>因此，默认情况下，元空间的大小仅受本地内存限制。</p><hr><h2 id="堆参数调优"><a href="#堆参数调优" class="headerlink" title="堆参数调优"></a>堆参数调优</h2><blockquote><p>注意：尽量配置初始内存和最大内存一样大，<font color='red'>避免GC和应用程序争抢内存，进而导致内存忽高忽低产生停顿</font></p></blockquote><p>获取虚拟机的相关内存信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMMemory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回 Java 虚拟机试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX_MEMORY = &quot;</span> + maxMemory + <span class="string">&quot;（字节）、&quot;</span> + (maxMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 Java 虚拟机中的内存总量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;TOTAL_MEMORY = &quot;</span> + totalMemory + <span class="string">&quot;（字节）、&quot;</span> + (totalMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：虚拟机最大内存为物理内存的1/4，而初始分配的内存为物理内存的1/64</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115755.png"></p><hr><p>配置JVM内存参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115756.png"></p><p>运行结果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115757.png"></p><hr><h2 id="堆溢出-OutOfMemoryError"><a href="#堆溢出-OutOfMemoryError" class="headerlink" title="堆溢出 OutOfMemoryError"></a>堆溢出 OutOfMemoryError</h2><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;Atlantis&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每执行下面语句，会在堆里创建新的对象</span></span><br><span class="line">            str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把堆内存调成10M后，再一直new对象，导致Full GC也无法处理，直至撑爆堆内存，进而导致<code>OOM</code>堆溢出错误</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115758.png"></p><p>出现<code>java.lang.OutOfMemoryError: Java heap space</code>异常，说明Java虚拟机的堆内存不够，造成堆内存溢出。原因有两点：</p><ul><li>①Java虚拟机的堆内存设置太小，可以通过参数<code>-Xms</code>和<code>-Xmx</code>来调整。</li><li>②代码中创建了大量对象，并且长时间不能被GC回收（存在被引用）。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;8-Java堆&quot;&gt;&lt;a href=&quot;#8-Java堆&quot; class=&quot;headerlink&quot; title=&quot;8_Java堆&quot;&gt;&lt;/a&gt;8_Java堆&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>7_方法区</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/7-%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/7-%E6%96%B9%E6%B3%95%E5%8C%BA/</id>
    <published>2021-02-19T03:56:41.000Z</published>
    <updated>2021-02-19T03:57:13.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-方法区"><a href="#7-方法区" class="headerlink" title="7_方法区"></a>7_方法区</h1><p>所在位置：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115641.png"></p><p>从线程共享与否的角度来看：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115642.png"></p><hr><p>栈、堆、方法区的交互关系：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115643.png"></p><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><hr><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区<strong>在逻辑上</strong>是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做<strong>Non-Heap（非堆）</strong>【物理上】，目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于 Java 堆的内存空间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115644.png"></p><ul><li><p>黄色部分：线程共享</p></li><li><p>灰色部分：线程私有</p></li></ul><hr><p>方法区主要存放的是 <strong>Class</strong>，而堆中主要存放的是 <strong>实例化的对象</strong></p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在 jdk7 及以前，习惯上把方法区，称为<strong>永久代</strong>。jdk8开始，使用 <strong>元空间</strong> 取代了永久代。</p><ul><li>JDK 1.7 ，永久代使用的是堆的内存。</li><li>JDK 1.8后，元空间存放在堆外内存中。【使用的是本机物理内存】</li></ul><p>本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。</p><blockquote><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115645.png"></p><p>而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115646.png"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong> 。</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了，根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</p><hr><h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p>方法区的大小不必是固定的，JVM 可以根据应用的需要动态调整。</p><h4 id="JDK-7-及以前"><a href="#JDK-7-及以前" class="headerlink" title="JDK 7 及以前"></a>JDK 7 及以前</h4><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当 JVM 加载的类信息容量超过了这个值，会报异常<code>OutofMemoryError:PermGen space</code> 。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115647.png"></p><hr><h4 id="JDK-8-以后"><a href="#JDK-8-以后" class="headerlink" title="JDK 8 以后"></a>JDK 8 以后</h4><p>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和 <code>-XX:MaxMetaspaceSize</code>指定 。</p><blockquote><p>默认值依赖于平台。windows下：</p><p>-XX:MetaspaceSize是21M，</p><p>-XX:MaxMetaspaceSize的值是-1，即没有限制。</p></blockquote><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code> 。</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值 。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;7-方法区&quot;&gt;&lt;a href=&quot;#7-方法区&quot; class=&quot;headerlink&quot; title=&quot;7_方法区&quot;&gt;&lt;/a&gt;7_方法区&lt;/h1&gt;&lt;p&gt;所在位置：&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;h</summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>6_Java 虚拟机栈</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/6-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/6-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</id>
    <published>2021-02-19T03:55:43.000Z</published>
    <updated>2021-02-19T03:56:19.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-Java-虚拟机栈"><a href="#6-Java-虚拟机栈" class="headerlink" title="6_Java 虚拟机栈"></a>6_Java 虚拟机栈</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>有不少 Java 开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p><p>首先栈是运行时的单位，而堆是存储的单位。</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115545.png"></p><h3 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a>Java虚拟机栈是什么</h3><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p><blockquote><p>栈帧：每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p></blockquote><p>同时，Java 栈是线程私有的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115546.png"></p><p>再比如，在 Java 中，test() 和 main() 都是方法，而在栈中，称为栈帧。在栈中，<code>main()</code>都是第一个入栈的。</p><blockquote><p>栈的顺序为：<code>main()</code>入栈 –&gt; <code>test()</code>入栈 –&gt; <code>test()</code>出栈 –&gt; <code>main()</code>出栈。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115547.png"></p><p>再来，接着观察下图，在图中一个栈中有两个栈帧，分别是<code>Stack Frame1</code>和<code>Stack Frame2</code>，对应方法1和方法2。其中<code>Stack Frame2</code>是最先被调用的方法2，所以它先入栈。然后方法2又调用了方法1，所以<code>Stack Frame1</code>处于栈顶位置。执行完毕后，依次弹出<code>Stack Frame1</code>和<code>Stack Frame2</code>，然后线程结束，栈释放。<br>所以，每执行一个方法都会产生一个栈帧，并保存到栈的顶部，顶部的栈帧就是当前所执行的方法，该方法执行完毕后会自动出栈。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115548.png"></p><p>总结如下，栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，方法A中又调用了方法B，于是产生栈帧F2也被压入栈中，方法B又调用方法C，于是产生栈帧F3也被压入栈中······执行完毕后，<strong>遵循“先进后出，后进先出”的原则</strong>，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了 。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><blockquote><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p></blockquote><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>同时，对于栈来说不存在垃圾回收问题（栈存在溢出的情况）。</p><blockquote><p>你这样想，加入有存在垃圾等着被回收的话，那岂不是栈就被堵住了。</p></blockquote><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115549.png"  /><h3 id="开发中遇到哪些异常？"><a href="#开发中遇到哪些异常？" class="headerlink" title="开发中遇到哪些异常？"></a>开发中遇到哪些异常？</h3><p>栈中可能出现的异常</p><p>Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackoverflowError </code>异常。</p><blockquote><p>此时是固定的 Java 栈没有内存可分配了，报 Error，和我们平时说的异常不一样。</p></blockquote><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <code>outofMemoryError </code>异常。</p><blockquote><p>Java 栈分配了 JVM 虚拟机的内存，但此时 Java 栈想要扩展，没有可分配的内存了，报 Error。【和堆内存溢出报的错一样】</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115550.png"></p><p>当栈深度达到 9656 的时候，就出现栈内存空间不足，就是因为不断调用方法，不断入栈创建栈帧，导致栈内存不足。</p><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;-Xss1m</span><br><span class="line">&gt;-Xss1k</span><br></pre></td></tr></table></figure><p>这里我们将栈内存设置为 2m，</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115551.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115552.png"></p><p>相比默认的 栈内存1m，此时栈深度达到了 19737 才报栈内存空间不足。</p><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>JVM直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115553.png"></p><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115554.png"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115555.png"></p><blockquote><p>关于栈帧的内部结构的具体探讨，这里没有放上来。</p></blockquote><h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul><li>举例栈溢出的情况？（<code>StackOverflowError</code>）<ul><li>通过 -Xss设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p></blockquote><p>运行时数据区，是否存在Error和GC？</p><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td></td></tr></tbody></table><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-Java-虚拟机栈&quot;&gt;&lt;a href=&quot;#6-Java-虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;6_Java 虚拟机栈&quot;&gt;&lt;/a&gt;6_Java 虚拟机栈&lt;/h1&gt;&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;he</summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>5_本地方法栈</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/5-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/5-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</id>
    <published>2021-02-19T03:54:47.000Z</published>
    <updated>2021-02-19T03:55:10.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5_本地方法栈"></a>5_本地方法栈</h1><p>Java 栈是属于线程私有，它的声明周期与线程同步，Java 方法被在调用时，入Java 栈成为一个一个栈帧，即 Java 虚拟机栈用于管理 Java 方法的调用，类似，<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个<code>stackoverflowError </code>异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个<code>outofMemoryError</code>异常。</li></ul><p>本地方法是使用 C 语言实现的。</p><p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115447.png"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><blockquote><p>都不归 JVM 管了，调用的是底层的操作系统资源 。</p></blockquote><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;5-本地方法栈&quot;&gt;&lt;a href=&quot;#5-本地方法栈&quot; class=&quot;headerlink&quot; title=&quot;5_本地方法栈&quot;&gt;&lt;/a&gt;5_本地方法栈&lt;/h1&gt;&lt;p&gt;Java 栈是属于线程私有，它的声明周期与线程同步，Java 方法被在调用时，入Java 栈成为一个</summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>4_ 本地方法接口</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-02-19T03:53:46.000Z</published>
    <updated>2021-02-19T03:54:21.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-本地方法接口"><a href="#4-本地方法接口" class="headerlink" title="4_ 本地方法接口"></a>4_ 本地方法接口</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>简单地讲，一个 Native Method 是一个 Java 调用非 Java 代码的接囗，其作用就是融合不同的编程语言为 Java 所用，它的初衷是用来融合 C/C++ 程序的，Java 诞生的时候是 C/C++ 流行时期，要想立足，就得调用 C/C++ 程序。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115353.png"></p><p>接下来，我们通过下图的多线程部分源码来理解什么是 native 方法。首先我们观察 start() 的源码，发现它其实并没有做什么复杂的操作，只是单纯的调用了 start0() 这个方法，然后我们去观察 start0() 的源码，发现它只是一个使用了 native 关键字修饰的一个方法<code>（private native void start0();）</code>，但只有声明却没有具体的实现！。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115354.png"></p><p>为什么？我们都知道 Thread 是<code>Class</code>关键字修饰的类（<code>class Thread implements Runnable</code>），而不是接口。一般来说，类中的方法都要有定义和实现，接口里面才有方法的定义声明。这就是 native 方法的独特之处，说白了，被<code>native</code>关键字修饰的方法，基本上和我们，甚至和 Java 都没啥关系了，因为它要去调用底层操作系统或者第三方语言的库函数，所以我们不需要去考虑它具体是如何实现的。</p><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><h3 id="与-Java-环境的交互"><a href="#与-Java-环境的交互" class="headerlink" title="与  Java 环境的交互"></a>与  Java 环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s  Java"></a>Sun’s  Java</h3><p>Sun的解释器是用 C 实现的，这使得它能像一些普通的C一样与外部交互。jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法 setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在 Windows 95 的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-本地方法接口&quot;&gt;&lt;a href=&quot;#4-本地方法接口&quot; class=&quot;headerlink&quot; title=&quot;4_ 本地方法接口&quot;&gt;&lt;/a&gt;4_ 本地方法接口&lt;/h1&gt;&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>3_程序计数器</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/3-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/3-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</id>
    <published>2021-02-19T03:52:44.000Z</published>
    <updated>2021-02-19T03:53:21.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3_程序计数器"></a>3_程序计数器</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>JVM 中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 <strong>PC计数器</strong>（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM 中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115246.png"></p><p>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎<code>Execution Engine</code>读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p><p>它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>PC寄存器一般用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出<code>（OutOfMemory，OOM）</code>错误。</p><blockquote><p>如果执行的是一个<code>native</code>方法，那这个计数器是空的。</p></blockquote><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><blockquote><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p></blockquote><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115247.png"  /><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-11-01 14:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115248.png"></p><p>通过 PC 寄存器，我们就可以知道当前程序执行到哪一步了</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115249.png"></p><hr><h3 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h3><blockquote><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p></blockquote><p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115250.png"></p><hr><h3 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h3><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115251.png"  /><hr><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><p>CPU 时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115252.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-程序计数器&quot;&gt;&lt;a href=&quot;#3-程序计数器&quot; class=&quot;headerlink&quot; title=&quot;3_程序计数器&quot;&gt;&lt;/a&gt;3_程序计数器&lt;/h1&gt;&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2_运行时数据区概述及线程</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-02-19T03:51:40.000Z</published>
    <updated>2021-02-19T04:03:02.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115144.png"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品 。</p><h2 id="JVM内存布局"><a href="#JVM内存布局" class="headerlink" title="JVM内存布局"></a>JVM内存布局</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM 内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。</p><p>不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>运行时数据区的完整图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115145.png"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁；另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><hr><p>左边淡黄色部分为多个线程共享：<strong>堆、方法区（具体实现：永久代 / 元空间）</strong></p><p>右边灰色部分为线程私有：<strong>Java 栈、本地方法栈、程序计数器</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115146.png"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。</p><p>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用Java线程中的 run（）方法。</p><h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。| 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运行时数据区概述及线程&quot;&gt;&lt;a href=&quot;#运行时数据区概述及线程&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区概述及线程&quot;&gt;&lt;/a&gt;运行时数据区概述及线程&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-</summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>1_JVM体系结构与类加载系统</title>
    <link href="http://jiangbk.top/2021/02/19/JVM/1-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F/"/>
    <id>http://jiangbk.top/2021/02/19/JVM/1-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-02-19T03:49:52.000Z</published>
    <updated>2021-02-19T04:03:12.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>👉来源Bilibili尚硅谷周阳老师JVM教程：<a href="https://www.bilibili.com/video/BV1vE411D7KE?from=search&seid=4040031347313595254">JVM_周阳老师教程</a></p></blockquote><h1 id="JVM体系结构与类加载系统"><a href="#JVM体系结构与类加载系统" class="headerlink" title="JVM体系结构与类加载系统"></a>JVM体系结构与类加载系统</h1><h2 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h2><p> JVM 的位置，JVM 是运行在操作系统之上的，它与硬件没有直接交互。</p><blockquote><p>补充：</p><ul><li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115001.png"></p><p>JVM 的整个体系结构图：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115002.png"  /><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="类装载器-ClassLoader"><a href="#类装载器-ClassLoader" class="headerlink" title="类装载器 ClassLoader"></a>类装载器 ClassLoader</h3><p>完整细节图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115003.png"></p><p>类装载器 ClassLoader 的作用：负责加载 class 文件的，将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。ClassLoader 只负责文件的加载，至于它是否可运行，则由 Execution Engine 决定。</p><blockquote><p>扩展一下：</p><ul><li><p>方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。</p></li><li><p>字节码文件存在于本地硬盘上。</p></li><li><p>class 与 Class：小写的 class，是指编译 Java 代码后所生成的以 .class 为后缀名的<strong>字节码文件</strong>。而大写的 Class，是 JDK 提供的 java.lang.Class，可以理解为封装<strong>类的模板</strong>。【模板实例化之后就得到n个相同的对象】</p></li><li><p>在 .class 文件-&gt; JVM &gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</p></li><li><p>JVM并不是通过检查文件后缀是不是 .class 来判断是否需要加载的，而是通过<strong>文件开头的特定文件标志</strong></p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115004.png"></p></blockquote><p>Car.class 字节码文件被 ClassLoader 类装载器加载并初始化，在方法区中生成了一个 Car Class 的类模板，而我们平时所用到的实例化，就是在这个类模板的基础上，形成了一个个实例，即car1，car2。反过来讲，我们可以对某个具体的实例进行 getClass() 操作，就可以得到该实例的类模板，即 Car Class。再接着，我们对这个类模板进行 getClassLoader() 操作，就可以得到这个类模板是由哪个类装载器进行加载的。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115005.png"  /><h3 id="类加载详细过程"><a href="#类加载详细过程" class="headerlink" title="类加载详细过程"></a>类加载详细过程</h3><blockquote><p>周阳老师这部分没有具体讲解，下面作补充，来源Bilibili尚硅谷宋红康老师JVM教程：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">硅谷2020最新版宋红康JVM教程</a></p></blockquote><p>完整的流程图如下所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115006.png"></p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</p><blockquote><h5 id="加载-class-文件的方式"><a href="#加载-class-文件的方式" class="headerlink" title="加载  .class 文件的方式"></a>加载  .class 文件的方式</h5><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul></blockquote><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><h5 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h5><p>目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><blockquote><p>工具：Binary Viewer查看</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115007.png"></p><p>如果出现不合法的字节码文件，那么将会验证不通过</p><p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115008.png"></p><p>安装完成后，我们编译完一个class文件后，点击 view 即可显示我们安装的插件来查看字节码方法了</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115009.png"></p><h5 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h5><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-10-31 20:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;  <span class="comment">//注意这里只是静态的在这个阶段设置默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的变量 a 在准备阶段会赋初始值，但不是 1，而是 0。</p><p>这里不包含用 final 修饰的static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</p><h5 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h5><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>初始化阶段就是执行类构造器方法<clinit>( ) 的过程。</p><ol><li>此方法不需定义，是 javac 编译器自动收集类中的所有 类变量的赋值动作 和 静态代码块中的语句 合并而来。</li></ol><blockquote><p>也就是说，当我们代码中包含 static 变量的时候，就会有 <clinit>( ) 方法。</p></blockquote><ol start="2"><li><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p></li><li><p><clinit> ( ) 不同于类的构造器【构造器是虚拟机视角下的<init>( )】，若该类具有父类，JVM 会保证子类的<clinit> ( ) 执行前，父类的<clinit> ( ) 已经执行完毕。</p></li></ol><blockquote><p>类构造器：任何一个类在声明后，都有生成一个构造器，默认是空参构造器 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         A = <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = A;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Son.b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回。</p></blockquote><ol start="4"><li>虚拟机必须保证一个类的<clinit>( )方法在多线程下被同步加锁。</li></ol><blockquote><p>Class 对象 是被加载到元空间，在 jdk 8之后，元空间是使用的本地物理内存，使用同步加锁这样可以避免被多次加载。</p></blockquote><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p><strong>（1）虚拟机自带的加载器</strong></p><ul><li>启动类加载器（Bootstrap），也叫根加载器，加载<code>%JAVAHOME%/jre/lib/rt.jar</code>。</li><li>扩展类加载器（Extension），加载<code>%JAVAHOME%/jre/lib/ext/*.jar</code>，例如<code>javax.swing</code>包。</li><li>应用程序类加载器（AppClassLoader），也叫系统类加载器，加载<code>%CLASSPATH%</code>的所有类。</li></ul><p><strong>（2）用户自定义的加载器</strong> ：</p><ul><li>用户可以自定义类的加载方式，但必须是<code>Java.lang.ClassLoader</code>的子类。</li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115010.png" style="zoom:67%;" /><p>接下来自定义的 MyObject，首先通过 getClassLoader() 获取到的是 AppClassLoader，然后 getParent() 得到ExtClassLoader，再 getParent() 竟然是null？可能大家会有疑惑，不应该是 Bootstrap 加载器么？这是因为，BootstrapClassLoader 是使用C++语言编写的，Java 在加载的时候就成了 null。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115011.png"></p><p>我们再来看 Java 自带的 Object，通过 getClassLoader() 获取到的加载器直接就是 BootstrapClassLoader，如果要想getParent() 的话，因为是 null 值，所以就会报 <code>java.lang.NullPointerException</code>空指针异常。</p><blockquote><p>sun.misc.Launcher 它是一个 java 虚拟机的入口应用</p></blockquote><hr><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115012.png"></p><blockquote><p>采用双亲委派的一个好处是，比如加载位于<code>rt.jar</code>包中的类<code>java.lang.Object</code>，不管是哪个加载器加载这个类，最终都是委派给顶层的启动类加载器进行加载，确保哪怕使用了不同的类加载器，最终得到的都是同样一个<code>Object</code>对象。</p></blockquote><hr><p>Tip：<code>rt.jar</code>是什么？为什么可以在idea这些开发工具中可以直接去使用String、ArrayList、甚至一些JDK提供的类和方法？观察下面动图就可以知道，原来这些都在<code>rt.jar</code>中定义好了，且直接被启动类加载器进行加载了。</p><hr><h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar包中java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是rt.jar包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><h4 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h4><p>双亲机制可以：</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;👉来源Bilibili尚硅谷周阳老师JVM教程：&lt;a href=&quot;https://www.bilibili.com/video/BV1vE411D7KE?from=search&amp;seid=4040031347313595254&quot;&gt;JVM_周阳老师</summary>
      
    
    
    
    <category term="JVM" scheme="http://jiangbk.top/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://jiangbk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>微服务/分布式</title>
    <link href="http://jiangbk.top/2021/02/19/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://jiangbk.top/2021/02/19/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2021-02-19T02:39:02.000Z</published>
    <updated>2021-02-19T02:51:27.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务-分布式"><a href="#微服务-分布式" class="headerlink" title="微服务/分布式"></a>微服务/分布式</h2><p>今天分享一下微服务/分布式常见的面试问题，不过这些问题都是针对应届生的，对于比较senior的求职者应该会深入很多。题目都是来自2020大厂真实面经！</p><p>没有了解过分布式/微服务的老哥们也不要担心看不懂这篇文章，内容我都是大白话讲出来的，非常易懂，带你速览分布式/微服务。</p><p>概览（看看自己能回答几题）：</p><ol><li>为什么要网关？</li><li>你知道有哪些常见的网关系统？</li><li>限流的算法有哪些？</li><li>为什么要分布式 id ？</li><li>分布式 id 生成策略有哪些？</li><li>了解RPC吗？</li><li>有哪些常见的 RPC 框架？</li><li>如果让你自己设计 RPC 框架你会如何设计？</li><li>Dubbo 了解吗？</li><li>Dubbo 提供了哪些负载均衡策略？</li><li>谈谈你对微服务领域的了解和认识！</li></ol><h3 id="为什么要网关？"><a href="#为什么要网关？" class="headerlink" title="为什么要网关？"></a>为什么要网关？</h3><p>微服务下一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。</p><p>综上：<strong>一般情况下，网关一般都会提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控这些功能。</strong></p><p>上面介绍了这么多功能实际上网关主要做了一件事情：<strong>请求过滤</strong> 。权限校验、流量控制这些都可以通过过滤器实现，请求转也是通过过滤器实现的。</p><h3 id="你知道有哪些常见的网关系统？"><a href="#你知道有哪些常见的网关系统？" class="headerlink" title="你知道有哪些常见的网关系统？"></a>你知道有哪些常见的网关系统？</h3><p>我所了解的目前经常用到的开源 API 网关系统有：</p><ol><li>Kong</li><li>Netflix zuul</li></ol><p>下图来源：<a href="https://www.stackshare.io/stackups/kong-vs-zuul">https://www.stackshare.io/stackups/kong-vs-zuul</a> 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/kong-vs-zuul.jpg" alt="Kong vs Netflix zuul">Kong vs Netflix zuul</p><p>可以看出不论是社区活跃度还是 Star数， Kong 都是略胜一筹。总的来说，Kong 相比于 Zuul 更加强大并且简单易用。Kong 基于 Openresty ，Zuul 基于 Java。</p><blockquote><p>OpenResty（也称为 ngx_openresty）是一个全功能的 Web 应用服务器。它打包了标准的 Nginx 核心，很多的常用的第三方模块，以及它们的大多数依赖项。</p><p>通过揉和众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用。——OpenResty</p></blockquote><p>另外， Kong 还提供了插件机制来扩展其功能。</p><p>比如、在服务上启用 Zipkin 插件</p><ul><li>ounter(line</li><li>ounter(line</li><li>ounter(line</li><li>ounter(line</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST http:&#x2F;&#x2F;kong:8001&#x2F;services&#x2F;&#123;service&#125;&#x2F;plugins \ --data &quot;name&#x3D;zipkin&quot; \ --data &quot;config.http_endpoint&#x3D;http:&#x2F;&#x2F;your.zipkin.collector:9411&#x2F;api&#x2F;v2&#x2F;spans&quot; \ --data &quot;config.sample_ratio&#x3D;0.001&quot;</span><br></pre></td></tr></table></figure><p>ps:这里没有太深入去探讨，需要深入了解的话可以自行查阅相关资料。</p><h3 id="限流的算法有哪些？"><a href="#限流的算法有哪些？" class="headerlink" title="限流的算法有哪些？"></a>限流的算法有哪些？</h3><p>简单介绍 4 种非常好理解并且容易实现的限流算法！</p><p>下图的图片不是 Guide 哥自己画的哦！图片来源于 InfoQ 的一篇文章<a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673">《分布式服务限流实战，已经为你排好坑了》</a>。</p><h4 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h4><p>规定我们单位时间处理的请求数量。比如我们规定我们的一个接口一分钟只能访问10次的话。使用固定窗口计数器算法的话可以这样实现：给定一个变量counter来记录处理的请求数量，当1分钟之内处理一个请求之后counter+1，1分钟之内的如果counter=100的话，后续的请求就会被全部拒绝。等到 1分钟结束后，将counter回归成0，重新开始计数（ps：只要过了一个周期就讲counter回归成0）。</p><p>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。比如我们限制一个接口一分钟只能访问10次的话，前半分钟一个请求没有接收，后半分钟接收了10个请求。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png" alt="固定窗口计数器算法">固定窗口计数器算法</p><h4 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h4><p>算的上是固定窗口计数器算法的升级版。滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：它把时间以一定比例分片。例如我们的借口限流每分钟处理60个请求，我们可以把 1 分钟分为60个窗口。每隔1秒移动一次，每个窗口一秒只能处理 不大于 60(请求数)/60（窗口数） 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p><p>很显然：当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png" alt="滑动窗口计数器算法">滑动窗口计数器算法</p><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png" alt="漏桶算法">漏桶算法</p><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png" alt="令牌桶算法">令牌桶算法</p><h3 id="为什么要分布式-id-？"><a href="#为什么要分布式-id-？" class="headerlink" title="为什么要分布式 id ？"></a>为什么要分布式 id ？</h3><blockquote><p>这部分内容来自：**<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93.md">分布式id生成方案总结</a>**</p></blockquote><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。</p><h3 id="分布式-id-生成策略有哪些？"><a href="#分布式-id-生成策略有哪些？" class="headerlink" title="分布式 id 生成策略有哪些？"></a>分布式 id 生成策略有哪些？</h3><p>详细解读请查看：**<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93.md">分布式id生成方案总结</a>**</p><p><img src= "/img/loading.gif" data-lazy-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" alt="常用分布式id方案">常用分布式id方案</p><h3 id="了解RPC吗？"><a href="#了解RPC吗？" class="headerlink" title="了解RPC吗？"></a>了解RPC吗？</h3><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p><p><strong>RPC原理是什么？</strong></p><p>我这里这是简单的提一下。详细内容可以查看下面这篇文章：</p><p><a href="http://www.importnew.com/22003.html">http://www.importnew.com/22003.html</a></p><p><img src= "/img/loading.gif" data-lazy-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg" alt="RPC原理图">RPC原理图</p><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>下面再贴一个网上的时序图：</p><p><img src= "/img/loading.gif" data-lazy-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/32527396.jpg" alt="RPC原理时序图">RPC原理时序图</p><h3 id="有哪些常见的-RPC-框架？"><a href="#有哪些常见的-RPC-框架？" class="headerlink" title="有哪些常见的 RPC 框架？"></a>有哪些常见的 RPC 框架？</h3><ul><li><strong>RMI（JDK自带）：</strong> JDK自带的RPC。详细内容可以参考：<a href="https://blog.csdn.net/lmy86263/article/details/72594760">从懵逼到恍然大悟之Java中RMI的使用</a></li><li><strong>Dubbo:</strong> Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。详细内容可以参考：<a href="https://blog.csdn.net/qq_34337272/article/details/79862899">高性能优秀的服务框架-dubbo介绍</a></li><li><strong>gRPC</strong>： Google 公布的开源软件，基 HTTP 2.0 协议，并支持常见的众多编程语言。</li><li><strong>Thrift：</strong> Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。详细内容可以参考： <a href="https://www.cnblogs.com/zeze/p/8628585.html">【Java】分布式RPC通信框架Apache Thrift 使用总结</a></li><li><strong>Hessian：</strong> Hessian是一个轻量级的remotingonhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。详细内容可以参考： <a href="https://blog.csdn.net/sunwei_pyw/article/details/74002351">Hessian的使用以及理解</a></li></ul><h3 id="如果让你自己设计-RPC-框架你会如何设计？"><a href="#如果让你自己设计-RPC-框架你会如何设计？" class="headerlink" title="如果让你自己设计 RPC 框架你会如何设计？"></a>如果让你自己设计 RPC 框架你会如何设计？</h3><p>一个典型的使用 RPC 的场景如下，一般情况下 RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这个的 RPC 框架才算真正合格。</p><p><img src= "/img/loading.gif" data-lazy-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84rpc%E6%A1%86%E6%9E%B6.jpg" alt="一个完整的RPC框架使用示意图">一个完整的RPC框架使用示意图</p><p>简单说一下思路：</p><ol><li>注册中心首先是要有的，推荐使用  Zookeeper。注册中心主要用来保存相关的信息比如远程方法的地址。</li><li>既然要要互相调用方法就要发请求，推荐nio 的 netty框架。</li><li>发请求发送什么数据呢？我们就要考虑序列化协议了。</li><li>另外，动态代理也是需要的。因为 RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，使用动态代理屏蔽远程接口调用的细节比如网络传输。推荐一篇我觉得非常不错的动态代理的文章：<a href="https://juejin.im/post/5a99048a6fb9a028d5668e62">《10分钟看懂动态代理设计模式》</a></li><li>负载均衡也是需要的。为啥？举个例子我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。。</li></ol><h3 id="了解Dubbo吗-？"><a href="#了解Dubbo吗-？" class="headerlink" title="了解Dubbo吗 ？"></a>了解Dubbo吗 ？</h3><p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p><p>Dubbo 目前已经有接近 31.2k 的 Star ，Dubbo的Github 地址：<a href="https://github.com/apache/incubator-dubbo">https://github.com/apache/incubator-dubbo</a> 。</p><p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得国内越来越多的公司开始使用以及接受分布式架构。</p><h3 id="Dubbo-提供了哪些负载均衡策略？"><a href="#Dubbo-提供了哪些负载均衡策略？" class="headerlink" title="Dubbo 提供了哪些负载均衡策略？"></a>Dubbo 提供了哪些负载均衡策略？</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 <code>random</code> 随机调用。可以自行扩展负载均衡策略，参见：<a href="https://dubbo.gitbooks.io/dubbo-dev-book/content/impls/load-balance.html">负载均衡扩展</a>。</p><p>备注:下面的图片来自于：尚硅谷2018Dubbo 视频。</p><h4 id="Random-LoadBalance-默认，基于权重的随机负载均衡机制"><a href="#Random-LoadBalance-默认，基于权重的随机负载均衡机制" class="headerlink" title="Random LoadBalance(默认，基于权重的随机负载均衡机制)"></a>Random LoadBalance(默认，基于权重的随机负载均衡机制)</h4><ul><li><strong>随机，按权重设置随机概率。</strong></li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/77722327.jpg" alt="基于权重的随机负载均衡机制">基于权重的随机负载均衡机制</p><h4 id="RoundRobin-LoadBalance-不推荐，基于权重的轮询负载均衡机制"><a href="#RoundRobin-LoadBalance-不推荐，基于权重的轮询负载均衡机制" class="headerlink" title="RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)"></a>RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)</h4><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/97933247.jpg" alt="基于权重的轮询负载均衡机制">基于权重的轮询负载均衡机制</p><h4 id="LeastActive-LoadBalance-最少活跃调用负载均衡机制"><a href="#LeastActive-LoadBalance-最少活跃调用负载均衡机制" class="headerlink" title="LeastActive LoadBalance(最少活跃调用负载均衡机制)"></a>LeastActive LoadBalance(最少活跃调用负载均衡机制)</h4><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul><h4 id="ConsistentHash-LoadBalance-一致性-Hash负载均衡机制"><a href="#ConsistentHash-LoadBalance-一致性-Hash负载均衡机制" class="headerlink" title="ConsistentHash LoadBalance(一致性 Hash负载均衡机制)"></a>ConsistentHash LoadBalance(一致性 Hash负载均衡机制)</h4><ul><li><strong>一致性 Hash，相同参数的请求总是发到同一提供者。(如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。)</strong></li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li></ul><h3 id="谈谈你对微服务领域的了解和认识"><a href="#谈谈你对微服务领域的了解和认识" class="headerlink" title="谈谈你对微服务领域的了解和认识"></a>谈谈你对微服务领域的了解和认识</h3><p>现在大公司都在用并且未来的趋势都是 Spring Cloud，而阿里开源的 Spring Cloud Alibaba 也是 Spring Cloud 规范的实现 。</p><p>我们通常把 Spring Cloud 理解为一系列开源组件的集合，但是 Spring Cloud并不是等同于 Spring Cloud Netflix 的 Ribbon（负载均衡）、Feign（远程调用）、Eureka（服务注册与发现，已经停止更新）、Hystrix（熔断）、Zuul （网关）； 这一套组件，而是抽象了一套通用的开发模式。它的目的是通过抽象出这套通用的模式，让开发者更快更好地开发业务。但是这套开发模式运行时的实际载体，还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。</p><blockquote><p>更多关于 Spring Cloud Netflix 的内容参见： <strong><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/system-design/micro-service/spring-cloud.md">大白话入门 Spring Cloud</a></strong></p></blockquote><p>Spring Cloud Alibaba 是官方认证的新一套 Spring Cloud 规范的实现,Spring Cloud Alibaba 是一套国产开源产品集合，后这对于国内的开发者是非常棒的一件事。阿里的这一举动势必会推动国内微服务技术的发展，因为在没有 Spring Cloud Alibaba 之前，我们的第一选择是 Spring Cloud Netflix，但是它们的文档都是英文的，出问题后排查也比较困难， 在国内并不是有特别多的人精通。Spring Cloud Alibaba 由阿里开源组件和阿里云产品组件两部分组成，其致力于提供微服务一站式解决方案，方便开发者通过 Spring Cloud 编程模型轻松开发微服务应用。</p><p>Spring Cloud Alibaba也是很值得学习的，其组成包括：</p><ol><li>Sentinel：轻量级的流量控制、熔断降级 Java 库</li><li>2.dubbo：Apache Dubbo 是一个基于 Java 的高性能开源 RPC 框架。</li><li>nacos：Nacos 致力于帮助您发现、配置和管理微服务。</li><li>seata：Seata 是一种易于使用，高性能，基于 Java 的开源分布式事务解决方案。</li><li>RocketMQ:阿里巴巴开源的一款高性能、高吞吐量的分布式消息中间件。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微服务-分布式&quot;&gt;&lt;a href=&quot;#微服务-分布式&quot; class=&quot;headerlink&quot; title=&quot;微服务/分布式&quot;&gt;&lt;/a&gt;微服务/分布式&lt;/h2&gt;&lt;p&gt;今天分享一下微服务/分布式常见的面试问题，不过这些问题都是针对应届生的，对于比较senior的求职者</summary>
      
    
    
    
    <category term="面试" scheme="http://jiangbk.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://jiangbk.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="分布式" scheme="http://jiangbk.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
