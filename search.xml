<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>12_Linux安装MySQL</title>
      <link href="2021/02/17/Linux/12-Linux%E5%AE%89%E8%A3%85MySQL/"/>
      <url>2021/02/17/Linux/12-Linux%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="12-Linux安装MySQL"><a href="#12-Linux安装MySQL" class="headerlink" title="12_Linux安装MySQL"></a>12_Linux安装MySQL</h1><blockquote><p>YUM（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。它基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，无须繁琐地一次次下载、安装</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">步骤1: 检测系统是否自带安装mysql</span><br><span class="line">[root@localhost &#x2F;]# yum list installed | grep mysql </span><br><span class="line"></span><br><span class="line">步骤2: 删除系统自带的mysql及其依赖（防止后面安装发生冲突）</span><br><span class="line">[root@localhost &#x2F;]# yum -y remove mysql-libs.x86_64 </span><br><span class="line"></span><br><span class="line">步骤3: 给CentOS添加rpm源，并且选择较新的源,RPM软件包管理器缩写</span><br><span class="line">[root@localhost &#x2F;]# wget --no-check-certificate dev.mysql.com&#x2F;get&#x2F;mysql-community-release-el6-5.noarch.rpm </span><br><span class="line"></span><br><span class="line">步骤4: 安装第一步下载的rpm文件</span><br><span class="line">[root@localhost &#x2F;]# yum install mysql-community-release-el6-5.noarch.rpm 此处需要输入&quot;y&quot; </span><br><span class="line">[root@localhost &#x2F;]# yum repolist enabled | grep mysql &#x2F;&#x2F;列出你所有的yum repo文件 </span><br><span class="line"></span><br><span class="line">步骤5: 使用yum安装mysql</span><br><span class="line">[root@localhost &#x2F;]# yum install mysql-community-server 此处输入3次“y” 安装完毕 </span><br><span class="line"></span><br><span class="line">步骤6: 启动mysql服务</span><br><span class="line">[root@localhost &#x2F;]# service mysqld start </span><br><span class="line"></span><br><span class="line">步骤7: 查看mysql是否自启动,并且设置开启自启动</span><br><span class="line">[root@localhost &#x2F;]# chkconfig --list | grep mysqld </span><br><span class="line">0 1 2 3 4 5 6 代表centOS启动状态</span><br><span class="line">[root@localhost &#x2F;]# chkconfig mysqld on </span><br><span class="line"></span><br><span class="line">步骤8: 修改字符集为UTF-8</span><br><span class="line">[root@localhost &#x2F;]# vim &#x2F;etc&#x2F;my.cnf</span><br><span class="line">在[mysqld]部分添加：</span><br><span class="line">character-set-server&#x3D;utf8 </span><br><span class="line">在文件末尾新增[client]段，并在[client]段添加：</span><br><span class="line">default-character-set&#x3D;utf8 </span><br><span class="line">esc退出编辑</span><br><span class="line">:wq保存退出</span><br><span class="line">修改完成后保存重启服务</span><br><span class="line">[root@localhost &#x2F;]# service mysqld restart </span><br><span class="line"></span><br><span class="line">步骤9: 修改默认配置 </span><br><span class="line">[root@localhost &#x2F;]# mysql_secure_installation </span><br><span class="line">按照提示进行配置，这里默认root用户的密码空，直接回车即可。此处输入内容:&quot;y&quot;,&quot;y&quot;,&quot;n&quot;,&quot;y&quot;,&quot;y&quot; </span><br><span class="line"></span><br><span class="line">步骤10:授权远程登录</span><br><span class="line">方案1:实现远程连接(授权法)- 将权限改为ALL PRIVILEGES</span><br><span class="line">[root@localhost &#x2F;]# mysql -uroot -p</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed </span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">&#x2F;&#x2F;mysql 新设置用户或更改密码后需用flush privileges刷新MySQL的系统权限相关表，否则会出现拒绝访问</span><br><span class="line">mysql&gt; select host,user,password from user; </span><br><span class="line">这样机器就可以以用户名root密码root远程访问该机器上的MySql. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案2:实现远程连接（改表法）</span><br><span class="line">use mysql;</span><br><span class="line">update user set host &#x3D; &#39;%&#39; where user &#x3D; &#39;root&#39;;</span><br><span class="line">fiush privileges </span><br><span class="line">这样在远端就可以通过root用户访问Mysql</span><br></pre></td></tr></table></figure><p>注意在测试时，要关闭防火墙 ~~</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11_Linux 安装 JDK8</title>
      <link href="2021/02/17/Linux/11-Linux-%E5%AE%89%E8%A3%85-JDK8/"/>
      <url>2021/02/17/Linux/11-Linux-%E5%AE%89%E8%A3%85-JDK8/</url>
      
        <content type="html"><![CDATA[<h1 id="11-Linux-安装-JDK8"><a href="#11-Linux-安装-JDK8" class="headerlink" title="11_Linux 安装 JDK8"></a>11_Linux 安装 JDK8</h1><h4 id="1-下载-JDK"><a href="#1-下载-JDK" class="headerlink" title="1.下载 JDK"></a>1.下载 JDK</h4><p>百度云链接：<a href="https://pan.baidu.com/s/1KFCLXSrsVvjYBNweugZv0w">https://pan.baidu.com/s/1KFCLXSrsVvjYBNweugZv0w</a><br>提取码：r3tt</p><h4 id="2-创建保存JDK的文件夹"><a href="#2-创建保存JDK的文件夹" class="headerlink" title="2.创建保存JDK的文件夹"></a>2.创建保存JDK的文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir jdkhome</span><br></pre></td></tr></table></figure><h4 id="3-解压JDK到jdkhome下"><a href="#3-解压JDK到jdkhome下" class="headerlink" title="3.解压JDK到jdkhome下"></a>3.解压JDK到jdkhome下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf jdk-8u11-linux-x64.tar.gz  -C &#x2F;home&#x2F;admin&#x2F;jdkhome</span><br></pre></td></tr></table></figure><h4 id="4-测试JDK是否安装成功"><a href="#4-测试JDK是否安装成功" class="headerlink" title="4.测试JDK是否安装成功"></a>4.测试JDK是否安装成功</h4><p>在JDK安装后的bin目录下运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xj0927 bin]# .&#x2F;java -version</span><br><span class="line">java version &quot;1.8.0_11&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_11-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)</span><br></pre></td></tr></table></figure><p>现在你只能在bin目录下查看JDK，所以还需要配置环境变量</p><h4 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5.配置环境变量"></a>5.配置环境变量</h4><h6 id="1-先切换到root用户-su-root"><a href="#1-先切换到root用户-su-root" class="headerlink" title="(1)先切换到root用户:su root"></a>(1)先切换到root用户:su root</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su root </span><br><span class="line">:输入密码</span><br></pre></td></tr></table></figure><p>(2)修改 profile 文件的操作权限: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +w &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h6 id="3-编辑profile文件"><a href="#3-编辑profile文件" class="headerlink" title="(3)编辑profile文件:"></a>(3)编辑profile文件:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h6 id="4-添加JAVA-HOME变量"><a href="#4-添加JAVA-HOME变量" class="headerlink" title="(4)添加JAVA_HOME变量:"></a>(4)添加JAVA_HOME变量:</h6><p>在文件末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#前面两条语句即可</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;home&#x2F;admin&#x2F;jdkhome&#x2F;jdk1.8.0_11</span><br><span class="line"># $PATH放在后面,覆盖自带的openjdk</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br></pre></td></tr></table></figure><h6 id="5-使环境变量及时生效"><a href="#5-使环境变量及时生效" class="headerlink" title="(5)使环境变量及时生效"></a>(5)使环境变量及时生效</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h6 id="6-查看变量是否更新成功"><a href="#6-查看变量是否更新成功" class="headerlink" title="(6)查看变量是否更新成功:"></a>(6)查看变量是否更新成功:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><h4 id="6-查看JDK"><a href="#6-查看JDK" class="headerlink" title="6.查看JDK"></a>6.查看JDK</h4><h6 id="7-在任意目录下测试环境是否配置成功"><a href="#7-在任意目录下测试环境是否配置成功" class="headerlink" title="(7)在任意目录下测试环境是否配置成功"></a>(7)在任意目录下测试环境是否配置成功</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>admin用户下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 bin]$ java -version</span><br><span class="line">java version &quot;1.8.0_11&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_11-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)</span><br></pre></td></tr></table></figure><p>也可输入java:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 bin]$ java</span><br><span class="line">Usage: java [-options] class [args...]</span><br><span class="line">           (to execute a class)</span><br><span class="line">   or  java [-options] -jar jarfile [args...]</span><br><span class="line">           (to execute a jar file)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>输入javac:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 bin]$ javac</span><br><span class="line">Usage: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">where possible options include:</span><br><span class="line">....</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10_Linux 基本命令</title>
      <link href="2021/02/17/Linux/10-Linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>2021/02/17/Linux/10-Linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="10-Linux-基本命令"><a href="#10-Linux-基本命令" class="headerlink" title="10_Linux 基本命令"></a>10_Linux 基本命令</h1><h2 id="1）目录结构"><a href="#1）目录结构" class="headerlink" title="1）目录结构"></a>1）目录结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184322.png"></p><p>使用命令查看:<code>ll</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184323.png"></p><ul><li>bin 存放二进制可执行文件(ls,cat,mkdir等) </li><li>boot 存放用于<strong>系统引导</strong>时使用的各种文件</li><li>dev 用于存放<strong>设备文件</strong></li><li>etc 存放系统<strong>配置文件</strong></li><li>home 存放所有<strong>用户文件</strong>的根目录 </li><li>lib 存放跟文件系统中的程序运行所需要的共享库及内核模块</li><li>mnt 系统管理员安装<strong>临时文件</strong>系统的安装点</li><li>opt 额外安装的可选应用<strong>程序包所放</strong>置的位置</li><li>usr 用于存放系统应用程序，比较重要的目录**/usr/local 本地管理员软件**安装目录</li></ul><p>需要关注的目录：</p><p>/etc 配置目录–&gt;软件安装后配置文件选择放入的地址。 </p><p>/usr/local软件安装目录</p><p>/opt目录一般用来安装应用程序。部署的API程序一般放在这个目录。 </p><h2 id="2）文件权限"><a href="#2）文件权限" class="headerlink" title="2）文件权限"></a>2）文件权限</h2><p>在linux下每个用户都有不同的权限，普通用户只能在自己的主目录下进行写操作. </p><p>三种基本权限:</p><ul><li>R 读权限</li><li>W 写权限</li><li>X 执行权限 </li></ul><h6 id="1-文件各部分"><a href="#1-文件各部分" class="headerlink" title="/1.文件各部分:"></a>/1.文件各部分:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--. 1 root root 26 Jul 16&#x3D;1 12:02 qf.log</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184239.png"></p><h6 id="2-权限各部分：分为4部分-1-2-4-5-7-8-10"><a href="#2-权限各部分：分为4部分-1-2-4-5-7-8-10" class="headerlink" title="/2.权限各部分：分为4部分(1,2-4,5-7,8-10)"></a>/2.权限各部分：分为4部分(1,2-4,5-7,8-10)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184251.png"></p><h6 id="3-修改权限方式"><a href="#3-修改权限方式" class="headerlink" title="/3.修改权限方式"></a>/3.修改权限方式</h6><p>方式1：字符设置法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：chmod [who][+ | - | &#x3D;] 文件名</span><br><span class="line">who (u 用户user ,g用户组group,o其他用户,a所有用户默认) </span><br><span class="line">操作符号:</span><br><span class="line">+添加某个权限</span><br><span class="line">-取消某个权限</span><br><span class="line">&#x3D;赋予权限</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">修改一个权限</span><br><span class="line">chmod g+w a.txt</span><br><span class="line">chmod u+x,g+w,o+w a.txt </span><br></pre></td></tr></table></figure><p>方式2：数字设定法</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184259.png"></p><ul><li>4表可读权限=r</li><li>2表写入权限=w</li><li>1表可执行=x</li><li>0无权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">举例:</span><br><span class="line">当前的数字权限: </span><br><span class="line">用户权限&#x3D;rwx&#x3D;4+2+1&#x3D;7 </span><br><span class="line">所属组权限&#x3D;r--&#x3D;4+0+0&#x3D;4 </span><br><span class="line">其他用户权限&#x3D;r--&#x3D;4+0+0&#x3D;4 </span><br><span class="line">组合:744</span><br><span class="line"></span><br><span class="line">chmod 744 a.txt</span><br></pre></td></tr></table></figure><h5 id="3-常用指令"><a href="#3-常用指令" class="headerlink" title="3)常用指令"></a>3)常用指令</h5><h6 id="1-查看目录"><a href="#1-查看目录" class="headerlink" title="/1.查看目录"></a>/1.查看目录</h6><ul><li>ls 查看目录内容 </li><li>ll 查看详细信息 </li></ul><h6 id="2-创建目录"><a href="#2-创建目录" class="headerlink" title="/2.创建目录"></a>/2.创建目录</h6><ul><li>mkdir ：创建目录 </li><li>mkdir -p 创建目录以及子目录，多个目录同时创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;a&#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure><h6 id="3-切换目录"><a href="#3-切换目录" class="headerlink" title="/3.切换目录"></a>/3.<strong>切换目录</strong></h6><p>cd 切换目录</p><ul><li>cd .. 要加空格</li><li>cd ../xxx 进入上一级目录的子目录 </li></ul><h6 id="4-创建文件"><a href="#4-创建文件" class="headerlink" title="/4.创建文件"></a>/4.创建文件</h6><ul><li>touch ：创建一个空白的普通文件</li></ul><h6 id="5-写入内容"><a href="#5-写入内容" class="headerlink" title="/5.写入内容"></a>/5.写入内容</h6><p>echo :把内容重定向到指定的文件中 ，有则打开，无则创建 </p><ul><li>覆盖模式(会清除之前的内容)&gt;: echo “ww”&gt;aa.txt  </li><li>追加模式(不会清除之前的内容)&gt;&gt;: echo “ww”&gt;&gt;aa.txt</li></ul><h6 id="6-查看文件内容"><a href="#6-查看文件内容" class="headerlink" title="/6.查看文件内容"></a>/6.查看文件内容</h6><ul><li>cat ：查看文件内容 </li><li>more ：分页查看文件内容，按空格键换页 </li></ul><h6 id="7-复制"><a href="#7-复制" class="headerlink" title="/7.复制"></a>/7.复制</h6><ul><li>cp ：复制 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把a.txt复制到b文件夹下</span><br><span class="line">cp a.txt b</span><br></pre></td></tr></table></figure><h6 id="8-剪切、重命名"><a href="#8-剪切、重命名" class="headerlink" title="/8.剪切、重命名"></a>/8.剪切、重命名</h6><ul><li>mv ：剪切、重命名(剪切的文件 放在同一个目录中是重命名) </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">剪切:</span><br><span class="line">剪切a.txt到b文件夹下</span><br><span class="line">mv a.txt b</span><br><span class="line"></span><br><span class="line">重命名:</span><br><span class="line">将a.txt重命名为b.txt</span><br><span class="line">mv a.txt b.txt</span><br></pre></td></tr></table></figure><h6 id="9-删除"><a href="#9-删除" class="headerlink" title="/9.删除"></a>/9.删除</h6><ul><li>删除文件:rm 文件名</li><li>删除文件夹：rm -r 文件夹名</li><li>rm -fr 直接彻底删除，没有提示。 </li></ul><h6 id="10-统计行数"><a href="#10-统计行数" class="headerlink" title="/10.统计行数"></a>/10.统计行数</h6><ul><li>统计行数 : wc  -l  文件名</li></ul><h6 id="11-查看当前路径"><a href="#11-查看当前路径" class="headerlink" title="/11.查看当前路径"></a>/11.查看当前路径</h6><ul><li>pwd ：查看当前目录的绝对路径</li></ul><h6 id="12-显示主机名"><a href="#12-显示主机名" class="headerlink" title="/12.显示主机名"></a>/12.显示主机名</h6><ul><li>hostname ： 显示主机名 </li></ul><h6 id="13-查看系统信息"><a href="#13-查看系统信息" class="headerlink" title="/13.查看系统信息"></a>/13.查看系统信息</h6><ul><li><p>uname -a ：显示完整的系统信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 test]$ uname -a</span><br><span class="line">Linux xj0927 2.6.32-431.el6.x86_64 #1 SMP Fri Nov 22 03:15:09 UTC 2013 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><h6 id="14-查看进程耗时与占用"><a href="#14-查看进程耗时与占用" class="headerlink" title="/14.查看进程耗时与占用"></a>/14.查看进程耗时与占用</h6></li><li><p> top ：显示当前耗时的进程信息 ,每3秒刷新一次</p></li><li><p>cltr+c: 中断</p><p>top确认cpu和内存的占用情况</p></li></ul><h6 id="15-查看进程快照"><a href="#15-查看进程快照" class="headerlink" title="/15.查看进程快照"></a>/15.查看进程快照</h6><ul><li>ps - axu : 显示当前进程的快照</li><li>ps - axu  | grep java : 显示某個程序当前进程的快照</li></ul><h6 id="16-文件大小"><a href="#16-文件大小" class="headerlink" title="/16.文件大小"></a>/16.文件大小</h6><ul><li>du -sh:  显示文件的大小信息 </li></ul><h6 id="17-磁盘占用情况"><a href="#17-磁盘占用情况" class="headerlink" title="/17.磁盘占用情况"></a>/17.磁盘占用情况</h6><ul><li>df -lh : 磁盘使用情况 </li></ul><h6 id="18-查看网卡情况"><a href="#18-查看网卡情况" class="headerlink" title="/18.查看网卡情况"></a>/18.查看网卡情况</h6><ul><li>ifconfig ：查看或者配置网卡信息(ip addr) </li></ul><h6 id="19-结束进程"><a href="#19-结束进程" class="headerlink" title="/19.结束进程"></a>/19.结束进程</h6><ul><li>kill pid ：杀死进程 ,pid进程编号</li><li>Kill -9 :强制杀死</li></ul><h6 id="20-查看端口号"><a href="#20-查看端口号" class="headerlink" title="/20.查看端口号"></a>/20.查看端口号</h6><ul><li>netstat </li></ul><p>常用参数: </p><p>-a或–all：显示所有连线中的Socket； </p><p>-l或–listening：显示监控中的服务器的Socket； </p><p>-n或–numeric：直接使用ip地址，而不通过域名服务器； </p><p>-p或–programs：显示正在使用Socket的程序识别码和程序名称； </p><p>-t或–tcp：显示TCP传输协议的连线状况； </p><p>简写：netstat -tlnp</p><p>找出运行在指定端口的进程：netstat -tlnp | grep ‘:22’ </p><h6 id="21-压缩文件与解压"><a href="#21-压缩文件与解压" class="headerlink" title="/21.压缩文件与解压"></a>/21.压缩文件与解压</h6><ul><li><p>c ：创建的一个归档文件 </p></li><li><p>x ：拆包 </p></li><li><p>z ：以gzip 格式压缩 j ：以bzip2格式压缩 </p></li><li><p>v ：显示打包或者拆包的文件信息 </p></li><li><p>f ： 后面紧接一个 归档文件 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">压缩指定文件到指定目录下:</span><br><span class="line">tar -czvf 目录/压缩文件名.tar.gz 源文件</span><br><span class="line"></span><br><span class="line">将b1文件夹下的a.txt压缩到b2文件夹下:</span><br><span class="line">tar -czvf b2/b1.tar.gz b1/a.txt</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解压指点文件到指定文件夹下:</span><br><span class="line">tar -xzvf 目录/压缩包名.tar.gz -C 路径/</span><br><span class="line"></span><br><span class="line">将d2目录下的a.tar.gz解压到d1目录下</span><br><span class="line">tar -xzvf d2/a.tar.gz -C /home/admin/test/</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="3）文本编辑器"><a href="#3）文本编辑器" class="headerlink" title="3）文本编辑器"></a>3）文本编辑器</h2><p>一般模式 ，默认方式，该模式不能编辑</p><ul><li><p>按 i（insert） 进入 插入模式</p><p>编辑模式</p></li><li><p>该模式可以编辑文档，按esc 退出插入模式 </p><p>命令模式</p></li><li><p>一般模式中按：进入命令模式[yy复制一行, dd剪切一行,p粘贴] </p></li><li><p>:q 安全退出，当没有操作该文档 </p></li><li><p>:q！修改了内容，但不想保存，强制退出 </p></li><li><p>:wq 保存退出 </p></li><li><p>:set number 显示行号set nonumber 取消行号显示</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9_CentOs 设置防火墙及开放端口</title>
      <link href="2021/02/17/Linux/9-CentOs-%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E5%8F%8A%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/"/>
      <url>2021/02/17/Linux/9-CentOs-%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E5%8F%8A%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="9-CentOs-设置防火墙及开放端口"><a href="#9-CentOs-设置防火墙及开放端口" class="headerlink" title="9_CentOs 设置防火墙及开放端口"></a>9_CentOs 设置防火墙及开放端口</h1><blockquote><p>Linux系统中默认有防火墙 Iptables 管理所有的端口，只启用默认远程连接22端口其他都关闭</p></blockquote><h5 id="1-方案一：修改防火墙配置"><a href="#1-方案一：修改防火墙配置" class="headerlink" title="1)方案一：修改防火墙配置"></a>1)<strong>方案一：修改防火墙配置</strong></h5><p>将开启的端口加入防火墙白名单中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure><p>增加下面代码 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -p tcp -m state -- state NEW -m tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state -- state NEW -m tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure><p>保存退出，重启防火墙 </p><h6 id="重启防火墙："><a href="#重启防火墙：" class="headerlink" title="重启防火墙："></a>重启防火墙：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><h6 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables status</span><br></pre></td></tr></table></figure><h5 id="2-方案二：关闭防火墙"><a href="#2-方案二：关闭防火墙" class="headerlink" title="2)方案二：关闭防火墙"></a>2)<strong>方案二：关闭防火墙</strong></h5><h6 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙 :"></a>关闭防火墙 :</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><h6 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙:"></a>开启防火墙:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables start</span><br></pre></td></tr></table></figure><h6 id="关闭防火墙自动启动"><a href="#关闭防火墙自动启动" class="headerlink" title="关闭防火墙自动启动"></a>关闭防火墙自动启动</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfifig iptables of</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8_CentOs 下安装 Tomcat</title>
      <link href="2021/02/17/Linux/8-CentOs-%E4%B8%8B%E5%AE%89%E8%A3%85-Tomcat/"/>
      <url>2021/02/17/Linux/8-CentOs-%E4%B8%8B%E5%AE%89%E8%A3%85-Tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="8-CentOs-下安装-Tomcat"><a href="#8-CentOs-下安装-Tomcat" class="headerlink" title="8_CentOs 下安装 Tomcat"></a>8_CentOs 下安装 Tomcat</h1><h5 id="1-上传tomcat压缩包"><a href="#1-上传tomcat压缩包" class="headerlink" title="1.上传tomcat压缩包"></a>1.上传tomcat压缩包</h5><p>百度云链接：<a href="https://pan.baidu.com/s/1R2njJS-l8DDwCDhV1sFZJw">https://pan.baidu.com/s/1R2njJS-l8DDwCDhV1sFZJw</a><br>提取码：tscu</p><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf apache-tomcat-8.5.56.tar.gz </span><br></pre></td></tr></table></figure><h5 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h5><p>进入解压包下的bin目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动:</span><br><span class="line">.&#x2F;startup.sh</span><br><span class="line"></span><br><span class="line">关闭:</span><br><span class="line">.&#x2F;shutdown.sh</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7_本地文件上传到Linux</title>
      <link href="2021/02/17/Linux/7-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Linux/"/>
      <url>2021/02/17/Linux/7-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="7-本地文件上传到Linux"><a href="#7-本地文件上传到Linux" class="headerlink" title="7_本地文件上传到Linux"></a>7_本地文件上传到Linux</h1><h4 id="1-SecureFXPortable软件下载"><a href="#1-SecureFXPortable软件下载" class="headerlink" title="1. SecureFXPortable软件下载"></a>1. SecureFXPortable软件下载</h4><p>百度云链接：<a href="https://pan.baidu.com/s/19QHs7QCFCkgRgk1Nq9d2Gw">https://pan.baidu.com/s/19QHs7QCFCkgRgk1Nq9d2Gw</a><br>提取码：01ue</p><h4 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2. 建立连接"></a>2. 建立连接</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183850.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183851.png"></p><h4 id="3-上传"><a href="#3-上传" class="headerlink" title="3)上传"></a>3)上传</h4><p>直接将左侧Windows系统下的压缩包拖拽到右侧即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183852.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6_更改系统语言</title>
      <link href="2021/02/17/Linux/6-%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/"/>
      <url>2021/02/17/Linux/6-%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="6-更改系统语言"><a href="#6-更改系统语言" class="headerlink" title="6_更改系统语言"></a>6_更改系统语言</h1><p>使用root权限进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su root </span><br><span class="line">password:输入密码(密码不可见)</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看当前所有语言环境：</span></span><br><span class="line">locale -a</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看当前系统语言环境：</span></span><br><span class="line">echo $LANG</span><br></pre></td></tr></table></figure><p>编辑i18n配置文件:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;i18n</span><br></pre></td></tr></table></figure><p>进行如下配置并保存退出：esc+ :wq!</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183732.png"></p><p>重启系统后系统文字变成英文简体。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_CentOs 7 连接外网的解决办法</title>
      <link href="2021/02/17/Linux/5-CentOs-7-%E8%BF%9E%E6%8E%A5%E5%A4%96%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>2021/02/17/Linux/5-CentOs-7-%E8%BF%9E%E6%8E%A5%E5%A4%96%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="5-CentOs-7-连接外网的解决办法"><a href="#5-CentOs-7-连接外网的解决办法" class="headerlink" title="5_CentOs 7 连接外网的解决办法"></a>5_CentOs 7 连接外网的解决办法</h1><h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>在新安装 CentOs 7后，想要连接外网，发现不能上网，同时 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p>出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name or service not known</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>网络未配置好 。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="一、选择-VMWare-的-NAT-模式"><a href="#一、选择-VMWare-的-NAT-模式" class="headerlink" title="一、选择 VMWare 的 NAT 模式"></a>一、选择 VMWare 的 NAT 模式</h3><h4 id="1）导航栏“编辑”-gt-“虚拟网络编辑器”-gt-NAT模式-gt-NAT设置"><a href="#1）导航栏“编辑”-gt-“虚拟网络编辑器”-gt-NAT模式-gt-NAT设置" class="headerlink" title="1）导航栏“编辑”-&gt;“虚拟网络编辑器” -&gt;NAT模式-&gt;NAT设置"></a>1）导航栏“编辑”-&gt;“虚拟网络编辑器” -&gt;NAT模式-&gt;NAT设置</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183642.png"></p><p>这一步主要是：记住NAT设置中的子网IP、子网掩码、网关IP三项，接下来配置文件主要是这三项。</p><h4 id="2）编辑网络配置文件"><a href="#2）编辑网络配置文件" class="headerlink" title="2）编辑网络配置文件"></a>2）编辑网络配置文件</h4><p>首先查看自己的网络使用的是哪个配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183643.png"></p><p>也可以使用下面命令查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183644.png"></p><p>然后编辑该文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183645.png"></p><p>保存退出！</p><blockquote><p>如何配置 Linux 的静态 IP，可参考我写的这篇博客</p></blockquote><h4 id="3）重启网络"><a href="#3）重启网络" class="headerlink" title="3）重启网络"></a>3）重启网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h4 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183646.png"></p><p>说明可正常连接外网！！！</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_设置主机名访问任意主机</title>
      <link href="2021/02/17/Linux/4-%E8%AE%BE%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%90%8D%E8%AE%BF%E9%97%AE%E4%BB%BB%E6%84%8F%E4%B8%BB%E6%9C%BA/"/>
      <url>2021/02/17/Linux/4-%E8%AE%BE%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%90%8D%E8%AE%BF%E9%97%AE%E4%BB%BB%E6%84%8F%E4%B8%BB%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="4-设置主机名访问任意主机"><a href="#4-设置主机名访问任意主机" class="headerlink" title="4_设置主机名访问任意主机"></a>4_设置主机名访问任意主机</h1><p>修改之前，只能通过ip进行访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 myfile]$ ping 192.168.77.131</span><br><span class="line">PING 192.168.77.131 (192.168.77.131) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.77.131: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.156 ms</span><br><span class="line">64 bytes from 192.168.77.131: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.127 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="ip与主机名映射"><a href="#ip与主机名映射" class="headerlink" title="ip与主机名映射"></a>ip与主机名映射</h2><h5 id="1-切换root"><a href="#1-切换root" class="headerlink" title="1)切换root"></a>1)切换root</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><h5 id="2-修改文件"><a href="#2-修改文件" class="headerlink" title="2)修改文件"></a>2)修改文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><h5 id="3-修改内容为"><a href="#3-修改内容为" class="headerlink" title="3)修改内容为:"></a>3)修改内容为:</h5><p>此时两个centos的ip和主机名分别为:</p><ul><li>192.168.77.130 xj0927</li><li>192.168.77.131 xj0928</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.77.130 xj0927</span><br><span class="line">192.168.77.131 xj0928</span><br><span class="line"></span><br><span class="line">若有其他ip和主机名也可继续添加...</span><br></pre></td></tr></table></figure><h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4)测试"></a>4)测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 myfile]$ ping xj0928</span><br><span class="line">PING xj0928 (192.168.77.131) 56(84) bytes of data.</span><br><span class="line">64 bytes from xj0928 (192.168.77.131): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;15.4 ms</span><br><span class="line">64 bytes from xj0928 (192.168.77.131): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.207 ms</span><br><span class="line">64 bytes from xj0928 (192.168.77.131): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.202 ms</span><br><span class="line">....</span><br></pre></td></tr></table></figure><hr><h2 id="Linux修改主机名"><a href="#Linux修改主机名" class="headerlink" title="Linux修改主机名"></a>Linux修改主机名</h2><h5 id="1-切换到root用户"><a href="#1-切换到root用户" class="headerlink" title="1)切换到root用户"></a>1)切换到root用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><h5 id="2-修改文件-1"><a href="#2-修改文件-1" class="headerlink" title="2)修改文件"></a>2)修改文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network</span><br></pre></td></tr></table></figure><p>注意:该文件是只读文件，退出时使用:wq退出 </p><h5 id="3-重新连接"><a href="#3-重新连接" class="headerlink" title="3)重新连接"></a>3)重新连接</h5><p>重新连接后显示修改后的服务器名 </p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_CentOs 7修改 IP 地址</title>
      <link href="2021/02/17/Linux/3-CentOs-7%E4%BF%AE%E6%94%B9-IP-%E5%9C%B0%E5%9D%80/"/>
      <url>2021/02/17/Linux/3-CentOs-7%E4%BF%AE%E6%94%B9-IP-%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="3-CentOs-7修改-IP-地址"><a href="#3-CentOs-7修改-IP-地址" class="headerlink" title="3_CentOs 7修改 IP 地址"></a>3_CentOs 7修改 IP 地址</h1><h3 id="问题场景："><a href="#问题场景：" class="headerlink" title="问题场景："></a>问题场景：</h3><p>安装完 CentOs 7 后，使用 ifconfig 查看 ip，没有显示出来，xshell 也就连接不上，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job for network.service failed because the control process exited with error</span><br></pre></td></tr></table></figure><p>此时，我们可以自己去配置静态 IP</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>首先，切换到 root 用户，查看自己需要修改哪个文件,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183404.png"></p><p>然后进入网络配置文件 network-scripts 目录下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</span><br></pre></td></tr></table></figure><p>使用 ls 命令，列出该目录下的文件，其中<strong>“ifcfg-ens33”</strong>的文件，为我们需要修改的网络配置文件。</p><p>使用 <strong>vim 命令</strong>（vi命令也可以）,对文件进行配置，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ifcfg-ens33</span><br></pre></td></tr></table></figure><p>我们需要修改：</p><p><strong>BOOTPROTO=”static</strong>“也就是将 dhcp 改为 static ，</p><p><strong>ONBOOT=”yes”</strong> 意思是将网卡设置为 开机启用，</p><p>同时在最后添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IPADDR&#x3D;192.168.0.230 #静态IP  </span><br><span class="line"></span><br><span class="line">GATEWAY&#x3D;192.168.0.1 #默认网关  </span><br><span class="line"></span><br><span class="line">NETMASK&#x3D;255.255.255.0 #子网掩码  </span><br><span class="line"></span><br><span class="line">DNS1&#x3D;192.168.0.1 #DNS 配置  </span><br><span class="line"></span><br><span class="line">DNS2&#x3D;8.8.8.8     #谷歌地址</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183405.png"></p><p>保存退出！</p><p>重启网络，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><hr><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183406.png"></p><p>如果报错，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job for network.service failed because the control process exited with error code. See &quot;systemctl status network.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure><p>可能是不小心改了一些文件，</p><p>解决办法：</p><p>在 /etc/sysconfig/network-scripts 目录下删除掉别的 ifcfg-xxx(只保留一个你网卡同名的文档)</p><p>再把 NetworkManager 停用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl disable NetworkManager</span><br></pre></td></tr></table></figure><p>保存之后再执行 systemctl restart network 就可以解决了 。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_CentOs 6 修改 IP 地址</title>
      <link href="2021/02/17/Linux/2_CentOs%206%20%E4%BF%AE%E6%94%B9%20IP%20%E5%9C%B0%E5%9D%80/"/>
      <url>2021/02/17/Linux/2_CentOs%206%20%E4%BF%AE%E6%94%B9%20IP%20%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux修改IP地址"><a href="#Linux修改IP地址" class="headerlink" title="Linux修改IP地址"></a>Linux修改IP地址</h1><h5 id="1-切换到root用户"><a href="#1-切换到root用户" class="headerlink" title="1)切换到root用户"></a>1)切换到root用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><h5 id="2-运行setup命令"><a href="#2-运行setup命令" class="headerlink" title="2)运行setup命令"></a>2)运行setup命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup</span><br></pre></td></tr></table></figure><h5 id="3-选择Network-configuration"><a href="#3-选择Network-configuration" class="headerlink" title="3)选择Network configuration"></a>3)选择Network configuration</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216232416.png"></p><h5 id="4-选择Device-configuration"><a href="#4-选择Device-configuration" class="headerlink" title="4)选择Device configuration"></a>4)选择Device configuration</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216232417.png"></p><h5 id="5-选择eth0"><a href="#5-选择eth0" class="headerlink" title="5)选择eth0"></a>5)选择eth0</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216232418.png"></p><h5 id="6-按空格-去掉-进行设置即可"><a href="#6-按空格-去掉-进行设置即可" class="headerlink" title="6)按空格,去掉*,进行设置即可"></a>6)按空格,去掉*,进行设置即可</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216232419.png"></p><h5 id="7-重启网络服务"><a href="#7-重启网络服务" class="headerlink" title="7)重启网络服务"></a>7)重启网络服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h5 id="8-测试"><a href="#8-测试" class="headerlink" title="8)测试:"></a>8)测试:</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看地址是否为修改后的地址</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_Xsell连接Linux</title>
      <link href="2021/02/17/Linux/1_Xsell%E8%BF%9E%E6%8E%A5Linux/"/>
      <url>2021/02/17/Linux/1_Xsell%E8%BF%9E%E6%8E%A5Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Xsell连接Linux"><a href="#Xsell连接Linux" class="headerlink" title="Xsell连接Linux"></a>Xsell连接Linux</h1><blockquote><p>来回切换虚拟机与Windows比较麻烦</p></blockquote><p>此时通过Xshell来连接</p><p><a href="https://pan.baidu.com/s/1yG6YFaSig4y1LcQ89FaV5A">百度云链接：提取码：ie6f </a></p><h5 id="1）查看Linux端口号"><a href="#1）查看Linux端口号" class="headerlink" title="1）查看Linux端口号"></a>1）查看Linux端口号</h5><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231615.png"  /><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231616.png"  /><h5 id="2）打开xshell，输入相关信息，建立连接"><a href="#2）打开xshell，输入相关信息，建立连接" class="headerlink" title="2）打开xshell，输入相关信息，建立连接"></a>2）打开xshell，输入相关信息，建立连接</h5><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231617.png"  /><h5 id="3-输入登录的Linux用户名"><a href="#3-输入登录的Linux用户名" class="headerlink" title="3)输入登录的Linux用户名"></a>3)输入登录的Linux用户名</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231618.png"></p><h5 id="4-输入登录的Linux密码"><a href="#4-输入登录的Linux密码" class="headerlink" title="4)输入登录的Linux密码"></a>4)输入登录的Linux密码</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231619.jpg"></p><h5 id="5-连接成功"><a href="#5-连接成功" class="headerlink" title="5)连接成功"></a>5)连接成功</h5><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231620.png"  /><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Xshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0_在VM虚拟机下安装-Linux</title>
      <link href="2021/02/17/Linux/0_%E5%9C%A8VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E5%AE%89%E8%A3%85-Linux/"/>
      <url>2021/02/17/Linux/0_%E5%9C%A8VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E5%AE%89%E8%A3%85-Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="在-VM-虚拟机下安装-Linux"><a href="#在-VM-虚拟机下安装-Linux" class="headerlink" title="在 VM 虚拟机下安装 Linux"></a>在 VM 虚拟机下安装 Linux</h1><h2 id="VM虚拟机安装"><a href="#VM虚拟机安装" class="headerlink" title="VM虚拟机安装"></a>VM虚拟机安装</h2><p><a href="https://pan.baidu.com/s/1xOLBGDqy2SmSI204AoIj7g">百度云链接：提取码：o6e6</a></p><p>安装完成后…查看是否有这两项</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231011.png"></p><hr><h2 id="安装Linux"><a href="#安装Linux" class="headerlink" title="安装Linux"></a>安装Linux</h2><h5 id="1）-Create-a-New-Virtual-Machine-新建虚拟机"><a href="#1）-Create-a-New-Virtual-Machine-新建虚拟机" class="headerlink" title="1） Create a New Virtual Machine (新建虚拟机)"></a>1） Create a New Virtual Machine (新建虚拟机)</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231012.png"></p><h5 id="2）选择Typical-典型"><a href="#2）选择Typical-典型" class="headerlink" title="2）选择Typical(典型)"></a>2）选择Typical(典型)</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231013.png"></p><h5 id="3）稍后选择-Linux-CentOS安装镜像"><a href="#3）稍后选择-Linux-CentOS安装镜像" class="headerlink" title="3）稍后选择 Linux CentOS安装镜像"></a>3）稍后选择 Linux CentOS安装镜像</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231014.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231015.png"></p><h5 id="4）选择CentOS安装目录"><a href="#4）选择CentOS安装目录" class="headerlink" title="4）选择CentOS安装目录"></a>4）选择CentOS安装目录</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231016.png"></p><h5 id="5）给系统指定最大磁盘空间-不建议小于5G"><a href="#5）给系统指定最大磁盘空间-不建议小于5G" class="headerlink" title="5）给系统指定最大磁盘空间(不建议小于5G)"></a>5）给系统指定最大磁盘空间(不建议小于5G)</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231017.png"></p><h5 id="6）完成"><a href="#6）完成" class="headerlink" title="6）完成"></a>6）完成</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231018.png"></p><h5 id="7）开始Server安装"><a href="#7）开始Server安装" class="headerlink" title="7）开始Server安装"></a>7）开始Server安装</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231019.png"></p><h5 id="8）开启虚拟机"><a href="#8）开启虚拟机" class="headerlink" title="8）开启虚拟机"></a>8）开启虚拟机</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231020.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231021.jpg"></p><h5 id="小插曲："><a href="#小插曲：" class="headerlink" title="小插曲："></a>小插曲：</h5><p>若第一次安装,此时可能出现下列问题</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231022.jpg"></p><p>解决措施:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.重启电脑进入 BIOS，既是按F1 或 F2、或F5、或delete等..不同品牌进入不同。</span><br><span class="line">2.找到菜单 Advanced   进入cpu configuration </span><br><span class="line">3.将 intel virtual technology 设置为 Enable，f10，然后保存退出；</span><br><span class="line">  或者是将SVM Mode 设置为Enable</span><br><span class="line">3.重新打开虚拟机即可。</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231023.png"></p><h5 id="9）设置语言"><a href="#9）设置语言" class="headerlink" title="9）设置语言"></a>9）设置语言</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231024.png"></p><h5 id="10）键盘选择"><a href="#10）键盘选择" class="headerlink" title="10）键盘选择"></a>10）键盘选择</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231025.png"></p><h5 id="11）基本储存设备"><a href="#11）基本储存设备" class="headerlink" title="11）基本储存设备"></a>11）基本储存设备</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231026.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231027.png"></p><h5 id="12）设置主机名"><a href="#12）设置主机名" class="headerlink" title="12）设置主机名"></a>12）设置主机名</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231028.png"></p><h5 id="13）选择时区"><a href="#13）选择时区" class="headerlink" title="13）选择时区"></a>13）选择时区</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231029.png"></p><h5 id="14）设置root账户"><a href="#14）设置root账户" class="headerlink" title="14）设置root账户"></a>14）设置root账户</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231030.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231031.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231032.jpg"></p><h5 id="15）安装中…"><a href="#15）安装中…" class="headerlink" title="15）安装中…"></a>15）安装中…</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231033.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231034.png"></p><h5 id="16）创建普通用户"><a href="#16）创建普通用户" class="headerlink" title="16）创建普通用户"></a>16）创建普通用户</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231035.png"></p><h5 id="17）设置时间"><a href="#17）设置时间" class="headerlink" title="17）设置时间"></a>17）设置时间</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231036.jpg"></p><h5 id="18）登录"><a href="#18）登录" class="headerlink" title="18）登录"></a>18）登录</h5><p>![](0_在 VM 虚拟机下安装 Linux/Linux/images/登录.jpg)</p><h5 id="19）网卡设置-非必须"><a href="#19）网卡设置-非必须" class="headerlink" title="19）网卡设置(非必须)"></a>19）网卡设置(非必须)</h5><p><img src= "/img/loading.gif" data-lazy-src="../../../Typora_%E5%B7%A5%E5%85%B7%E7%B1%BB/Linux/images/%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%A9.jpg"></p><p><strong>nat方式</strong>，每次换网络的情况下，<strong>IP不会变化。</strong>跨网段访问。<br><strong>桥接模式</strong>，每次换网络的情况下，<strong>IP都会变化。优势是和主机一个段，相对更快。</strong></p><p>上面是开发环境，下面是线上环境。 </p><hr><h2 id="克隆Linux"><a href="#克隆Linux" class="headerlink" title="克隆Linux"></a>克隆Linux</h2><p>发现一步一步安装确实挺繁琐的，可以选择直接克隆</p><h5 id="1）克隆"><a href="#1）克隆" class="headerlink" title="1）克隆"></a>1）克隆</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231037.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231038.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231039.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231040.png"></p><h5 id="2）克隆路径"><a href="#2）克隆路径" class="headerlink" title="2）克隆路径"></a>2）克隆路径</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231041.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231042.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231043.png"></p><h5 id="3）完成克隆后多台服务器："><a href="#3）完成克隆后多台服务器：" class="headerlink" title="3）完成克隆后多台服务器："></a>3）完成克隆后多台服务器：</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231044.jpg"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_redis缓存过期淘汰策略</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/4-redis%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/4-redis%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="4-redis缓存过期淘汰策略"><a href="#4-redis缓存过期淘汰策略" class="headerlink" title="4_redis缓存过期淘汰策略"></a>4_redis缓存过期淘汰策略</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>问题1：生产上你们的redis内存设置多少?</p></blockquote><blockquote><p>问题2：如何配置、修改redis的内存大小？</p></blockquote><blockquote><p>问题3：redis清理内存的方式?定期删除和惰性删除了解过吗？</p></blockquote><blockquote><p>问题4：redis缓存淘汰策略？</p></blockquote><blockquote><p>问题5：redis的LRu了解过吗?可否手写一个LRu算法？</p></blockquote><hr><p>redis默认内存多少？在哪里查看? 如何设置修改?</p><h4 id="查看Redis最大占用内存"><a href="#查看Redis最大占用内存" class="headerlink" title="查看Redis最大占用内存"></a>查看Redis最大占用内存</h4><blockquote><p>打开redis配置文件，设置maxmemory参数，maxmemory是bytes字节类型，注意转换。 </p></blockquote><hr><h4 id="redis默认内存多少可以用？"><a href="#redis默认内存多少可以用？" class="headerlink" title="redis默认内存多少可以用？"></a>redis默认内存多少可以用？</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182352.png"></p><hr><h4 id="一般生产上你如何配置？"><a href="#一般生产上你如何配置？" class="headerlink" title="一般生产上你如何配置？"></a>一般生产上你如何配置？</h4><blockquote><p>一般推荐Redis设置内存为最大物理内存的<code>四分之三</code>，也就是0.75</p></blockquote><hr><h4 id="如何修改redis内存设置"><a href="#如何修改redis内存设置" class="headerlink" title="如何修改redis内存设置"></a>如何修改redis内存设置</h4><p>通过修改文件配置：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182353.png"></p><p>通过命令修改：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182354.png"></p><hr><h4 id="什么命令查看redis内存使用情况"><a href="#什么命令查看redis内存使用情况" class="headerlink" title="什么命令查看redis内存使用情况?"></a>什么命令查看redis内存使用情况?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></table></figure><hr><h4 id="真要打满了会怎么样-如果Redis内存使用超出了设置的最大值会怎样"><a href="#真要打满了会怎么样-如果Redis内存使用超出了设置的最大值会怎样" class="headerlink" title="真要打满了会怎么样? 如果Redis内存使用超出了设置的最大值会怎样?"></a>真要打满了会怎么样? 如果Redis内存使用超出了设置的最大值会怎样?</h4><p>改改配置，故意把最大值设为1个byte试试</p><blockquote><p>报<code>OOM</code></p></blockquote><p>设置了maxmemory的选项，假如redis内存使用达到上限</p><p>没有加上过期时间就会导致数据写满maxmemory 为了避免类似情况，引出下一章内存淘汰策略</p><hr><h2 id="redis缓存淘汰策略"><a href="#redis缓存淘汰策略" class="headerlink" title="redis缓存淘汰策略"></a>redis缓存淘汰策略</h2><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p>如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢??如果回答yes，你自己走还是面试官送你?如果不是，那过期后到底什么时候被删除呢?？是个什么操作?</p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><blockquote><p>总结：<code>对CPU不友好</code>，用处理器性能换取存储空间（拿时间换空间）</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182355.png"></p><hr><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><blockquote><p>总结：<code>对memory不友好</code>，用存储空间换取处理器性能（拿空间换时间)</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182356.png"></p><hr><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><blockquote><p>定期<code>抽样key</code>，判断是否过期，但存在漏网之鱼</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182357.png"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182358.png"></p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>种类：(redis6.0.8版本)</p><ul><li>noeviction: 不会驱逐任何key</li><li>allkeys-lru: 对所有key使用LRU算法进行删除</li><li>volatile-lru: 对所有设置了过期时间的key使用LRU算法进行删除</li><li>allkeys-random: 对所有key随机删除</li><li>volatile-random: 对所有设置了过期时间的key随机删除</li><li>volatile-ttl: 删除马上要过期的key</li><li>allkeys-lfu: 对所有key使用LFU算法进行删除</li><li>volatile-lfu: 对所有设置了过期时间的key使用LFU算法进行删除</li></ul><hr><p>2个维度：</p><ul><li>过期键中筛选</li><li>所有键中筛选</li></ul><p>4个方面：</p><ul><li>LRU</li><li>LFU</li><li>random</li><li>ttl</li></ul><p>组成8个选项</p><hr><blockquote><p>你平时用哪一种？</p><p>allkeys-lru: 对所有key使用LRU算法进行删除</p></blockquote><blockquote><p>如何配置、修改？</p><p>方式一：使用配置文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182359.png"></p><hr><p>方式二：使用命令</p><p>config set maxmemory-policy allkeys-lru</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_分布式锁</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3_分布式锁"></a>3_分布式锁</h1><h2 id="分布式锁的面试题"><a href="#分布式锁的面试题" class="headerlink" title="分布式锁的面试题"></a>分布式锁的面试题</h2><blockquote><p>问题1：Redis除了拿来做缓存，你还见过基于Redis的什么用法?</p><p>答：传统五大数据类型的落地应用；做分布式锁</p></blockquote><blockquote><p>问题2：Redis做分布式锁的时候有需要注意的问题?</p></blockquote><blockquote><p>问题3：如果是Redis是单点部署的，会带来什么问题?</p><p>​            那你准备怎么解决单点问题呢?</p></blockquote><blockquote><p>问题4：集群模式下，比如主从模式，有没有什么问题呢?</p></blockquote><blockquote><p>问题5：那你简单的介绍一下Redlock吧?你简历上写redisson，你谈谈</p></blockquote><blockquote><p>问题6：Redis分布式锁如何续期?看门狗知道吗?</p></blockquote><hr><h2 id="Base案例-boot-redis"><a href="#Base案例-boot-redis" class="headerlink" title="Base案例(boot+redis)"></a>Base案例(boot+redis)</h2><blockquote><p>使用场景：<font color='red'>多个服务间保证同一时刻同一时间段内同一用户只能有一个请求(防止关键业务出现并发攻击)</font></p></blockquote><h4 id="1、建Module"><a href="#1、建Module" class="headerlink" title="1、建Module"></a>1、建Module</h4><blockquote><p>两个微服务：boot_redis01、boot_redis02</p></blockquote><h4 id="2、改POM"><a href="#2、改POM" class="headerlink" title="2、改POM"></a>2、改POM</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hhf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>boot_redis01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="3、建YML"><a href="#3、建YML" class="headerlink" title="3、建YML"></a>3、建YML</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">1111</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379 </span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）默认8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">#连接池最大阻塞等待时间（使用负值表示没有限制）默认-1</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接默认8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接默认0</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0 </span></span><br></pre></td></tr></table></figure><hr><h4 id="4、启动类"><a href="#4、启动类" class="headerlink" title="4、启动类"></a>4、启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application01.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="5、config"><a href="#5、config" class="headerlink" title="5、config"></a>5、config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证不是序列化后的乱码配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="6、controller"><a href="#6、controller" class="headerlink" title="6、controller"></a>6、controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h4><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:1111&#x2F;buy_goods</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:2222&#x2F;buy_goods</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182252.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182253.jpg"></p><p>正常访问！</p><hr><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><h3 id="1-单机版没加锁"><a href="#1-单机版没加锁" class="headerlink" title="1.单机版没加锁"></a>1.单机版没加锁</h3><blockquote><p>没有加锁，并发下数字不对，出现<code>超卖现象</code></p></blockquote><p>思考：加synchronized？加ReentrantLock？还是都可以?</p><p>答 ：视业务需求而定。synchronized加锁的话会一直进行阻塞直到获得锁，而ReentrantLock可以使用tryLock()设置获取锁的时间，如果获取不到锁可以中断做其它事情。</p><hr><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p><font color='red'>修改为2.0版本：</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-nginx分布式微服务架构"><a href="#2-nginx分布式微服务架构" class="headerlink" title="2.nginx分布式微服务架构"></a>2.nginx分布式微服务架构</h3><blockquote><p> 分布式部署后，单机锁还是出现超卖现象，需要分布式锁</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182254.png"></p><hr><h4 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h4><p>我这里使用的docker配置Nginx实现负载均衡</p><p>详细参考：<a href="https://blog.csdn.net/XJ0927/article/details/109635711">Dokcer部署Nginx</a> 与 <a href="https://blog.csdn.net/XJ0927/article/details/109501188">Nginx实现负载均衡</a></p><hr><p>下面进行测试</p><p>手动方式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182255.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182256.png"></p><p>可以发现可以轮询访问微服务。</p><hr><p>高并发模拟：模拟2000个线程同时访问微服务</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182257.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182258.png"></p><hr><p>结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182259.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182300.png"></p><p>出现重复消费问题！</p><hr><h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><blockquote><p>上redis分布式锁<code>setnx</code>：Redis具有极高的性能，且其命令对分布式锁支持友好，借助SET命令即可实现加锁处理. </p></blockquote><p>修改为3.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_LOCK_KEY = <span class="string">&quot;lock&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">    Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);<span class="comment">//setnx</span></span><br><span class="line">    <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-程序异常"><a href="#3-程序异常" class="headerlink" title="3.程序异常"></a>3.程序异常</h3><blockquote><p><font color='red'>出异常的话，可能无法释放锁， 必须要在代码层面finally释放锁 </font></p></blockquote><p>加锁解锁，lock/unlock必须同时出现并保证调用</p><h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改为4.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建           </span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);<span class="comment">//setnx   </span></span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-微服务宕机"><a href="#4-微服务宕机" class="headerlink" title="4.微服务宕机"></a>4.微服务宕机</h3><blockquote><p><font color='red'>部署了微服务jar包的机器挂了，代码层面根本没有走到finally这块， 没办法保证解锁，这个key没有被删除，需要加入一个过期时间限定key</font></p></blockquote><h4 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改为5.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建 </span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);<span class="comment">//setnx   </span></span><br><span class="line">        stringRedisTemplate.expire(REDIS_LOCK_KEY, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-过期时间设置不能保证原子性"><a href="#5-过期时间设置不能保证原子性" class="headerlink" title="5.过期时间设置不能保证原子性"></a>5.过期时间设置不能保证原子性</h3><blockquote><p><font color='red'>设置key+过期时间分开了，必须要合并成一行具备原子性</font></p></blockquote><h4 id="解决办法-4"><a href="#解决办法-4" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改为6.0：换重载方法，同时设置过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-误释放锁"><a href="#6-误释放锁" class="headerlink" title="6.误释放锁"></a>6.误释放锁</h3><blockquote><p><font color='red'>张冠李戴，删除了别人的锁</font></p></blockquote><h4 id="解决办法-5"><a href="#解决办法-5" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改为7.0版本：对要删除的锁进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))) &#123;</span><br><span class="line">            stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁    </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-释放锁不是原子性"><a href="#7-释放锁不是原子性" class="headerlink" title="7.释放锁不是原子性"></a>7.释放锁不是原子性</h3><blockquote><p><font color='red'>finally块的判断+del删除操作不是原子性的</font></p></blockquote><h4 id="解决办法1：使用Redis事务"><a href="#解决办法1：使用Redis事务" class="headerlink" title="解决办法1：使用Redis事务"></a>解决办法1：使用Redis事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            stringRedisTemplate.watch(REDIS_LOCK_KEY); <span class="comment">//加事务，乐观锁     </span></span><br><span class="line">            <span class="keyword">if</span> (value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))) &#123;</span><br><span class="line">                stringRedisTemplate.setEnableTransactionSupport(<span class="keyword">true</span>);</span><br><span class="line">                stringRedisTemplate.multi();<span class="comment">//开始事务      </span></span><br><span class="line">                stringRedisTemplate.delete(REDIS_LOCK_KEY);</span><br><span class="line">                List&lt;Object&gt; list = stringRedisTemplate.exec();</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;  <span class="comment">//如果等于null，就是没有删掉，删除失败，再回去while循环那再重新执行删除                     </span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="comment">//如果删除成功，释放监控器，并且break跳出当前循环   </span></span><br><span class="line">            stringRedisTemplate.unwatch();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="解决办法2：使用Lua脚本"><a href="#解决办法2：使用Lua脚本" class="headerlink" title="解决办法2：使用Lua脚本"></a>解决办法2：使用Lua脚本</h4><p>Redis可以通过<code>eval命令</code>保证代码执行的原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">20</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, <span class="string">&quot;ip&quot;</span>, <span class="number">6379</span>, <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jedisPool) &#123;</span><br><span class="line">            <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Jedispool is not ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Jedis jedis = RedisUtils.getJedis();</span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]&quot;</span> + <span class="string">&quot;then &quot;</span> + <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1])&quot;</span> + <span class="string">&quot;else &quot;</span> + <span class="string">&quot;  return 0 &quot;</span> + <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = jedis.eval(script, Collections.singletonList(REDIS_LOCK_KEY), Collections.singletonList(value));</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(result.toString())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------del REDIS_LOCK_KEY success&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------del REDIS_LOCK_KEY error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-redis续期问题"><a href="#8-redis续期问题" class="headerlink" title="8.redis续期问题"></a>8.redis续期问题</h3><blockquote><p><font color='red'>确保redisLock过期时间大于业务执行时间的问题</font></p></blockquote><p>集群+CAP对比zookeeper</p><ul><li>Redis：AP：redis异步复制造成的锁丢失， 比如:主节点没来的及把刚刚set进来这条数据给从节点，就挂了。此时如果集群模式下，就得上Redisson来解决</li><li>Zookeeper：CP</li></ul><hr><h4 id="解决办法-6"><a href="#解决办法-6" class="headerlink" title="解决办法"></a>解决办法</h4><p>redis集群环境下，我们自己写的也不OK, 直接上RedLock之Redisson落地实现</p><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://&quot;</span> + redisHost + <span class="string">&quot;:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);</span><br><span class="line">    redissonLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redissonLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-完善"><a href="#9-完善" class="headerlink" title="9.完善"></a>9.完善</h3><p>可能出现错误：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182301.png"></p><p>是在并发多的时候就可能会遇到这种错误，可能会被重新抢占</p><p>不见得当前这个锁的状态还是在锁定，并且本线程持有</p><h4 id="解决办法-7"><a href="#解决办法-7" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);</span><br><span class="line">    redissonLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//还在持有锁的状态，并且是当前线程持有的锁再解锁   </span></span><br><span class="line">        <span class="keyword">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread()) &#123;</span><br><span class="line">            redissonLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>synchronized  单机版oK，上分布式</p><p>===&gt; nginx分布式微服务 单机锁不行</p><p>===&gt;取消单机锁  上redis分布式锁setnx</p><p>===&gt; 只加了锁，没有释放锁，  出异常的话，可能无法释放锁，必须要在代码层面finally释放锁 </p><p>===&gt; 宕机了，部署了微服务代码层面根本没有走到finally这块，没办法保证解锁，这个key没有被删除，需要有lockKey的过期时间设定</p><p>===&gt; 为redis的分布式锁key，增加过期时间此外，还必须要setnx+过期时间必须同一行的原子性操作 </p><p>===&gt;必须规定只能自己删除自己的锁，你不能把别人的锁删除了,防止张冠李戴，1删2,2删3</p><p>===&gt; lua或者事务 </p><p>===&gt; redis集群环境下，我们自己写的也不OK直接上RedLock之Redisson落地实现</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_redis传统五大基本类型的落地应用</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/2-redis%E4%BC%A0%E7%BB%9F%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%90%BD%E5%9C%B0%E5%BA%94%E7%94%A8/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/2-redis%E4%BC%A0%E7%BB%9F%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%90%BD%E5%9C%B0%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="2-redis传统五大基本类型的落地应用"><a href="#2-redis传统五大基本类型的落地应用" class="headerlink" title="2_redis传统五大基本类型的落地应用"></a>2_redis传统五大基本类型的落地应用</h1><p>官网命令大全网址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.redis.cn&#x2F;commands.html</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182057.png"></p><hr><p>8大类型：</p><ol><li>String(字符类型)</li><li>Hash(散列类型)</li><li>List(列表类型)</li><li>Set(集合类型)</li><li>SortedSet(有序集合类型，简称zset)</li><li>Bitmap(位图)</li><li>HyperLogLog(统计)</li><li>GEO（地理）</li></ol><hr><p><strong>备注：</strong> </p><ul><li><font color='red'>命令不区分大小写，而key是区分大小写的</font></li><li><font color='red'>help @类型名词</font></li></ul><hr><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 最常用</span></span><br><span class="line">set key value</span><br><span class="line">get key</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 同时设置/获取多个键值（m就是more的意思）</span></span><br><span class="line">MSET key value [key value ....]</span><br><span class="line">MGET key [key ....]</span><br></pre></td></tr></table></figure><hr><h4 id="数值增减"><a href="#数值增减" class="headerlink" title="数值增减"></a>数值增减</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 递增数字</span></span><br><span class="line">INCR key</span><br><span class="line"><span class="section"># 增加指定的整数</span></span><br><span class="line">INCRBY key increment</span><br><span class="line"></span><br><span class="line"><span class="section"># 递减数值</span></span><br><span class="line">DECR key</span><br><span class="line"><span class="section"># 减少指定的整数</span></span><br><span class="line">DECRBY key decrement</span><br></pre></td></tr></table></figure><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 获取字符串长度</span></span><br><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><hr><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><font color='red'>分布式锁</font></h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># key不存在时则创建,存在则不创建</span></span><br><span class="line">setnx key value</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># </span></span><br><span class="line">set key value [<span class="string">Ex seconds</span>][<span class="symbol">PX milliseconds</span>][<span class="string">NX|XX</span>]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182058.png"></p><hr><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>商品编号、订单号采用INCR命令生成：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182059.png"></p><p>类似：点赞数+1就使用incr，踩数-1就使用decr</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182100.png"></p><blockquote><p><font color='red'>是否喜欢的文章</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182101.png"></p><hr><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><blockquote><p>对应Java中的结构：<font color='red'>Map&lt;String,Map&lt;Object,object&gt;&gt;</font></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一次设置一个字段值</span></span><br><span class="line">HSET key field value</span><br><span class="line"><span class="section"># 一次获取一个字段值</span></span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一次设置多个字段值</span></span><br><span class="line">HMSET key field value [field value ...]</span><br><span class="line"><span class="section"># 一次获取多个字段值</span></span><br><span class="line">HMGET key field [field ....]</span><br><span class="line"></span><br><span class="line"><span class="section"># 获取所有字段值</span></span><br><span class="line">hgetall key</span><br><span class="line"><span class="section"># 获取某个key内的全部数量</span></span><br><span class="line">hlen key</span><br><span class="line"><span class="section"># 删除某个key的一个字段</span></span><br><span class="line">hdel key field</span><br></pre></td></tr></table></figure><hr><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>购物车早期，当前小中厂可用：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182102.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182103.png"></p><p>实现方案：以用户id作为hash结构中的key，新增商品时使用hset为用户key增加一个字段，字段值就是商品数量，同样如果再增加一件商品，就再添加一个field，而如果对添加的商品进行数量+1就使用hincrby增加相应的数量，需要全选商品时，就使用hgetall，购物车商品的数量显示就使用hlen。</p><hr><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><blockquote><p>其实就是一个双向链表：有序可重复</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 向列表左边添加元素</span></span><br><span class="line">LPUSH key value [value ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 向列表右边添加元素</span></span><br><span class="line">RPUSH key value [value ....]</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看列表</span></span><br><span class="line">LRANGE key start stop</span><br><span class="line"><span class="section"># 获取列表中元素的个数</span></span><br><span class="line">LLEN key</span><br></pre></td></tr></table></figure><hr><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>微信文章订阅公众号：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182104.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182105.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182106.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182107.png"></p><hr><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><blockquote><p>无序不可重复</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 添加元素</span></span><br><span class="line">SADD key member[member ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 删除元素</span></span><br><span class="line">SREM key member [member ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 获取集合中的所有元素</span></span><br><span class="line">SMEMBERS key</span><br><span class="line"></span><br><span class="line"><span class="section"># 判断元素是否在集合中</span></span><br><span class="line">SISMEMBER key member</span><br><span class="line"></span><br><span class="line"><span class="section"># 获取集合中的元素个数</span></span><br><span class="line">SCARD key</span><br></pre></td></tr></table></figure><hr><p>随机取一个元素</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 从集合中随机弹出一个元素，元素不删除</span></span><br><span class="line">SRANDMEMBER key [数字]</span><br><span class="line"></span><br><span class="line"><span class="section"># 从集合中随机弹出一个元素，出一个删一个</span></span><br><span class="line">SPOP key[数字]</span><br></pre></td></tr></table></figure><hr><p>集合运算</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 集合的差集运算A-B：属于A但不属于B的元素构成的集合</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 集合的交集运算A∩B：属于A同时也属于B的共同拥有的元素构成的集合</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 集合的并集运算AUB：属于A或者属于B的元素合并后的集合</span></span><br><span class="line">SUNION key [key ...]</span><br></pre></td></tr></table></figure><hr><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>微信抽奖小程序：</font></p><ul><li><p>1 用户ID，立即参与按钮：sadd key 用户ID</p></li><li><p>2 显示已经有多少人参与了上图23208人参加：SCARD key</p></li><li><p>3 抽奖(从set中任意选取N个中奖人)：</p><p>​     SRANDMEMBER key 2   随机抽奖2个人，元素不删除</p><pre><code> SPOP key3            随机抽奖3个人，元素会删除 </code></pre></li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182108.png"></p><hr><blockquote><p><font color='red'>微信朋友圈点赞：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182109.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182110.png"></p><hr><blockquote><p><font color='red'>微博好友关注社交关系：</font></p></blockquote><p>共同关注的人：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182111.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182112.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182113.png"></p><hr><p>我关注的人也关注他(大家爱好相同)：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182114.png"></p><hr><blockquote><p><font color='red'>QQ内推可能认识的人：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182115.png"></p><hr><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><blockquote><p>向有序集合中加入一个元素和该元素的分数</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 添加元素</span></span><br><span class="line">ZADD key score member [score member ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 按照元素分数从小到大的顺序 返回索引从start到stop之间的所有元素</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="section"># 获取元素的分数</span></span><br><span class="line"> ZSCORE key member</span><br><span class="line"> </span><br><span class="line"> # 删除元素</span><br><span class="line"> ZREM key member [member ...]</span><br><span class="line"> </span><br><span class="line"> # 获取指定分数范围的元素</span><br><span class="line"> ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"> </span><br><span class="line"> # 增加某个元素的分数</span><br><span class="line"> ZINCRBY key increment member</span><br><span class="line"> </span><br><span class="line"> # 获取集合中元素的数量</span><br><span class="line"> ZCARD key</span><br><span class="line"> </span><br><span class="line"> # 获得指定分数范围内的元素个数</span><br><span class="line"> ZCOUNT key min max</span><br><span class="line"> </span><br><span class="line"> # 按照排名范围删除元素</span><br><span class="line"> ZREMRANGEBYRANK key start stop</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取元素的排名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 从小到大</span></span><br><span class="line">ZRANK key member</span><br><span class="line"><span class="section"># 从大到小</span></span><br><span class="line">ZREVRANK key member</span><br></pre></td></tr></table></figure><hr><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>根据商品销售对商品进行排序显示：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182116.png"></p><hr><blockquote><p><font color='red'>抖音热搜：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182117.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182118.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_安装Redis</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/1-%E5%AE%89%E8%A3%85Redis/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/1-%E5%AE%89%E8%A3%85Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装Redis"><a href="#1-安装Redis" class="headerlink" title="1_安装Redis"></a>1_安装Redis</h1><p>官网地址：<a href="https://redis.io/">https://redis.io/</a></p><p>中文官网地址：<a href="http://www.redis.cn/">http://www.redis.cn/</a></p><blockquote><p>说明：安全Bug按照官网提示，升级成为6.0.8</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_AQS</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/3-AQS/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/3-AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="3-AQS"><a href="#3-AQS" class="headerlink" title="3_AQS"></a>3_AQS</h1><p>前置知识:</p><ul><li>公平锁和非公平锁</li><li>可重入锁</li><li>LockSupport</li><li>自旋锁</li><li>数据结构之链表</li><li>设计模式之模板设计模式</li></ul><hr><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>字面意思：抽象的队列同步器</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181731.png"></p><p>源代码：AbstractQueuedSynchronizer 简称为AQS</p><blockquote><p>技术翻译：是用来构建锁或者其它同步器组件<code>的重量级基础框架及整个JUC体系的基石</code>，通过内置的<code>FIFO队列</code>来完成资源获取线程的排队工作，并通过一个<code>int类变量</code>表示持有锁的状态。</p><p>这里的同步器组件指CountDownLatch、Semaphore、ReentrantLock、ReentrantReadWriteLock 等</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181732.png">  </p><p><strong>锁和同步器的关系</strong></p><blockquote><p>锁：面向锁的<code>使用者</code>(定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可)</p><p>同步器：面向锁的<code>实现者</code>(比如Java并发大神Douglee，提出统一规 范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。)</p></blockquote><hr><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><p><font color='red'>加锁会导致阻塞</font>，有阻塞就需要排队，实现排队必然需要有某种形式的队列来进行管理</p><p>抢到资源的线程直接使用办理业务，抢占不到资源的线程的必然涉及一种<code>排队等候机制</code>，抢占资源失败的线程继续去等待(类似办理窗口都满了，暂时没有受理窗口的顾客只能去<code>候客区排队等候</code>)，仍然保留获取锁的可能且获取锁流程仍在继续(候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。</p><p>既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢? </p><p>如果共享资源被占用，<code>就需要一定的阻塞等待唤醒机制来保证锁分配</code>。这个机制主要用的是<strong>CLH队列</strong>的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是<strong>AQS</strong>的抽象表现。它将请求共享资源的线程封装成队列的 <font color='red'>结点(Node)</font>，通过<strong>CAS、自旋以及LockSuport.park()**的方式，维护</strong>state变量**的状态，使并发达到同步的效果。                 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181732.png"></p><hr><h2 id="AQS初识"><a href="#AQS初识" class="headerlink" title="AQS初识"></a>AQS初识</h2><p>官网解释：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181733.png"></p><p>有阻塞就需要排队，实现排队必然需要队列</p><p>AQS使用一个volatile的<code> int类型的成员变量state</code>来表示同步状态，通过内置的<code> FIFO队列</code>来完成资源获取的排队工作将每条要去抢占资源的线程封装成 一个 <font color='red'>Node节点</font> 来实现锁的分配，通过<strong>CAS</strong>完成对<strong>State</strong>值的修改。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181734.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181735.png"></p><hr><h2 id="AQS内部体系架构"><a href="#AQS内部体系架构" class="headerlink" title="AQS内部体系架构"></a>AQS内部体系架构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181736.png"></p><hr><h3 id="AQS自身"><a href="#AQS自身" class="headerlink" title="AQS自身"></a>AQS自身</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181734.png"></p><h4 id="AQS的int变量："><a href="#AQS的int变量：" class="headerlink" title="AQS的int变量："></a>AQS的int变量：</h4><blockquote><p>AQS的同步状态State成员变量</p><p>类比，银行办理业务的受理窗口状态：</p><ul><li>零就是没人，自由状态可以办理</li><li>大于等于1，有人占用窗口，等着去</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The synchronization state.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><hr><h4 id="AQS的CLH队列"><a href="#AQS的CLH队列" class="headerlink" title="AQS的CLH队列"></a>AQS的CLH队列</h4><blockquote><p>CLH队列（三个大牛的名字组成），为一个<code>双向队列</code></p><p>类比，银行侯客区的等待顾客</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181737.png"></p><hr><p>小总结：</p><ul><li><font color='red'>有阻塞就需要排队，实现排队必然需要队列</font></li><li>state变量+CLH双端Node队列</li></ul><hr><h3 id="内部类Node（Node类在AQS类内部）"><a href="#内部类Node（Node类在AQS类内部）" class="headerlink" title="内部类Node（Node类在AQS类内部）"></a>内部类Node（Node类在AQS类内部）</h3><h4 id="Node的int变量"><a href="#Node的int变量" class="headerlink" title="Node的int变量"></a>Node的int变量</h4><blockquote><p>Node的等待状态<code>waitState</code>成员变量（注意与status状态区分，status表示同步状态）</p><p>类比，等候区其它顾客(其它线程)的等待状态</p><p>​         队列中每个排队的个体就是一个Node.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure><hr><h4 id="Node此类的讲解"><a href="#Node此类的讲解" class="headerlink" title="Node此类的讲解"></a>Node此类的讲解</h4><p>内部结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181738.png" alt="17"></p><hr><p>属性说明：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181739.png"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181740.png"></p><hr><h2 id="从我们的ReentrantLock开始解读AQS"><a href="#从我们的ReentrantLock开始解读AQS" class="headerlink" title="从我们的ReentrantLock开始解读AQS"></a>从我们的ReentrantLock开始解读AQS</h2><blockquote><p>Lock接口的实现类，基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock();</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181734.png"></p><h4 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181741.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181742.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181743.png"></p><h4 id="从最简单的lock方法开始看看公平和非公平"><a href="#从最简单的lock方法开始看看公平和非公平" class="headerlink" title="从最简单的lock方法开始看看公平和非公平"></a>从最简单的lock方法开始看看公平和非公平</h4><p>通过ReentrantLock的源码来讲解公平锁和非公平锁 可以明显看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件:<code>hasQueuedPredecessors()</code>，</p><p>hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181744.png"></p><h4 id="非公平锁走起，方法lock"><a href="#非公平锁走起，方法lock" class="headerlink" title="非公平锁走起，方法lock()"></a>非公平锁走起，方法lock()</h4><p>对比公平锁和非公平锁的tryAcqure()方法的实现代码， 其实差别就在于非公平锁获取锁时比公平锁中少了一个判断!hasQueuedPredecessors() </p><p>hasQueuedPredecessors()中判断了是否需要排队，导致公平锁和非公平锁的差异如下: </p><ul><li>公平锁: 公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中;</li><li>非公平锁: 不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程在unpark(), 之后还是需要竞争锁(存在线程竞争的情况下) </li></ul><h4 id="AQS源码深度分析走起"><a href="#AQS源码深度分析走起" class="headerlink" title="AQS源码深度分析走起"></a>AQS源码深度分析走起</h4><p>需要的快捷键：</p><ul><li>ctrl + alt + B：跳到实现类</li><li>ctrl + alt + 左箭头/右箭头：回到上次操作/回到下一次操作</li></ul><p><strong>公平锁：</strong> 从lock()开始，依次跳…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>非公平锁：</strong> 从lock()开始，依次跳…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是公平还是非公平，最终都会走向<code>tryAcquire</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181745.png"></p><hr><blockquote><p>带入一个银行办理业务的案例来模拟我们的AQS如何进行线程的管理和通知唤醒机制 ：</p><p>3个线程模拟3个来银行网点，受理窗口办理业务的顾客</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> Created in 2021-01-25 16:43</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AQSDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//非公平锁</span></span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A顾客就是第一个顾客，此时受理窗口没有任何人，A可以直接去办理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----A thread come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MINUTES.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个顾客，第二个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时B只能等待，</span></span><br><span class="line">        <span class="comment">// 进入候客区</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----B thread come in&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三个顾客，第三个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时C只能等待，</span></span><br><span class="line">        <span class="comment">// 进入候客区</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----C thread come in&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="lock方法分析"><a href="#lock方法分析" class="headerlink" title="lock方法分析"></a>lock方法分析</h5><p>A顾客过来办理业务，由于是非公平方式，走下面这条路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于state的状态确实为0，和CAS预估值一样，CAS操作成功，将state值改为1，同时将Node节点中的线程设置为当前线程A</p><p>初始状态：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181746.png"></p><p>第一个顾客来之后：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181747.png"></p><hr><h5 id="acquire-方法分析"><a href="#acquire-方法分析" class="headerlink" title="acquire()方法分析"></a>acquire()方法分析</h5><p>第二个顾客过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181748.png"></p><p>此时state的状态值为1，代表锁已经被占有，CAS失败，走<code>acquire()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先走<code>tryAcquire()</code>方法，如果成功就返回<code>ture</code>，取反返回<code>false</code>，就不走后面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread(); <span class="comment">//获取当前线程：此时是顾客B</span></span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">//获取state状态，此时值为1</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>下面对这个类中的两个判断进行分别解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况1：顾客B此时走入大厅，发现柜台有人在办理业务，需要去候客区排队，刚准备坐下时，此时顾客A办理完成，就直接去窗口办理：判断当前state状态是否为0，如果为0，进行CAS操作，将state设置为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//附上state+1的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：顾客A办理完，准备起身走时，发现还有件事忘记了办理，又坐下进行办理：判断当前线程是否为线程A，如果是，将state的状态值+1，（<font color='red'>可重入锁的实现</font>）</p><p>总结：这两种情形都是可以获取到锁，即走<code>tryAcquire()</code>方法时返回true</p><hr><h5 id="addWaiter方法分析"><a href="#addWaiter方法分析" class="headerlink" title="addWaiter方法分析"></a>addWaiter方法分析</h5><p>但，此时两种情形都不满足：即返回<code>false</code>，取反为<code>true</code>，继续走后面的方法<code>addWaiter(Node.EXCLUSIVE)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181749.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);  <span class="comment">//当前线程为B，节点为null</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail; <span class="comment">//tail为null</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将tail节点赋给pred节点，此时就为null，不会进入if，走入队方法<code>enq(node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123; <span class="comment">//此时node为B顾客</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>注意：这是一个自旋操作，</font></p><p>tail为空节点，会进入<code>if</code>判断，通过CAS操作设置<code>head</code>头结点的指向Node空节点（此时Node节点即图中的傀儡节点，不储存数据，仅用于占位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123; <span class="comment">//此时传入的update为一个Node空节点</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181750.png"></p><p>然后再将<code>head</code>头结点的执行赋给<code>tail</code>尾结点的指向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail &#x3D; head;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181751.png"></p><p>完成后，不会走下面的else 分支。由于是自旋，继续从头开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;<span class="comment">//此时tail执行空节点，即不为null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;<span class="comment">//将B线程的前指针指向t节点（这里即tail节点）所执行的节点（这里即空节点）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tail</code>不为null，走<code>else</code>分支，</p><p>首先：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.prev &#x3D; t;&#x2F;&#x2F;将B线程的前指针指向空节点</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181752.png"></p><p>然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSetTail(t, node) &#x2F;&#x2F;设置尾结点：将tail尾结点所执向的节点改为执向顾客B</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181753.png"></p><p>然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.next &#x3D; node; &#x2F;&#x2F;将空节点的next指针指向顾客B</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181754.png"></p><p>最后：<code>return</code>结束自旋！</p><hr><p>此时，第三个顾客C，也来办理业务，同样也没有抢到锁，需要走到<code>addWaiter(Node.EXCLUSIVE)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail; <span class="comment">//tail节点执行顾客B</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，tail节点执行顾客B，赋给pred节点，所以pred节点也执行B，即pred不为null，需要进入<code>if</code>判断</p><p>首先：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.prev &#x3D; pred;&#x2F;&#x2F;将顾客C的头指针指向顾客B</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181755.png"></p><p>然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSetTail(pred, node)&#x2F;&#x2F;设置尾结点指向顾客C</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181756.png"></p><p>最后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred.next &#x3D; node;&#x2F;&#x2F;将顾客B的后指针指向顾客C</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181757.png"></p><p>发现没有顾客C没有走<code>enq(node)</code>方法，也就是说此时已有哨兵节点，不需要再去创建哨兵节点进行占位。</p><p>若还有其他顾客D、E….走这条路依然是这样。</p><hr><h5 id="acquireQueued方法分析"><a href="#acquireQueued方法分析" class="headerlink" title="acquireQueued方法分析"></a>acquireQueued方法分析</h5><p>虽然顾客B和顾客C依次都入了队，但是，没有真正的阻塞，下面开始执行<code>acquireQueued()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//此时传入进的node为顾客B</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//先不管这个，这是防止中途打断放弃的设置</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>这里又是一个自旋</font></p><p>首先：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//设置p为哨兵节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//附上源码</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">    Node p = prev;<span class="comment">//prev为头指针，将其指向的节点付给p</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后：<code>p=head</code>相等，进入<code>tryAcquire</code>方法，再次尝试获取锁，假设现在依然抢不到锁，不能继续往下走，进入下一个<code>if</code>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;<span class="comment">//此时pred为哨兵节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//此时为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//-1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//进入此语句</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&#x2F;&#x2F;设置waitStatus为-1</span><br></pre></td></tr></table></figure><p>由于是自旋，再次进入<code>acquireQueued</code>，尝试获取锁，获取失败，同理又进入<code>shouldParkAfterFailedAcquire</code>方法，但此时<code>waitStatus</code>值为1，所以进入下列<code>if</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p><code>shouldParkAfterFailedAcquire</code>返回为<code>true</code>，继续向下执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时：真正被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>这个时候，才调用<code>park()</code>方法，将线程进行阻塞！！！</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181758.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181759.png"></p><p>顾客C同理，都被阻塞在这里，直到拿到许可证，才可被依次放行</p><hr><h5 id="unlock-方法"><a href="#unlock-方法" class="headerlink" title="unlock()方法"></a>unlock()方法</h5><p>此时顾客A办理完业务，准备释放锁，走到<code>tryRelease</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;<span class="comment">//此时c就为0</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">//将当前拥有锁的线程设置为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">//同时设置state值为0</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>true</code>，进入<code>release</code>方法的if语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;<span class="comment">//将头节点赋给h</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)<span class="comment">//h的waitStarus状态值为-1</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>unparkSuccessor(h)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;  <span class="comment">//此时为-1</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">//进入，通过CAS操作将状态设置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">//upark唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181800.png"></p><hr><p>此时，顾客B和顾客C正挂起阻塞着，这里unpark后，相当于给了一张许可证</p><p><font color='red'>顾客B来个回马枪！！！</font></p><p>顾客B再次来到这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//顾客B</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试获取锁<code>tryAcquire</code>,来到<code>nonfairTryAcquire</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时state的状态值为0，顾客B进入<code>if</code>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将锁的线程设置当前线程B，返回<code>true</code></p><hr><p>即进入下列<code>if</code>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    failed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setHead(node);<span class="comment">//设置头节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//附上源码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node; <span class="comment">//将头节点指向顾客B</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">//将顾客B的线程设置为null</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;<span class="comment">//前指针设置为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181801.png"></p><p>然后：<font color='red'>将哨兵节点的后指针设置为null，此时哨兵节点等待垃圾回收</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181802.png"></p><p>此时原顾客B节点就成为新的哨兵节点</p><p>同理，顾客C出队也是如此操作！！！</p><hr><h2 id="AQS考点"><a href="#AQS考点" class="headerlink" title="AQS考点"></a>AQS考点</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 第一个考点我相信你应该看过源码了，那么AQS里面有个变量叫State，它的值有几种？</span></span><br><span class="line"></span><br><span class="line">答 3个状态：没占用是0，占用了是1，大于1是可重入锁</span><br><span class="line"></span><br><span class="line"><span class="section"># 第二个考点 如果AB两个线程进来了以后，请问这个总共有多少个Node节点？</span></span><br><span class="line">答案是3个</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> AQS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_LockSupport</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/2-LockSupport/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/2-LockSupport/</url>
      
        <content type="html"><![CDATA[<h1 id="2-LockSupport"><a href="#2-LockSupport" class="headerlink" title="2_LockSupport"></a>2_LockSupport</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>官方解释：LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><p>一句话：LockSupport中的park()和unpark()的作用分别是<code>阻塞线程</code>和<code>解除阻塞线程</code></p></blockquote><hr><h2 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h2><p>线程等待唤醒机制(wait/notify)</p><h4 id="3种让线程等待和唤醒的方法"><a href="#3种让线程等待和唤醒的方法" class="headerlink" title="3种让线程等待和唤醒的方法"></a>3种让线程等待和唤醒的方法</h4><h5 id="方式1-使用synchronized"><a href="#方式1-使用synchronized" class="headerlink" title="方式1:  使用synchronized"></a>方式1:  使用synchronized</h5><blockquote><p>使用Object中的<code>wait()</code>方法让线程等待， 使用Object中的<code>notify()</code>方法唤醒线程</p></blockquote><p>正常情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedWaitNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo.synchronizedWaitNotify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181558.png"></p><hr><p>异常情况1：wait方法和notify方法，两个都去掉同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedWaitNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            synchronized (objectLock) &#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            synchronized (objectLock) &#123;</span></span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo.synchronizedWaitNotify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181559.png"></p><p>抛出异常！</p><blockquote><p>原因：synchronized是关键字属于JVM层面。monitorenter(底层是通过monitor对象来完成,其实wait/notify等方法也依赖monitor对象只能在同步块或方法中才能调用wait/notify等方法)</p></blockquote><hr><p>异常情况2：将notify放在wait方法前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181600.png"></p><p>B线程先notify后，A线程后使用wait会出现另一个线程一直处于等待状态</p><hr><p><strong>小总结</strong></p><ul><li>wait和notify方法必须要在同步块或者方法里面且成对出现使用</li><li>先wait后notify才OK</li></ul><hr><h5 id="方式2：使用-lock"><a href="#方式2：使用-lock" class="headerlink" title="方式2：使用 lock"></a>方式2：使用 lock</h5><blockquote><p>Condition接口中的<code>await</code>后<code>signal</code>方法实现线程的等待和唤醒</p></blockquote><p>正常情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//唤醒</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181601.png"></p><hr><p>异常情况1：不进行lock加锁、放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                lock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                lock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181602.png"></p><p>同样也抛出异常！</p><hr><p>异常情况2：先unlock释放锁，再lock加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//TODO 一直卡在这里等待被唤醒</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181603.png"></p><p>B线程先进行释放锁，A线程再加锁，线程一直处于等待状态！</p><hr><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>传统的synchronized和Lock实现等待唤醒通知的约束</p><p>必须满足下列条件：</p><ul><li>线程先要获得并持有锁，必须在锁块（synchronized或lock）中</li><li>必须要先等待后唤醒，线程才能够被唤醒</li></ul></blockquote><hr><h5 id="方式3：使用LockSupport"><a href="#方式3：使用LockSupport" class="headerlink" title="方式3：使用LockSupport"></a>方式3：使用LockSupport</h5><blockquote><p>LockSupport类中的<code>park</code>等待和<code>unpark</code>唤醒</p></blockquote><h6 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h6><blockquote><p>通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作</p></blockquote><p>官网解释：LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><p>LockSupport类使用了一种名为Permit(许可）的概念来做到阻塞和唤醒线程的功能，<code>每个线程都有一个许可(permit)</code>,permit只有两个值1和零，默认是零。可以把许可看成是一种(0,1)信号量(Semaphore），但与Semaphore不同的是，许可的累加上限是1。 </p><hr><h6 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h6><p>阻塞：park()/park(Object blocker)：阻塞当前线程/阻塞传入的具体线程</p><p>permit默认是0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时,park方法会被唤醒，然后会将permit再次设置为0并返回。 </p><p>唤醒：unpark(Thread thread)：唤醒处于阻断状态的指定线程</p><p>调用unpark(thread)方法后，就会将thread线程的许可permit设置成1(注意多次调用unpark方法，不会累加，permit值还是1)会自动唤醒thread线程，即之前阻塞中的LockSupport.park()方法会立即返回。</p><hr><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>正常情况：无锁块要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockSupport：俗称 锁中断</span></span><br><span class="line"><span class="comment"> * 以前的两种方式：</span></span><br><span class="line"><span class="comment"> * 1.以前的等待唤醒通知机制必须synchronized里面有一个wait和notify</span></span><br><span class="line"><span class="comment"> * 2.lock里面有await和signal</span></span><br><span class="line"><span class="comment"> * 这上面这两个都必须要持有锁才能干</span></span><br><span class="line"><span class="comment"> * LockSupport它的解决的痛点</span></span><br><span class="line"><span class="comment"> * 1.LockSupport不用持有锁块，不用加锁，程序性能好，</span></span><br><span class="line"><span class="comment"> * 2.先后顺序，不容易导致卡死</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;come  in....&quot;</span>);</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程...等待被放行</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待3s，让t2线程发放许可证</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181604.png"></p><hr><p>之前错误的先唤醒后等待，LockSupport照样支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;come  in....&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程...等待被放行</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒....&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181605.png"></p><p>发现t1线程并没有进入执行lock方法（此时它已有许可证）</p><hr><h6 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h6><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根结底，LockSupport调用的Unsafe中的<code>native代码</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockSupport提供park()和unpark()方法实现<code>阻塞线程</code>和<code>解除线程阻塞</code>的过程：</p><ul><li>LockSupport和每个使用它的线程都有一个许可(permit)关联。permit相当于1，0的开关，默认是0。</li><li>调用一次unpark就加1变成1，<code>调用一次park会消费permit，也就是将1变成0</code>，同时park立即返回。</li><li>如再次调用park会变成阻塞(因为permit为零了会阻塞在这里，一直到permit变为1)，这时调用unpark会把permit置为1。</li><li>每个线程都有一个相关的permit, <code>permit最多只有一个</code>，重复调用unpark也不会积累凭证。</li></ul><p>形象的理解：</p><ul><li>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。</li><li>当调用park方法时 ，如果有凭证，则会直接消耗掉这个凭证然后正常退出;  如果无凭证，就必须阻塞等待凭证可用;</li><li>而unpark则相反，它会增加一个凭证，但凭证最多只能有1个，累加无效。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;come  in....&quot;</span>);</span><br><span class="line">            <span class="comment">//消耗一张凭证</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="comment">//TODO 没有凭证,继续等待.....</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO 发放凭证：最多为1</span></span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            </span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181606.png"></p><p>此时虽然unpark了两次，但是permit许可证最多为1，所以第一次park消费掉凭证，第二次park时，许可证为0，阻塞等待。</p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 面试题</span></span><br><span class="line"><span class="section"># 为什么可以先唤醒线程后阻塞线程?</span></span><br><span class="line">因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。</span><br><span class="line"></span><br><span class="line"><span class="section"># 为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</span></span><br><span class="line">因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证;而调用两次park却需要消费两个凭证，证不够，不能放行。</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> AQS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LockSupport </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_可重入锁</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="1_可重入锁"></a>1_可重入锁</h1><blockquote><p><strong>可重入锁：</strong> 又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提：<code>锁对象得是同一个对象</code>)，不会因为之前已经获取过还没释放而阻塞。</p><p>Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p></blockquote><p>类似于家里面的大门,进入之后可以进入厕所、厨房等</p><hr><p>“可重入锁”这四个字分开来解释:</p><ul><li>可：可以。</li><li>重：再次。</li><li>入：进入</li><li>锁：同步锁</li><li>进入什么：进入同步域（即同步代码块/方法或显式锁锁定的代码）</li></ul><blockquote><p>一句话：一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁</p></blockquote><hr><h2 id="可重入锁种类"><a href="#可重入锁种类" class="headerlink" title="可重入锁种类"></a>可重入锁种类</h2><h3 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h3><blockquote><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁</p></blockquote><p>同步块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 可重入锁:可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。</span></span><br><span class="line"><span class="comment"> * 在一个synchronized修饰的方法或代码块的内部</span></span><br><span class="line"><span class="comment"> * 调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 10:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">static</span> Object objectLockA = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLockA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------外层调用&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectLockA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------中层调用&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (objectLockA) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------内层调用&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181425.png"></p><hr><p>同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 10:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLock2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====外层&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====中层&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====内层&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReEnterLock2().m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181426.png"></p><hr><h4 id="Synchronized的重入的实现机理"><a href="#Synchronized的重入的实现机理" class="headerlink" title="Synchronized的重入的实现机理"></a>Synchronized的重入的实现机理</h4><blockquote><p>每个锁对象拥有一个<code>锁计数器</code>和一个指向<code>持有该锁的线程</code>的指针</p></blockquote><p>当执行<code>monitorenter</code>时,如果目标锁对象的计数器为零,那么说明它没有被其他线程持有,Java虚拟机会将该锁对象</p><p>的持有线程设置为当前线程,并且将其计数器加1,否则需要等待,直至持有线程释放该锁</p><p>当执行<code>monitorexit</code>时,Java虚拟机则锁对象的计数器减1。计数器为零代表锁已经被释放</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181427.png"></p><p>说明：第一个<code>monitorexit</code>是在方法执行完成时使用，第二个<code>monitorexit</code>是在发生异常时，能够保证锁的自动释放。</p><hr><h3 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h3><blockquote><p>显式锁（即Lock）也有ReentrantLock这样的可重入锁。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 10:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLock3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=======外层&quot;</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;=======内层&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181428.png"></p><p>发现，同一个线程可以再次获取、释放同一把锁。</p><hr><p>那如果现在加锁释放锁的次数不匹配：加锁两次，释放一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 10:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLock3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//加锁两次</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=======外层&quot;</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;=======内层&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//只释放一次</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 thread----外层调用lock&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181429.png"></p><p>由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。</p><p><font color='orange'>正常情况，加锁几次就要解锁几次</font></p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> AQS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可重入锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github学习</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Github%20%E5%AD%A6%E4%B9%A0/Github%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Github%20%E5%AD%A6%E4%B9%A0/Github%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Github学习"><a href="#Github学习" class="headerlink" title="Github学习"></a>Github学习</h1><p>​    使用 Github 优秀框架 + 源码 提升自己</p><h2 id="常用词含义"><a href="#常用词含义" class="headerlink" title="常用词含义"></a>常用词含义</h2><ul><li>watch：会持续收到该项目的动态</li><li>fork：复制某个仓库到自己的 Github 仓库中</li><li>star：可以理解为点赞</li><li>clone：将项目下载至本地 [ git clone xxxx]</li><li>follow：关注你感兴趣的作者，会收到他们的动态</li></ul><hr><h2 id="in-关键字限制搜索范围"><a href="#in-关键字限制搜索范围" class="headerlink" title="in 关键字限制搜索范围"></a>in 关键字限制搜索范围</h2><p><strong>公式：</strong><code>XXX关键字 in:name 或 description 或 readme</code></p><ul><li>xxx in:name [ 项目名称 ] 含有XXX的</li><li>xxx in:description [ 项目描述 ] 含有XXX的</li><li>xxx in:readme [ 项目的readme文件 ] 中包含XXX的</li><li>组合使用<ul><li>xxx in:name,readme 项目的名称和 readme 中包含 xxx 的</li></ul></li></ul><hr><h2 id="stars-或-fork-数量关键字查找"><a href="#stars-或-fork-数量关键字查找" class="headerlink" title="stars 或 fork 数量关键字查找"></a>stars 或 fork 数量关键字查找</h2><p><strong>公式：</strong></p><ul><li><code>xxx关键字 stars 通配符</code> :&gt; 或者 :&gt;=</li><li>区间范围数字： <code>stars:数字1..数字2</code></li></ul><p><strong>案例:</strong></p><ul><li><p>查找 stars 数大于等于 5000 的 Springboot 项目：springboot stars:&gt;=5000</p></li><li><p>查找 forks 数在 1000~2000 之间的 springboot 项目：springboot forks:1000..5000</p></li><li><p>组合使用</p><ul><li>查找 star 大于1000，fork 数在 500 到 1000：<code>springboot stars:&gt;1000 forks:500..1000</code></li></ul></li></ul><hr><h2 id="awesome-加强搜索"><a href="#awesome-加强搜索" class="headerlink" title="awesome 加强搜索"></a>awesome 加强搜索</h2><p><strong>公式：</strong> <code>awesome 关键字</code>：</p><p>awesome 系列，一般用来收集 [ 学习、工具、书籍类相关的项目 ]</p><ul><li>搜索优秀的 redis 相关的项目，包括框架，教程等 awesome redis</li></ul><hr><h2 id="高亮显示某行代码"><a href="#高亮显示某行代码" class="headerlink" title="高亮显示某行代码"></a>高亮显示某行代码</h2><ul><li>一行：地址后面紧跟 #L10<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13</code></li></ul></li><li>多行：地址后面紧跟 #Lx - #Ln<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13-L30</code></li></ul></li></ul><hr><h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><ul><li>使用英文字母 <code>t</code> ,开启项目内搜索</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217142128.png"></p><hr><h2 id="搜索某个地区内的大佬"><a href="#搜索某个地区内的大佬" class="headerlink" title="搜索某个地区内的大佬"></a>搜索某个地区内的大佬</h2><ul><li>location：地区</li><li>language：语言</li><li>例如：<code>location:beijing language:java</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11_死锁编码及快速定位</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/11-%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/11-%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="11-死锁编码及快速定位"><a href="#11-死锁编码及快速定位" class="headerlink" title="11_死锁编码及快速定位"></a>11_死锁编码及快速定位</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141338.png"></p><h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><ul><li>系统资源不足</li><li>进程运行推进的顺序不对</li><li>资源分配不当</li></ul><h2 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h2><ul><li>互斥<ul><li>解决方法：把互斥的共享资源封装成可同时访问</li></ul></li><li>占有且等待<ul><li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li></ul></li><li>非抢占式<ul><li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li></ul></li><li>循环等待<ul><li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li></ul></li></ul><h2 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************** 资源类 **************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有锁：&quot;</span> + lockA);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 等待获取锁&quot;</span> + lockB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 已获得锁&quot;</span> + lockB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************** 测试类 ****************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA,lockB),<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB,lockA),<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，main线程无法结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t2 自己持有锁：lockB</span><br><span class="line">t1 自己持有锁：lockA</span><br><span class="line">t1 等待获取锁lockB</span><br><span class="line">t2 等待获取锁lockA</span><br></pre></td></tr></table></figure><hr><h2 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用 jps 命令查看运行的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141339.png"></p><p>在使用 jstack 查看堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack  7560   # 后面参数是 jps输出的该类的pid</span><br></pre></td></tr></table></figure><p>得到的结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141340.png"></p><p>通过查看最后一行，我们看到 Found 1 deadlock，即存在一个死锁</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10_线程池</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/10-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/10-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10_线程池"></a>10_线程池</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现 Callable 接口</p><ul><li>实现 Runnable 接口</li><li>实现 Callable 接口</li><li>实例化 Thread 类</li><li>使用 线程池 获取</li></ul><hr><h2 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h2><blockquote><p>Callable 接口，是一种让线程执行完成后，<code>[ 能够返回结果的 ]</code></p></blockquote><p>在说到 Callable 接口的时候，我们不得不提到 Runnable 接口 [  两种写法 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 实现Runnable接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***** 实现 Runnable 接口*******&#x2F;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(&quot;线程方法体&quot;);</span><br><span class="line">&#125;,&quot;t1&quot;).start();</span><br></pre></td></tr></table></figure><p>实现 Runnable 接口的时候，需要重写 run 方法，也就是线程在启动的时候，会自动调用的方法</p><hr><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>同理，我们实现 Callable 接口，也需要实现 call 方法，但是这个时候我们还需要有返回值，<font color='red'>这个Callable 接口的应用场景一般就在于批处理业务，比如 [ 转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败 ]</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Callable有返回值</span><br><span class="line"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyThread2 implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;come in Callable&quot;);</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要做的就是通过 Thread 线程， 将 MyThread2 实现 Callable 接口的类包装起来</p><hr><p>这里需要用到的是 FutureTask 类，他实现了 Runnable 接口，并且还需要传递一个实现 Callable 接口的类作为构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span><br><span class="line">&#x2F;&#x2F; 这里通过了FutureTask接触了Callable接口</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br></pre></td></tr></table></figure><p>然后在用 Thread 进行实例化，传入实现 Runnabnle 接口的 FutureTask 的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 &#x3D; new Thread(futureTask, &quot;aaa&quot;);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>最后通过 utureTask.get() 获取到返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出FutureTask的返回值</span><br><span class="line">System.out.println(&quot;result FutureTask &quot; + futureTask.get());</span><br></pre></td></tr></table></figure><hr><p>这就相当于原来我们的方式是 main 方法一条龙之心，后面在引入 Callable 后，对于执行比较久的线程，可以单独新开一个线程进行执行，最后在进行汇总输出</p><p>最后需要注意的是： 最后获得 Callable 线程的计算结果，如果没有计算完成就要去强求获得，会导致阻塞，直到计算完成</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141226.png"></p><p>就是说： <font color='red'>[  futureTask.get() 需要放在最后执行，这样不会导致主线程阻塞  ]</font></p><hr><p>也可以使用下面算法，使用类似于 [ 自旋锁 ] 的方式来进行判断是否运行完毕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断futureTask是否计算完成</span><br><span class="line">while(!futureTask.isDone()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result FutureTask &quot; + futureTask.get());</span><br></pre></td></tr></table></figure><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个 FutureTask 的时候，只会计算一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启两个线程计算futureTask</span><br><span class="line">new Thread(futureTask, &quot;AAA&quot;).start();</span><br><span class="line">new Thread(futureTask, &quot;BBB&quot;).start();</span><br></pre></td></tr></table></figure><p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要定义两个 futureTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask2 &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启两个线程计算futureTask</span><br><span class="line">new Thread(futureTask, &quot;AAA&quot;).start();</span><br><span class="line"></span><br><span class="line">new Thread(futureTask2, &quot;BBB&quot;).start();</span><br></pre></td></tr></table></figure><hr><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：[ 线程复用、控制最大并发数、管理线程 ]</p><p>线程池中的任务是放入到阻塞队列中的</p><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>多核处理的好处是：[ 省略的上下文的切换开销 ]</p><p>原来我们实例化对象的时候，是使用 new 关键字进行创建，到了 Spring 后，我们学了 IOC 依赖注入，发现Spring 帮我们将对象已经加载到了 Spring 容器中，只需要通过 @Autowrite 注解，就能够自动注入，从而使用</p><p>因此使用多线程有下列的好处</p><ul><li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就立即执行</li><li>提高线程的可管理性。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java 中线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor 这几个类。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141227.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141228.png"></p><hr><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul><li>Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池<ul><li>执行长期的任务，性能好很多</li><li>创建一个 [ 定长线程池 ]，可控制线程数最大并发数，超出的线程会在队列中等待</li></ul></li><li>Executors.newSingleThreadExecutor：创建一个只有 1 个线程的 [ 单线程池 ]<ul><li>一个任务一个任务执行的场景</li><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul></li><li>Executors.newCacheThreadPool(); 创建一个 [ 可扩容的线程池 ]<ul><li>执行很多短期异步的小程序或者负载教轻的服务器</li><li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li></ul></li><li>Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li></ul><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>首先我们需要使用  [ Executors 工具类 ]，进行创建线程池，这里创建了一个拥有 5 个线程的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一池5个处理线程 [ 用池化技术，一定要记得关闭 ]</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个只有一个线程的线程池</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newCacheThreadPool();</span><br></pre></td></tr></table></figure><p>然后我们执行下面的的应用场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br></pre></td></tr></table></figure><p>我们需要使用 [ threadPool.execute  ] 执行业务，execute 需要传入一个实现了 Runnable 接口的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t 给用户办理业务&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们使用完毕后关闭线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Array  Arrays(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Collection Collections(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Executor Executors(辅助工具类)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-5 给用户:4 办理业务</span><br><span class="line">pool-1-thread-1 给用户:5 办理业务</span><br><span class="line">pool-1-thread-4 给用户:3 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-3 给用户:2 办理业务</span><br><span class="line">pool-1-thread-2 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:8 办理业务</span><br><span class="line">pool-1-thread-1 给用户:7 办理业务</span><br><span class="line">pool-1-thread-5 给用户:6 办理业务</span><br></pre></td></tr></table></figure><p>我们能够看到，一共有 5 个线程，在给 10 个用户办理业务</p><hr><h5 id="创建周期性执行任务的线程池"><a href="#创建周期性执行任务的线程池" class="headerlink" title="创建周期性执行任务的线程池"></a>创建周期性执行任务的线程池</h5><p>Executors.newScheduledThreadPool(int corePoolSize)：</p><p><strong>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</strong></p><p>底层使用 ScheduledThreadPoolExecutor 来实现 ScheduledThreadPoolExecutor 为ThreadPoolExecutor子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* delay：延时执行任务的时间</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                     long delay,</span><br><span class="line">                                     TimeUnit unit)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws IllegalArgumentException   &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* initialDelay 第一次执行任务延迟时间</span><br><span class="line">* period 连续执行任务之间的周期，从上一个任务开始执行时计算延迟多少开始执行下一个任务，但是还会等上一个任务结束之后。</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                long initialDelay,</span><br><span class="line">                                                long period,</span><br><span class="line">                                                TimeUnit unit)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws IllegalArgumentException   &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* initialDelay 第一次执行任务延迟时间</span><br><span class="line">* delay：连续执行任务之间的周期，从上一个任务全部执行完成时计算延迟多少开始执行下一个任务</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                   long initialDelay,</span><br><span class="line">                                                   long delay,</span><br><span class="line">                                                   TimeUnit unit)</span><br></pre></td></tr></table></figure><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>我们通过查看源码，点击了 Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool 能够发现底层都是使用了 ThreadPoolExecutor</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141229.png"></p><p>我们可以看到线程池的内部，还使用到了 LinkedBlockingQueue 链表阻塞队列</p><p>同时在查看 Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue 阻塞队列</p><p>最后查看一下，完整的三个创建线程的方法</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141230.png"></p><h4 id="线程池的重要参数"><a href="#线程池的重要参数" class="headerlink" title="线程池的重要参数"></a>线程池的重要参数</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141231.png"></p><p>线程池在创建的时候，一共有7大参数</p><ul><li>corePoolSize：[ 核心线程数 ]，线程池中的常驻核心线程数<ul><li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li><li>当线程池中的线程数目达到 corePoolSize 后，就会把到达的队列放到缓存队列中</li></ul></li><li>maximumPoolSize：线程池能够容纳同时执行的 [ 最大线程数 ]，此值必须大于等于1、<ul><li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li></ul></li><li>keepAliveTime：多余的 [ 空闲线程存活时间 ]<ul><li>当线程池数量超过 corePoolSiz e时，当空闲时间达到 keepAliveTime 值时，多余的空闲线程会被销毁，直到只剩下 corePoolSize 个线程为止</li><li>默认情况下，只有当线程池中的线程数大于 corePoolSize 时，keepAliveTime 才会起作用</li></ul></li><li>unit：keepAliveTime 的单位</li><li>workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）<ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul></li><li>threadFactory：表示生成线程池中工作线程的 [ 线程工厂  ]，用于创建线程池 一般用默认即可</li><li>handler：[ 拒绝策略 ] ，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的 Runnable 的策略</li></ul><p>今日值班窗口有 2 个，现在 2 个窗口都有人在办理业余，此时又进来 3 个客人需要办理业务，他们就需要去等待区 [ 阻塞队列 ]等待</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141232.png"></p><p>此时，又进来 3 个客人需要办理业务，但当值窗口已满，等待区已满，就需要 加班窗口 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141233.png"></p><p>今天 人特别多，不知为何，又来了 2 个人，课堂经理就需要到门口，对来的进行阻拦了，因为此时网点已容不下更多人</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141234.png"></p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>以下所有拒绝策略都实现了 RejectedExecutionHandle r接口</p><ul><li>AbortPolicy：默认，直接抛出 RejectedExcutionException 异常，阻止系统正常运行</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><hr><h4 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h4><h5 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141235.png"></p><p><strong>文字说明：</strong></p><ol><li>在创建了线程池后，等待提交过来的任务请求</li><li>当调用 execute() 方法添加一个请求任务时，线程池会做出如下判断<ol><li>如果正在运行的线程池数量小于 corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入 [ 阻塞队列 ]</li><li>如果这时候队列满了，并且正在运行的线程数量还小于 maximumPoolSize，那么还是创建非核心线程 like 运行这个任务；</li><li>如果队列满了并且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和 [ 拒绝策略 ]来执行</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做操作一定的时间 (keepAliveTime) 时，线程池会判断：<ol><li>如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉</li><li>所以线程池的所有任务完成后，它会最终收缩到 corePoolSize 的大小</li></ol></li></ol><p><strong>[ 以顾客去银行办理业务为例，谈谈线程池的底层工作原理：]</strong></p><ol><li>最开始假设来了两个顾客，因为 corePoolSize为 2，因此这两个顾客直接能够去窗口办理</li><li>后面又来了三个顾客，因为 corePool 已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li><li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li><li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li></ol><h4 id="为什么不用默认创建的线程池？"><a href="#为什么不用默认创建的线程池？" class="headerlink" title="为什么不用默认创建的线程池？"></a>为什么不用默认创建的线程池？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程池创建的方法有：[ 固定数的，单一的，可变的 ] ，那么在实际开发中，应该使用哪个？</span><br><span class="line"></span><br><span class="line">答：我们一个都不用，在生产环境中是使用自己自定义的</span><br><span class="line"></span><br><span class="line">为什么不用Executors中JDK提供的？</span><br></pre></td></tr></table></figure><p>根据阿里巴巴手册：并发控制这章</p><ul><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程<ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li></ul></li><li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutors 的方式，这样的处理方式让写的同学 [ 更加明确线程池的运行规则，规避资源耗尽的风险 ]<ul><li>Executors 返回的线程池对象弊端如下：<ul><li>FixedThreadPool 和 SingleThreadPool：<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</li></ul></li><li>CacheThreadPool 和 ScheduledThreadPool<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li></ul></li></ul></li></ul></li></ul><hr><h3 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h3><h4 id="采用默认拒绝策略"><a href="#采用默认拒绝策略" class="headerlink" title="采用默认拒绝策略"></a>采用默认拒绝策略</h4><p>从上面我们知道，因为默认的 Executors 创建的线程池，底层都是使用 LinkBlockingQueue 作为阻塞队列的，而LinkBlockingQueue 虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有 20 多亿，可以相当是无界的了，因此我们要使用 ThreadPoolExecutor 自己手动创建线程池，然后指定阻塞队列的大小</p><p>下面我们创建了一个 核心线程数为 2，最大线程数为 5，并且阻塞队列数为 3 的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写线程池</span></span><br><span class="line"><span class="keyword">final</span> Integer corePoolSize = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> Integer maximumPoolSize = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">final</span> Long keepAliveTime = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span></span><br><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    corePoolSize,</span><br><span class="line">    maximumPoolSize,</span><br><span class="line">    keepAliveTime,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure><p>然后使用 for 循环，模拟 10 个用户来进行请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 循环十次，模拟业务办理，让5个线程处理这10个请求</span><br><span class="line">      for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">          final int tempInt &#x3D; i;</span><br><span class="line">          executorService.execute(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + &quot;\t 给用户:&quot; + tempInt + &quot; 办理业务&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">      executorService.shutdown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是在用户执行到第 9 个的时候，触发了异常，程序中断 [ 最大只能运行 8 个 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task threadPoll.MyThreadPoolExecutorsDemo$$Lambda$14&#x2F;0x0000000840064c40@5b6f7412 rejected from java.util.concurrent.ThreadPoolExecutor@27973e9b[Running, pool size &#x3D; 5, active threads &#x3D; 5, queued tasks &#x3D; 3, completed tasks &#x3D; 0]</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)</span><br><span class="line">at threadPoll.MyThreadPoolExecutorsDemo.main(MyThreadPoolExecutorsDemo.java:32)</span><br><span class="line">pool-1-thread-5 给用户:8 办理业务</span><br><span class="line">pool-1-thread-3 给用户:6 办理业务</span><br><span class="line">pool-1-thread-1 给用户:1 办理业务</span><br><span class="line">pool-1-thread-2 给用户:2 办理业务</span><br><span class="line">pool-1-thread-4 给用户:7 办理业务</span><br><span class="line">pool-1-thread-2 给用户:5 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:3 办理业务</span><br></pre></td></tr></table></figure><p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的 AbortPolicy，也就是抛异常的</p><p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 = 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p><h4 id="采用CallerRunsPolicy拒绝策略"><a href="#采用CallerRunsPolicy拒绝策略" class="headerlink" title="采用CallerRunsPolicy拒绝策略"></a>采用CallerRunsPolicy拒绝策略</h4><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">main 给用户:8 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-3 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:3 办理业务</span><br><span class="line">pool-1-thread-1 给用户:2 办理业务</span><br></pre></td></tr></table></figure><p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p><h4 id="采用-DiscardPolicy-拒绝策略"><a href="#采用-DiscardPolicy-拒绝策略" class="headerlink" title="采用 DiscardPolicy 拒绝策略"></a>采用 DiscardPolicy 拒绝策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-1 给用户:2 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-3 给用户:3 办理业务</span><br></pre></td></tr></table></figure><p>采用 DiscardPolicy 拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p><h4 id="采用DiscardOldestPolicy拒绝策略"><a href="#采用DiscardOldestPolicy拒绝策略" class="headerlink" title="采用DiscardOldestPolicy拒绝策略"></a>采用DiscardOldestPolicy拒绝策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-1 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:8 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br></pre></td></tr></table></figure><p>这个策略和刚刚差不多，会把最久的队列中的任务替换掉</p><hr><h3 id="线程池的合理参数"><a href="#线程池的合理参数" class="headerlink" title="线程池的合理参数"></a>线程池的合理参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产环境中如何配置 corePoolSize 和 maximumPoolSize</span><br></pre></td></tr></table></figure><p>这个是根据具体业务来配置的，分为 CPU 密集型和 IO 密集型</p><ul><li>CPU密集型</li></ul><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p><p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p><p>CPU密集型任务 [ 配置尽可能少的线程数量 ] ：</p><p><strong>一般公式：</strong>CPU核数 + 1个线程数</p><ul><li>IO密集型</li></ul><p>由于 IO 密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p><p>IO 密集型，即该任务需要大量的 IO 操作，即大量的阻塞</p><p>在单线程上运行 IO 密集型的任务会导致浪费大量的 CPU 运算能力花费在等待上</p><p>所以 IO 密集型任务中使用多线程可以大大的加速程序的运行，即使在单核 CPU 上，这种加速主要就是利用了被浪费掉的阻塞时间。</p><p>IO密集时，大部分线程都被阻塞，故需要 [ 多配置线程数 ]：</p><p>参考公式：CPU核数 / (1 - 阻塞系数)   [ 阻塞系数在0.8 ~ 0.9左右 ] </p><p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9_Synchronized 和 Lock 的区别与好处</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/9-Synchronized-%E5%92%8C-Lock-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/9-Synchronized-%E5%92%8C-Lock-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h1 id="9-Synchronized-和-Lock-的区别与好处"><a href="#9-Synchronized-和-Lock-的区别与好处" class="headerlink" title="9_Synchronized 和 Lock 的区别与好处"></a>9_Synchronized 和 Lock 的区别与好处</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早期的时候我们解决  [ 生产者消费者问题  ]对线程的主要操作为：</p><ul><li>synchronized  👉   [ wait ]  [ notify / notifyAll ]</li></ul><p>然后后面出现了替代方案</p><ul><li>lock   👉  [ await ]  [ singal / singalAll ]</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141037.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="synchronized-和-lock-有什么区别？用新的-lock-有什么好处？举例说明"><a href="#synchronized-和-lock-有什么区别？用新的-lock-有什么好处？举例说明" class="headerlink" title="synchronized  和  lock 有什么区别？用新的 lock 有什么好处？举例说明"></a>synchronized  和  lock 有什么区别？用新的 lock 有什么好处？举例说明</h3><p>1）synchronized 属于JVM 层面，属于 java 的关键字</p><ul><li> monitorenter（底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象 只能在同步块或者方法中才能调用 wait/ notify 等方法）</li><li> Lock 是具体类（java.util.concurrent.locks.Lock）是 api 层面的锁</li></ul><p>2）使用方法：</p><ul><li>synchronized：不需要用户去手动释放锁，当 synchronized 代码执行后，系统会自动让线程释放对锁的占用</li><li>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要 lock() 和 unlock() 配置 try catch / finally语句来完成</li></ul><p>3）等待是否中断</p><ul><li>synchronized：不可中断，除非抛出异常或者正常运行完成</li><li>ReentrantLock：可中断，可以设置超时方法<ul><li>设置超时方法，trylock(long timeout, TimeUnit unit)</li><li>通过 lock.lockInterruptibly() 可以实现中断</li></ul></li></ul><p>4）加锁是否公平</p><ul><li>synchronized：非公平锁</li><li>ReentrantLock：默认非公平锁，构造函数可以传递 boolean 值，true 为公平锁，false 为非公平锁</li></ul><p>5）锁绑定多个条件 Condition</p><ul><li>synchronized：没有，要么随机，要么全部唤醒</li><li>ReentrantLock：用来实现 [ 分组唤醒需要唤醒的线程 ]，可以精确唤醒，而不是像 synchronized 那样，要么随机，要么全部唤醒</li></ul><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>针对刚刚提到的区别的第 5 条，我们有下面这样的一个场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目：多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br><span class="line">紧接着</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br><span class="line">..</span><br><span class="line">来10轮</span><br></pre></td></tr></table></figure><p>我们会发现，这样的场景在使用 synchronized 来完成的话，会非常的困难，但是使用 lock 就非常方便了</p><p>也就是我们需要实现一个链式唤醒的操作</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141052.png"></p><p>当 A 线程执行完后，B 线程才能执行，然后 B 线程执行完成后，C 线程才执行</p><p>首先我们需要创建一个重入锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个重入锁</span><br><span class="line">private Lock lock &#x3D; new ReentrantLock();</span><br></pre></td></tr></table></figure><p>然后定义三个条件，也可以称为 [ 锁的钥匙 ]，通过它就可以获取到锁，进入到方法里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这三个相当于备用钥匙</span><br><span class="line">private Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line">private Condition condition2 &#x3D; lock.newCondition();</span><br><span class="line">private Condition condition3 &#x3D; lock.newCondition();</span><br></pre></td></tr></table></figure><p>然后开始记住锁的三部曲： [ 判断 干活 唤醒 ]</p><p>这里的判断，为了 [ 避免虚假唤醒，一定要采用 while ]</p><p>干活就是把需要的内容，打印出来</p><p>唤醒的话，就是修改资源类的值，然后精准唤醒线程进行干活：这里A 唤醒B， B唤醒C，C又唤醒A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知B线程执行）</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************* 资源类 *******************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A 1   B 2   c 3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建一个重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这三个相当于备用钥匙</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知B线程执行）</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知C线程执行）</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知C线程执行）</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通知1号去干活了</span></span><br><span class="line">            condition1.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************* 测试类 *******************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    shareResource.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">A 10</span><br><span class="line">A 11</span><br><span class="line">A 12</span><br><span class="line">A 13</span><br><span class="line">A 14</span><br><span class="line">B 20</span><br><span class="line">B 21</span><br><span class="line">B 22</span><br><span class="line">B 23</span><br><span class="line">B 24</span><br><span class="line">B 25</span><br><span class="line">B 26</span><br><span class="line">B 27</span><br><span class="line">B 28</span><br><span class="line">B 29</span><br><span class="line">C 30</span><br><span class="line">C 31</span><br><span class="line">C 32</span><br><span class="line">C 33</span><br><span class="line">C 34</span><br><span class="line">C 35</span><br><span class="line">C 36</span><br><span class="line">C 37</span><br><span class="line">C 38</span><br><span class="line">C 39</span><br><span class="line">C 310</span><br><span class="line">C 311</span><br><span class="line">C 312</span><br><span class="line">C 313</span><br><span class="line">C 314</span><br><span class="line">.....</span><br><span class="line">执行 10 轮</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8_ 阻塞队列</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/8-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/8-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="8-阻塞队列"><a href="#8-阻塞队列" class="headerlink" title="8_ 阻塞队列"></a>8_ 阻塞队列</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭 [ FIFO ]</p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140908.png"></p><p>线程1 通过 Put 往阻塞队列中添加元素，而线程 2 通过 Take 从阻塞队列中移除元素：</p><ul><li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</li><li>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</li></ul><p>[  类比 1 ]：</p><ul><li>当蛋糕店的柜子空的时候，无法从柜子里面获取蛋糕</li><li>当蛋糕店的柜子满的时候，无法继续向柜子里面添加蛋糕了</li></ul><p>[  即 ]：</p><ul><li>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</li><li>试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</li></ul><hr><h3 id="为什么要用-？"><a href="#为什么要用-？" class="headerlink" title="为什么要用 ？"></a>为什么要用 ？</h3><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p><p>在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</p><h4 id="为什么需要-BlockingQueue"><a href="#为什么需要-BlockingQueue" class="headerlink" title="为什么需要 BlockingQueue"></a>为什么需要 BlockingQueue</h4><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都帮你一手包办了</p><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度 [ 减少程序员的负担 ：不需要手动阻塞或者唤醒 ] 。</p><hr><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ 面试 ]</span><br><span class="line">&#x2F;&#x2F; 你用过List集合类</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ArrayList集合类熟悉么？</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 还用过 CopyOnWriteList  和 BlockingQueue</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140924.png"></p><p>BlockingQueue 阻塞队列是属于一个接口，底下有七个实现类：</p><ul><li><strong>ArrayBlockQueue：</strong>由数组结构组成的有界阻塞队列</li><li><strong>LinkedBlockingQueue：</strong>由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<ul><li>[ 有界，但是界限非常大，相当于无界，可以当成无界 ]</li></ul></li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li><strong>SynchronousQueue：</strong>不存储元素的阻塞队列，也即单个元素的队列<ul><li>[ 生产一个，消费一个，不存储元素，不消费不生产 ]</li></ul></li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul><p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p><hr><h3 id="BlockingQueue-核心方法"><a href="#BlockingQueue-核心方法" class="headerlink" title="BlockingQueue 核心方法"></a>BlockingQueue 核心方法</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140931.png"></p><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException：Queue full                             当阻塞队列空时：再往队列中 remove 移除元素，会抛出： NoSuchException</th></tr></thead><tbody><tr><td>特殊性</td><td>插入方法，成功 true，失败 false 移除方法：成功返回出队列元素，队列没有就返回空</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到 put 数据 or 响应中断退出， 当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列可用。</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h5 id="抛出异常组"><a href="#抛出异常组" class="headerlink" title="抛出异常组"></a>抛出异常组</h5><p>但执行 add 方法，向已经满的 ArrayBlockingQueue 中添加元素时候，会抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻塞队列，[ 需要填入默认值 ]</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.add(&quot;XXX&quot;));</span><br></pre></td></tr></table></figure><p>运行后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span><br><span class="line">at java.util.AbstractQueue.add(AbstractQueue.java:98)</span><br><span class="line">at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)</span><br><span class="line">at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:25)</span><br></pre></td></tr></table></figure><p>同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了 3 个值，但是取的时候，取了 4 次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻塞队列，[ 需要填入默认值 ]</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此时队列为空</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br></pre></td></tr></table></figure><p>那么出现异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br><span class="line">at java.util.AbstractQueue.remove(AbstractQueue.java:117)</span><br><span class="line">at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:30)</span><br></pre></td></tr></table></figure><h5 id="布尔类型组"><a href="#布尔类型组" class="headerlink" title="布尔类型组"></a>布尔类型组</h5><p>我们使用 offer 的方法，添加元素时候，如果阻塞队列满了后，会返回 false ，否者返回 true</p><p>同时在取的时候，如果队列已空，那么会返回 null  [ 避免了产生异常，叫停程序 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue blockingQueue &#x3D; new ArrayBlockingQueue(3);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">&#x2F;&#x2F;队列已满</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">&#x2F;&#x2F;队列已空</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h5 id="阻塞队列组"><a href="#阻塞队列组" class="headerlink" title="阻塞队列组"></a>阻塞队列组</h5><p>我们使用 put 的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒</p><p>一般在消息中间件，比如 RabbitMQ 中会使用到，因为需要 [ 保证消息百分百不丢失，因此只有让它阻塞 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">blockingQueue.put(&quot;a&quot;);</span><br><span class="line">blockingQueue.put(&quot;b&quot;);</span><br><span class="line">blockingQueue.put(&quot;c&quot;);</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br><span class="line"></span><br><span class="line">blockingQueue.take();</span><br></pre></td></tr></table></figure><p>同时使用 take 取消息的时候，如果内容不存在的时候，也会被阻塞，直到队列有元素时，才唤醒</p><p>[ 如果一直队列一直没有元素呢 ，让它一直阻塞吗 ？ ]</p><h5 id="不见不散组"><a href="#不见不散组" class="headerlink" title="不见不散组"></a>不见不散组</h5><p>在 offer( ) ， poll 的基础上 [  加时间  ]</p><p>使用 offer 插入的时候，需要指定时间，如果 2 秒还没有插入，那么就放弃插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;a&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;b&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;c&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">&#x2F;&#x2F;尝试加入元素，如果 2s 都没有成功，放弃，返回 false</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;d&quot;, 2L, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>同时 poll 取的时候也进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">&#x2F;&#x2F;尝试取元素,如果 2s 都未取到,返回 null</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>如果 2 秒内取不出来，那么就返回 null</p><p>[ 这组方法就更加灵活，使用较多 ]</p><hr><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 没有容量，与其他 BlockingQueue 不同，SynchronousQueue 是一个不存储元素的 BlockingQueue，每一个 put 操作必须等待一个 take 操作，否者不能继续添加元素</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p><p>生产的线程分别 put 了 A、B、C这三个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个[不储存元素的]阻塞队列</span><br><span class="line">BlockingQueue&lt;String&gt; synchronousQueue &#x3D; new SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put A&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;A&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put B&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put C&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;t1&quot;).start();</span><br></pre></td></tr></table></figure><p>消费线程使用 take，消费阻塞队列中的内容，并且每次消费前，都等待 5 秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">           </span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take A&quot;);</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take B&quot;);</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take C&quot;);</span><br><span class="line"></span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;, &quot;t2&quot;).start();</span><br></pre></td></tr></table></figure><p>最后结果输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t1 put A </span><br><span class="line">5秒后...</span><br><span class="line">t2 take A </span><br><span class="line"></span><br><span class="line">t1 put B </span><br><span class="line">5秒后...</span><br><span class="line">t2 take B </span><br><span class="line"></span><br><span class="line">t1 put C </span><br><span class="line">5秒后...</span><br><span class="line">t2 take C </span><br></pre></td></tr></table></figure><p>我们从最后的运行结果可以看出，每次 t1 线程向队列中添加阻塞队列添加元素后，t1 输入线程就会等待 t2 消费线程，t2 消费后，t2 处于挂起状态，等待 t1 在 存入，从而周而复始，形成 一存一取的状态 。</p><p>完整版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: SynchronousQueue使用演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-11-13 13:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个[不储存元素的]阻塞队列</span></span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put A&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put B&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put C&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take A&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h3><h4 id="生产者消费者模式-2-0"><a href="#生产者消费者模式-2-0" class="headerlink" title="生产者消费者模式 2.0"></a>生产者消费者模式 2.0</h4><p>一个初始值为 0 的变量，两个线程对其交替操作，一个加 1，一个减 1，来 5 轮</p><p>关于多线程的操作，我们需要记住下面几句</p><ul><li>线程 操作 资源类</li><li>判断 干活 通知</li><li>防止虚假唤醒机制</li></ul><p>我们下面实现一个简单的生产者消费者模式，首先有资源类 ShareData</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package blockingQueue;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: xj0927</span><br><span class="line"> * @Description: 资源类 [高内聚，低耦合：内聚指的是，一个空调，自身带有调节温度高低的方法]</span><br><span class="line"> * @Date Created in 2020-11-13 14:13</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ShareData &#123;</span><br><span class="line"></span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void increment()&#123;</span><br><span class="line">        &#x2F;&#x2F;同步代码块：加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;判断</span><br><span class="line">            while (number !&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F;等待：不能生产</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;干活</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通知：唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            &#x2F;&#x2F;释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void decrement()&#123;</span><br><span class="line">        &#x2F;&#x2F;同步代码块：加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;判断</span><br><span class="line">            while (number &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F;等待：不能消费</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;干活</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通知:唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有一个 number 变量，同时提供了 increment  和 decrement 的方法，分别让 number 加 1 和减 1</p><p>但是我们在进行判断的时候，为了 [ 防止出现虚假唤醒机制 ]，不能使用 if 来进行判断，而应该使用 while 判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断</span><br><span class="line">while(number !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 等待不能生产</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能使用 if判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断</span><br><span class="line">if(number !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 等待不能生产</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 资源类 [高内聚，低耦合：内聚指的是，一个空调，自身带有调节温度高低的方法]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-11-13 14:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/********************* 资源类 *************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待：不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知：唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待：不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知:唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************* 测试 *************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//t1线程：生产</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">                shareData.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//t2线程：消费</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">                shareData.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后运行成功后，我们一个进行生产，一个进行消费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br></pre></td></tr></table></figure><hr><h4 id="生成者和消费者-3-0"><a href="#生成者和消费者-3-0" class="headerlink" title="生成者和消费者 3.0"></a>生成者和消费者 3.0</h4><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度 。</p><p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************** 资源类 *******************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认开启，进行生产消费</span></span><br><span class="line">    <span class="comment">// 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子包装类，而不用 number++ [ 不用担心原子操作]</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue [ 进行抽象]</span></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而应该采用依赖注入里面的，构造注入方法传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        <span class="comment">// 查询出传入的class是什么</span></span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，[ 防止出现虚假唤醒 ]</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列:&quot;</span> + data  + <span class="string">&quot;成功&quot;</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//[一旦 FLAG 为true 就停止生产]</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列:&quot;</span> + data  + <span class="string">&quot;失败&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 停止生产，表示FLAG=false，生产结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue != <span class="keyword">null</span> &amp;&amp; retValue != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="string">&quot;成功&quot;</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 退出消费队列 [不要忘记了]</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止生产的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 测试类 *******************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> SynchronousQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 生产线程启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myProd();</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;prod&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费线程启动&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5秒后，停止生产和消费</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5秒钟后，生产和消费线程停止，线程结束&quot;</span>);</span><br><span class="line">        myResource.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">prod 生产线程启动</span><br><span class="line">consumer 消费线程启动</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">consumer 消费队列：1成功</span><br><span class="line">prod 插入队列：1成功</span><br><span class="line">prod 插入队列：2成功</span><br><span class="line">consumer 消费队列：2成功</span><br><span class="line">prod 插入队列：3成功</span><br><span class="line">consumer 消费队列：3成功</span><br><span class="line">prod 插入队列：4成功</span><br><span class="line">consumer 消费队列：4成功</span><br><span class="line">prod 插入队列：5成功</span><br><span class="line">consumer 消费队列：5成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5秒钟后，生产和消费线程停止，线程结束</span><br><span class="line">prod 停止生产,表示FLAG &#x3D; false,生产结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer 消费失败,队列中已为空，退出</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7_CountDownLatch_CyclicBarrier_Semaphore使用</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/7-CountDownLatch-CyclicBarrier-Semaphore%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/7-CountDownLatch-CyclicBarrier-Semaphore%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="7-CountDownLatch-CyclicBarrier-Semaphore使用"><a href="#7-CountDownLatch-CyclicBarrier-Semaphore使用" class="headerlink" title="7_CountDownLatch_CyclicBarrier_Semaphore使用"></a>7_CountDownLatch_CyclicBarrier_Semaphore使用</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p><p>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，调用线程就会被阻塞。其它线程调用 CountDown 方法会将计数器减 1（调用 CountDown 方法的线程不会被阻塞），当计数器的值变成零时，因调用 await 方法被阻塞的线程会被唤醒，继续执行 。</p><h3 id="场景：班长关门"><a href="#场景：班长关门" class="headerlink" title="场景：班长关门"></a>场景：班长关门</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个时候就用到了 CountDownLatch，计数器了。我们一共创建 6 个线程，然后计数器的值也设置成 6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数器</span><br><span class="line">CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);</span><br></pre></td></tr></table></figure><p>然后每次学生线程执行完，就让计数器的值<strong>减 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 上完自习，离开教室&quot;);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是<strong>一道墙</strong>，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t 班长最后关门&quot;);</span><br></pre></td></tr></table></figure><p>不加 CountDownLatch 的执行结果，我们发现 main 线程提前已经执行完成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 上完自习，离开教室</span><br><span class="line">0 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br></pre></td></tr></table></figure><p>引入CountDownLatch后的执行结果，我们能够控制住 main 方法的执行，这样能够保证前提任务的执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 上完自习，离开教室</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">1 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moxi.interview.study.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 上完自习，离开教室&quot;</span>);</span><br><span class="line">                <span class="comment">//计数器 -1 </span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置屏障</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 班长最后关门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>和 CountDownLatch 相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行 。</p><p>CyclicBarrier 的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的 await 方法 。</p><h3 id="案例：七龙珠"><a href="#案例：七龙珠" class="headerlink" title="案例：七龙珠"></a>案例：七龙珠</h3><p>集齐 7 个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法[Runnable 接口]</span><br><span class="line">*&#x2F;</span><br><span class="line">CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(7, () -&gt; &#123;</span><br><span class="line">System.out.println(&quot;召唤神龙&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行 await 方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Semaphore：信号量"><a href="#Semaphore：信号量" class="headerlink" title="Semaphore：信号量"></a>Semaphore：信号量</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>信号量主要用于两个目的</p><ul><li>一个是用于共享资源的互斥使用</li><li>另一个用于并发线程数的控制</li></ul><p>通过 acquire() 和 release() 实现 。</p><h3 id="案例：抢车位"><a href="#案例：抢车位" class="headerlink" title="案例：抢车位"></a>案例：抢车位</h3><p>我们模拟一个抢车位的场景，假设一共有6个车，3个停车位</p><p>那么我们首先需要定义信号量为3，也就是3个停车位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span><br><span class="line">*&#x2F;</span><br><span class="line">Semaphore semaphore &#x3D; new Semaphore(3, false);</span><br></pre></td></tr></table></figure><p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后，信号量需要减1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代表一辆车，已经占用了该车位</span><br><span class="line">semaphore.acquire(); &#x2F;&#x2F; 抢占</span><br></pre></td></tr></table></figure><p>同时车辆假设需要等待3秒后，释放信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每个车停3秒</span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(3);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后车辆离开，释放信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 释放停车位</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟6部车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 代表一辆车，已经占用了该车位</span></span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 抢占</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 抢到车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每个车停3秒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 离开车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0 抢到车位</span><br><span class="line">2 抢到车位</span><br><span class="line">1 抢到车位</span><br><span class="line">2 离开车位</span><br><span class="line">1 离开车位</span><br><span class="line">3 抢到车位</span><br><span class="line">0 离开车位</span><br><span class="line">4 抢到车位</span><br><span class="line">5 抢到车位</span><br><span class="line">4 离开车位</span><br><span class="line">3 离开车位</span><br><span class="line">5 离开车位</span><br></pre></td></tr></table></figure><p>看运行结果能够发现，0 2 1 车辆首先抢占到了停车位，然后等待3秒后，离开，然后后面 3 4 5 又抢到了车位 。</p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6_Java 的锁</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/6-Java-%E7%9A%84%E9%94%81/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/6-Java-%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="6-Java-的锁"><a href="#6-Java-的锁" class="headerlink" title="6_Java 的锁"></a>6_Java 的锁</h1><h2 id="Java-锁之-公平锁-和-非公平锁"><a href="#Java-锁之-公平锁-和-非公平锁" class="headerlink" title="Java 锁之 公平锁 和 非公平锁"></a>Java 锁之 公平锁 和 非公平锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序 [ 随机抢占 ]，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p><h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><p>synchronized 只能是非公平锁 。</p><p>并发包中 ReentrantLock 的创建可以指定析构函数的 boolean 类型来得到公平锁或者非公平锁，默认是非公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span><br><span class="line">*&#x2F;</span><br><span class="line">Lock lock &#x3D; new ReentrantLock(true);</span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后按照 FIFO 的规则从队列中取到自己</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>Java ReenttrantLock 通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，<code>对于synchronized 而言，也是一种非公平锁 </code>。</p><hr><h2 id="可重入锁-和-递归锁-ReentrantLock"><a href="#可重入锁-和-递归锁-ReentrantLock" class="headerlink" title="可重入锁 和 递归锁 ReentrantLock"></a>可重入锁 和 递归锁 ReentrantLock</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>理念：</strong> [ 可重入锁就是递归锁 ！！！] 指的是 <strong>同一线程</strong> 外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 。也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p><p>⽐如⼀个线程获得了某个对象的锁 [ 第一层方法 ]，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的 [ 第二层方法 ]</p><p><strong>实现：</strong> ReentrantLock / Synchronized  就是一个典型的可重入锁</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>可重入锁就是，在一个 method1 方法中加入一把锁，方法 2 也加锁了，那么他们拥有的是同一把锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method1() &#123;</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void method2() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们只需要进入 method1 后，那么它也能直接进入method2 方法，因为他们所拥有的锁，是同一把 。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可重入锁的最大作用就是避免死锁</p><h3 id="可重入锁验证"><a href="#可重入锁验证" class="headerlink" title="可重入锁验证"></a>可重入锁验证</h3><h4 id="证明-Synchronized"><a href="#证明-Synchronized" class="headerlink" title="证明 Synchronized"></a>证明 Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送短信</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoked sendSMS()&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在同步方法中，调用另外一个同步方法</span></span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot;\t invoked sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个线程操作资源列</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们编写了一个资源类 phone，拥有两个加了 synchronized 的同步方法，分别是 sendSMS 和 sendEmail，我们在 sendSMS 方法中，调用 sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()</span><br><span class="line">t1 invoked sendEmail()</span><br><span class="line">t2 invoked sendSMS()</span><br><span class="line">t2 invoked sendEmail()</span><br></pre></td></tr></table></figure><p>这就说明当 t1 线程进入sendSMS 的时候，拥有了一把锁，同时 t2 线程无法进入，直到 t1 线程拿着锁，执行了sendEmail 方法后，才释放锁，这样 t2 才能够进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()      t1线程在外层方法获取锁的时候</span><br><span class="line">t1 invoked sendEmail()    t1在进入内层方法会自动获取锁</span><br><span class="line"></span><br><span class="line">t2 invoked sendSMS()      t2线程在外层方法获取锁的时候</span><br><span class="line">t2 invoked sendEmail()    t2在进入内层方法会自动获取锁</span><br></pre></td></tr></table></figure><h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set 进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">            setLock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t set Lock&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为Phone实现了Runnable接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们使用 ReentrantLock 进行验证，首先资源类实现了 Runnable 接口，重写 Run 方法，里面调用 get 方法，get 方法在进入的时候，就加了锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在方法里面，又调用另外一个加了锁的 setLock 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t set Lock&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果我们能发现，结果和加 synchronized 方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br></pre></td></tr></table></figure><p><strong>注意 1：</strong> 当我们在 getLock 方法加两把锁会是什么情况呢？(阿里面试)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">            setLock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是<strong>同一把锁</strong>，也就是说用同一个钥匙都能够打开 。</p><p><strong>注意 2：</strong> 当我们在 getLock 方法加两把锁，但是只解一把锁会出现什么情况呢 ？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void getLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br></pre></td></tr></table></figure><p>也就是说程序直接卡死，线程不能出来，也就说明我们<strong>申请几把锁，最后需要解除几把锁</strong></p><p><strong>注意 3：</strong> 当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢 ？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，运行程序会直接报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br><span class="line">Exception in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><hr><h2 id="Java-锁之-自旋锁"><a href="#Java-锁之-自旋锁" class="headerlink" title="Java 锁之 自旋锁"></a>Java 锁之 自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗 [ 避免用户态与内核态之间的转换 ]，缺点是循环会消耗CPU 。</p><p>原来提到的 CAS 比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140615.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>**优点： **循环比较获取直到成功为止，没有类似于 wait 的阻塞</p><p>**缺点： **当不断自旋的线程越来越多的时候，会因为执行 while 循环不断的消耗 CPU 资源</p><h3 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h3><p>通过 CAS 操作完成自旋锁，A线程先进来调用 myLock 方法自己持有锁 5 秒，B 随后进来发现当前有线程持有锁，不是 null，所以只能通过自旋等待，直到 A 释放锁后 B 随后抢到 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在的泛型装的是[Thread]，原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt;  atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前进来的线程</span></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋</span></span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前进来的线程</span></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己用完了后，把atomicReference变成null</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoked myUnlock()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动t1线程，开始操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始占有锁</span></span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始释放锁</span></span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让main线程暂停1秒，使得t1线程，先执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1秒后，启动t2线程，开始占用这个锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始占有锁</span></span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="comment">// 开始释放锁</span></span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 come in </span><br><span class="line">.....五秒后.....</span><br><span class="line">t1 invoked myUnlock()</span><br><span class="line">t2 come in </span><br><span class="line">t2 invoked myUnlock()</span><br></pre></td></tr></table></figure><p>首先输出的是 t1 come in</p><p>然后1秒后，t2线程启动，发现锁被 t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到 t1释放锁后，也就是 5 秒后，t2 成功获取到锁，然后释放 。</p><hr><h2 id="独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="独占锁（写锁） / 共享锁（读锁） / 互斥锁"></a>独占锁（写锁） / 共享锁（读锁） / 互斥锁</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>**独占锁： **指该锁一次只能被一个线程所持有。对 ReentrantLock 和 Synchronized 而言都是独占锁</p><p><strong>共享锁：</strong> 指该锁可以被多个线程锁持有 。</p><p>对 ReentrantReadWriteLock 其读锁是共享，其写锁是独占；写的时候只能一个人写，但是读的时候，可以多个人同时读 。</p><h3 id="为什么会有写锁和读锁"><a href="#为什么会有写锁和读锁" class="headerlink" title="为什么会有写锁和读锁"></a>为什么会有写锁和读锁</h3><p>原来我们使用 ReentrantLock 创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读 。</p><p>多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写 。</p><ul><li>读-读：能共存</li><li>读-写：不能共存</li><li>写-写：不能共存</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// private Lock lock = null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义写操作</span></span><br><span class="line"><span class="comment">     * 满足：原子 + 独占</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取:&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object value = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">// 线程操作资源类，5个线程写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt +  <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程操作资源类， 5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别创建5个线程写入缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程操作资源类，5个线程写</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">    final int tempInt &#x3D; i;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5个线程读取缓存，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程操作资源类， 5个线程读</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">    final int tempInt &#x3D; i;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        myCache.get(tempInt + &quot;&quot;);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 正在写入：0</span><br><span class="line">4 正在写入：4</span><br><span class="line">3 正在写入：3</span><br><span class="line">1 正在写入：1</span><br><span class="line">2 正在写入：2</span><br><span class="line">0 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">2 写入完成</span><br><span class="line">4 写入完成</span><br><span class="line">4 读取完成：null</span><br><span class="line">0 写入完成</span><br><span class="line">3 读取完成：null</span><br><span class="line">0 读取完成：null</span><br><span class="line">1 写入完成</span><br><span class="line">3 写入完成</span><br><span class="line">1 读取完成：null</span><br><span class="line">2 读取完成：null</span><br></pre></td></tr></table></figure><p>我们可以看到，在写入的时候，写操作都没其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致！！！</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 创建一个读写锁</span><br><span class="line">* 它是一个读写融为一体的锁，在使用的时候，需要转换</span><br><span class="line">*&#x2F;</span><br><span class="line">private ReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();</span><br></pre></td></tr></table></figure><p>当我们在进行写操作的时候，就需要转换成写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个写锁</span><br><span class="line">rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写锁 释放</span><br><span class="line">rwLock.writeLock().unlock();</span><br></pre></td></tr></table></figure><p>当们在进行读操作的时候，在转换成读锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个读锁</span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读锁 释放</span><br><span class="line">rwLock.readLock().unlock();</span><br></pre></td></tr></table></figure><p>这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个读写锁</span></span><br><span class="line"><span class="comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义写操作</span></span><br><span class="line"><span class="comment">     * 满足：原子 + 独占</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            map.put(key, value);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 写锁 释放</span></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object value = map.get(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 读锁释放</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程操作资源类，5个线程写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt +  <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程操作资源类， 5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 正在写入：1</span><br><span class="line">1 写入完成</span><br><span class="line">2 正在写入：2</span><br><span class="line">2 写入完成</span><br><span class="line">3 正在写入：3</span><br><span class="line">3 写入完成</span><br><span class="line">4 正在写入：4</span><br><span class="line">4 写入完成</span><br><span class="line">5 正在写入：5</span><br><span class="line">5 写入完成</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">5 正在读取:</span><br><span class="line">2 读取完成：2</span><br><span class="line">1 读取完成：1</span><br><span class="line">4 读取完成：4</span><br><span class="line">3 读取完成：3</span><br><span class="line">5 读取完成：5</span><br></pre></td></tr></table></figure><p>从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作 。</p><hr><p><strong>补充：</strong></p><h2 id="为什么Synchronized无法禁止指令重排，却能保证有序性"><a href="#为什么Synchronized无法禁止指令重排，却能保证有序性" class="headerlink" title="为什么Synchronized无法禁止指令重排，却能保证有序性"></a>为什么Synchronized无法禁止指令重排，却能保证有序性</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p><ul><li>Java内存模型</li><li>并发编程有序性问题</li><li>指令重排</li><li>synchronized锁</li><li>可重入锁</li><li>排它锁</li><li>as-if-serial语义</li><li>单线程&amp;多线程</li></ul><h4 id="标准解答"><a href="#标准解答" class="headerlink" title="标准解答"></a>标准解答</h4><p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p><blockquote><p>先解释什么是有序性问题，也知道是什么原因导致的有序性问题</p></blockquote><p>我们也知道，最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样。</p><blockquote><p>表明你知道啥是指令重排，也知道他的实现原理</p></blockquote><p>但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义。</p><p>as-if-serial语义把<strong>单线程</strong>程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p><blockquote><p>重点！解释下什么是as-if-serial语义，因为这是这道题的第一个关键词，答上来就对了一半了</p></blockquote><p>再说下synchronized，他是Java提供的锁，可以通过他对Java中的对象加锁，并且他是一种排他的、可重入的锁。</p><p>所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p><blockquote><p>介绍synchronized的原理，这是本题的第二个关键点，到这里基本就可以拿满分了。</p></blockquote><p>synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是<strong>单线程</strong>，因为有as-if-serial语义保证，单线程的有序性就天然存在了。</p><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p><a href="https://mp.weixin.qq.com/s/Pd6dOXaMQFUHfAUnOhnwtw">https://mp.weixin.qq.com/s/Pd6dOXaMQFUHfAUnOhnwtw</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_TransferValue 是什么</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/5-TransferValue-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/5-TransferValue-%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="5-TransferValue-是什么"><a href="#5-TransferValue-是什么" class="headerlink" title="5_TransferValue 是什么"></a>5_TransferValue 是什么</h1><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><h3 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String personName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personName = personName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferValueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.setPersonName(<span class="string">&quot;XXXX&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;XXX&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TransferValueDemo test = <span class="keyword">new</span> TransferValueDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义基本数据类型</span></span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        test.changeValue1(age);</span><br><span class="line">        System.out.println(<span class="string">&quot;age ----&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化person类</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        test.changeValue2(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;personName-----&quot;</span> + person.getPersonName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String</span></span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        test.changeValue3(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;string-----&quot;</span> + str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age ----20</span><br><span class="line">personName-----XXXX</span><br><span class="line">string-----abc</span><br></pre></td></tr></table></figure><h3 id="changeValue1-的执行过程"><a href="#changeValue1-的执行过程" class="headerlink" title="changeValue1 的执行过程"></a>changeValue1 的执行过程</h3><p>八种基本数据类型，在栈里面分配内存，属于值传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈管运行，堆管存储</span><br></pre></td></tr></table></figure><p>当们执行 changeValue1 的时候，因为 int 是基本数据类型，所以传递的是 int = 20 这个值，相当于传递的是一个副本，main 方法里面的 age 并没有改变，因此输出的结果  age 还是20，属于值传递 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140405.png"></p><h3 id="changeValue2-的执行过程"><a href="#changeValue2-的执行过程" class="headerlink" title="changeValue2 的执行过程"></a>changeValue2 的执行过程</h3><p>因为 Person 是属于对象，传递的是<strong>内存地址</strong>，当执行changeValue2的时候，会改变内存中的 Person 的值，属于引用传递，两个指针都是指向同一个地址 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140358.png"></p><h3 id="changeValue3-的执行过程"><a href="#changeValue3-的执行过程" class="headerlink" title="changeValue3 的执行过程"></a>changeValue3 的执行过程</h3><p>String 不属于基本数据类型，但是为什么执行完成后，还是 abc 呢？</p><p>这是因为 String 的特殊性，当我们执行 String str = “abc” 的时候，它会把 <code>abc</code> 放入常量池中</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140411.png"></p><p>当我们执行 changeValue3 的时候，会重新新建一个 xxx，并没有销毁 abc，然后指向xxx，然后最后我们输出的是 main 中的引用，还是指向的 abc，因此最后输出结果还是abc 。</p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 值传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_ Collection 线程不安全的举例</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/4-Collection-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/4-Collection-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Collection-线程不安全的举例"><a href="#4-Collection-线程不安全的举例" class="headerlink" title="4_ Collection 线程不安全的举例"></a>4_ Collection 线程不安全的举例</h1><h2 id="单线程环境下"><a href="#单线程环境下" class="headerlink" title="单线程环境下"></a>单线程环境下</h2><p>单线程环境的 ArrayList 是不会有问题的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListNotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String element : list) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>为什么 ArrayList 是线程不安全的 ？因为在进行写操作的时候，方法上为了保证并发性，是没有添加 synchronized 修饰，所以并发写的时候，就会出现问题 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140149.png"></p><hr><h2 id="ArrayList-不安全的案列"><a href="#ArrayList-不安全的案列" class="headerlink" title="ArrayList 不安全的案列"></a>ArrayList 不安全的案列</h2><p>当我们同时启动 100个线程去操作 List 的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">![Snipaste_2020-<span class="number">11</span>-<span class="number">12_17</span>-<span class="number">53</span>-<span class="number">21</span>](../../../../../myBlog/source/_posts/大厂面试第二季_周阳老师/JUC/4_ArrayList 为什么线程不安全/images/Snipaste_2020-<span class="number">11</span>-<span class="number">12_17</span>-<span class="number">53</span>-<span class="number">21.</span>png)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="comment">//往集合中添加元素【add 方法并未 synchronized 修饰】</span></span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候出现了错误，也就是<code>java.util.ConcurrentModificationException</code>[ 并发修改的异常 ]</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140157.png"></p><h4 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h4><p>并发修改导致：一个人正在写入，另一个人过来抢夺，导致数据不一致异常 ！</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：Vector"><a href="#方案一：Vector" class="headerlink" title="方案一：Vector"></a>方案一：Vector</h5><p>第一种方法，就是不用 ArrayList 这种不安全的 List 实现类，而采用 Vector，线程安全的</p><p>关于 Vector 如何实现线程安全的，而是在方法上加了锁，即 synchronized </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140202.png"></p><p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致并发性下降 。</p><h5 id="方案二：Collections-synchronizedList"><a href="#方案二：Collections-synchronizedList" class="headerlink" title="方案二：Collections.synchronizedList()"></a>方案二：Collections.synchronizedList()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>采用 Collections 集合工具类，在 ArrayList 外面包装一层 同步 机制 。</p><h5 id="方案三：使用-JUC-工具类中的-CopyOnWriteArrayList-类"><a href="#方案三：使用-JUC-工具类中的-CopyOnWriteArrayList-类" class="headerlink" title="方案三：使用 JUC 工具类中的 CopyOnWriteArrayList 类"></a>方案三：使用 JUC 工具类中的 CopyOnWriteArrayList 类</h5><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p><p>CopyOnWrite 容器即写时复制的容器。往一个容器添加元素的时候，不会直接往当前容器添加，而是现将当前容器 Object [ ] 进行 Copy ，复制出一个新的容器 Object [ ] ，然后再往新的容器中添加元素，添加完元素后，再将原容器的引用指向新的容器；这样做的好处是可以对 CopyOnWrite 容器进行并发读，而不需要加锁，因为当前容器并不需要添加元素。所以 CopyOnWrite 容器也是一种读写分离的思想！</p><p>就是写的时候，把 ArrayList 扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList 的引用指向扩容后的</p><p><strong>查看底层 add 方法源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Object[] elements = getArray();</span><br><span class="line">          <span class="keyword">int</span> len = elements.length;</span><br><span class="line">          Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">          newElements[len] = e;</span><br><span class="line">          setArray(newElements);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先需要加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure><p>然后在末尾扩容一个单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] elements &#x3D; getArray();</span><br><span class="line">int len &#x3D; elements.length;</span><br><span class="line">Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br></pre></td></tr></table></figure><p>然后在把扩容后的空间，填写上需要 add 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newElements[len] &#x3D; e;</span><br></pre></td></tr></table></figure><p>最后把内容 set 到 Array 中</p><hr><h2 id="HashSet-线程不安全"><a href="#HashSet-线程不安全" class="headerlink" title="HashSet 线程不安全"></a>HashSet 线程不安全</h2><h4 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h4><p> 线程不安全。并发情况下也会发生 <code>ConcurrentModificationException</code> 异常；</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：Collections-synchronizedSet-new-HashSet-lt-gt"><a href="#方案一：Collections-synchronizedSet-new-HashSet-lt-gt" class="headerlink" title="方案一：Collections.synchronizedSet(new HashSet&lt;&gt;())"></a>方案一：<code>Collections.synchronizedSet(new HashSet&lt;&gt;())</code></h5><h5 id="方案二：使用-JUC-工具类中的-CopyOnWriteArraySet-类"><a href="#方案二：使用-JUC-工具类中的-CopyOnWriteArraySet-类" class="headerlink" title="方案二：使用 JUC 工具类中的 CopyOnWriteArraySet 类"></a>方案二：使用 JUC 工具类中的 CopyOnWriteArraySet 类</h5><p>底层还是使用 CopyOnWriteArrayList 进行实例化</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140209.png"></p><p><strong>补充：</strong></p><p>同理 HashSet 的底层结构就是 HashMap</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140214.png"></p><p><strong>思考：</strong> 但是为什么我调用 HashSet.add() 的方法，只需要传递一个元素，而 HashMap 是需要传递 key-value 键值对 ？</p><p>首先我们查看 hashSet 的 add 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们能发现但我们调用 add 的时候，存储一个值进入map中，只是作为key进行存储，而 value 存储的是一个Object 类型的常量，也就是说 HashSet 只关心key，而不关心 value 。</p><hr><h2 id="HashMap-线程不安全案列"><a href="#HashMap-线程不安全案列" class="headerlink" title="HashMap 线程不安全案列"></a>HashMap 线程不安全案列</h2><p>同理 HashMap 在多线程环境下，也是不安全的，并发情况下也会发生 <code>ConcurrentModificationException</code> 异常；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：使用-HashTable"><a href="#方案一：使用-HashTable" class="headerlink" title="方案一：使用 HashTable"></a>方案一：使用 HashTable</h5><p>与 Vector 类似，属于 HashMap 线程安全的实现类，里面方面同样加了 <code>synchronized</code>修饰，效率较低 。</p><h5 id="方案二：Collections-synchronizedMap-new-HashMap-lt-gt"><a href="#方案二：Collections-synchronizedMap-new-HashMap-lt-gt" class="headerlink" title="方案二：Collections.synchronizedMap(new HashMap&lt;&gt; ())"></a>方案二：Collections.synchronizedMap(new HashMap&lt;&gt; ())</h5><h5 id="方案三：使用-JUC-工具类下的-ConcurrentHashMap"><a href="#方案三：使用-JUC-工具类下的-ConcurrentHashMap" class="headerlink" title="方案三：使用 JUC 工具类下的  ConcurrentHashMap"></a>方案三：使用 JUC 工具类下的  ConcurrentHashMap</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_谈谈原子类的ABA问题</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/3-%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/3-%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="3-谈谈原子类的ABA问题"><a href="#3-谈谈原子类的ABA问题" class="headerlink" title="3_谈谈原子类的ABA问题"></a>3_谈谈原子类的ABA问题</h1><h2 id="原子类-AtomicInteger-的ABA问题"><a href="#原子类-AtomicInteger-的ABA问题" class="headerlink" title="原子类 AtomicInteger 的ABA问题"></a>原子类 AtomicInteger 的ABA问题</h2><h3 id="连环套路"><a href="#连环套路" class="headerlink" title="连环套路"></a>连环套路</h3><p>从 AtomicInteger 引出下面的问题：</p><p>CAS -&gt; Unsafe -&gt; CAS 底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避 ABA 问题</p><hr><h3 id="ABA-问题是什么"><a href="#ABA-问题是什么" class="headerlink" title="ABA 问题是什么"></a>ABA 问题是什么</h3><p>假设现在有两个线程，分别是 T1 和 T2，然后 T1 执行某个操作的时间为10 秒，T2 执行某个时间的操作是 2 秒，最开始 AB 两个线程，分别从主内存中获取 A 值，但是因为 B 的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105629.png"></p><p>所以 ABA 问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了 N 次，但是最终又改成原来的值了 。</p><h3 id="CAS-导致-ABA-问题"><a href="#CAS-导致-ABA-问题" class="headerlink" title="CAS 导致 ABA 问题"></a>CAS 导致 ABA 问题</h3><p>CAS 算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p><p>比如说一个线程 one 从内存位置 V 中取出A，这时候另外一个线程 two 也从内存中取出 A，并且线程 two进行了一些操作将值变成了B，然后线程 two 又将 V 位置的数据变成 A，这时候线程 one 进行CAS操作发现内存中仍然是 A，然后线程 one 操作成功 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的！！！</span><br></pre></td></tr></table></figure><hr><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>原子引用其实和原子包装类是差不多的概念，就是将一个 java 类，用原子引用类进行包装起来，那么这个类就具备了原子性 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User z3 = <span class="keyword">new</span> User(<span class="string">&quot;z3&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        User l4 = <span class="keyword">new</span> User(<span class="string">&quot;l4&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在主物理内存的共享变量，为z3</span></span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于原子引用的-ABA-问题"><a href="#基于原子引用的-ABA-问题" class="headerlink" title="基于原子引用的 ABA 问题"></a>基于原子引用的 ABA 问题</h4><p>我们首先创建了两个线程，然后 T1 线程，执行一次 ABA 的操作，T2 线程在一秒后修改主内存的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的原子引用包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，它能够成功的修改，这就是 ABA 问题</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105647.png"></p><hr><h3 id="解决-ABA-问题"><a href="#解决-ABA-问题" class="headerlink" title="解决 ABA 问题"></a>解决 ABA 问题</h3><p><strong>思路如下：</strong></p><p>新增一种机制，也就是修改版本号，类似于[ 时间戳 ]的概念</p><p>T1： 100 1 2019 2</p><p>T2： 100 1 101 2 100 3</p><p>如果 T1 修改的时候，版本号为 2，落后于现在的版本号 3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路 。</p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的原子引用包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递两个值，一个是初始值，一个是初始版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的产生==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t3一秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否：&quot;</span> + result + <span class="string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能够发现，线程 t3，在进行 ABA 操作后，版本号变更成了 3，而线程 t4 在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样 。</p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_CAS 底层原理</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/2-CAS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/2-CAS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="2-CAS-底层原理"><a href="#2-CAS-底层原理" class="headerlink" title="2_CAS 底层原理"></a>2_CAS 底层原理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CAS 的全称是 Compare-And-Swap，它是 CPU 并发原语</p><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p><p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法。调用UnSafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于 CAS 是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，不会造成所谓的数据不一致的问题，也就是说 CAS 是线程安全的 。</p><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个原子类</span></span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span></span><br><span class="line"><span class="comment">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140025.png"></p><p>首先调用 AtomicInteger 创建了一个实例， 并初始化为 5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger(5);</span><br></pre></td></tr></table></figure><p>然后调用 CAS 方法，企图更新成 2019，这里有两个参数，一个是 5，表示期望值，第二个就是我们要更新的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(5, 2019)</span><br></pre></td></tr></table></figure><p>然后再次使用了一个方法，同样将值改成 1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(5, 1024)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了 2019，不满足期望值，因此返回了 false，本次写入失败！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135811.png"></p><hr><h2 id="CAS-底层原理"><a href="#CAS-底层原理" class="headerlink" title="CAS 底层原理"></a>CAS 底层原理</h2><p>首先我们先看看 atomicInteger.getAndIncrement() 方法的源码</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135820.png"></p><p>从这里能够看到，底层又调用了一个 unsafe 类的 getAndAddInt 方法</p><h3 id="1、unsafe-类"><a href="#1、unsafe-类" class="headerlink" title="1、unsafe 类"></a>1、unsafe 类</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135829.png"></p><p>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe 类存在sun.misc 包中，其内部方法操作可以像 C 的指针一样直接操作内存，因为 Java 中的 CAS 操作的执行依赖于 Unsafe 类的方法。</p><blockquote><p>注意 Unsafe 类的所有方法都是 native 修饰的，也就是说 unsafe 类中的方法都直接调用操作系统底层资源执行相应的任务！！！</p></blockquote><p>为什么 Atomic 修饰的包装类，能够保证原子性，依靠的就是底层的 unsafe 类</p><h3 id="2、变量-valueOffset"><a href="#2、变量-valueOffset" class="headerlink" title="2、变量 valueOffset"></a>2、变量 valueOffset</h3><p>表示该变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135835.png"></p><p>从这里我们能够看到，通过 valueOffset，直接通过内存地址，获取到值，然后进行加 1 的操作</p><h3 id="3、变量-value-用-volatile-修饰"><a href="#3、变量-value-用-volatile-修饰" class="headerlink" title="3、变量 value 用 volatile 修饰"></a>3、变量 value 用 volatile 修饰</h3><p>保证了多线程之间的内存可见性</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135844.png"></p><p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行 compareAndSwapInt() 在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p><p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p><p>假设执行 compareAndSwapInt 返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用 synchronized，而用 CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的 do while 循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作 。</p><p>假设线程 A 和线程 B 同时执行 getAndInt 操作（分别跑在不同的 CPU 上）</p><ol><li>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据JMM 模型，线程 A 和线程 B 各自持有一份价值为 3 的副本，分别存储在各自的工作内存</li><li>线程 A 通过 getIntVolatile(var1 , var2)  拿到 value 值3，这是线程 A 被挂起（该线程失去 CPU 执行权）</li><li>线程 B 也通过 getIntVolatile(var1, var2) 方法获取到 value 值也是3，此时刚好线程 B 没有被挂起，并执行了compareAndSwapInt 方法，比较内存的值也是 3，成功修改内存值为 4，线程B打完收工，一切OK</li><li>这是线程 A 恢复，执行 CAS 方法，比较发现自己手里的数字 3 和主内存中的数字 4 不一致，说明该值已经被其它线程抢先一步修改过了，那么 A 线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行 do while</li><li>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总能够看到，线程 A 继续执行 compareAndSwapInt 进行比较替换，直到成功。</li></ol><p>Unsafe 类 + CAS 思想： 也就是自旋，自我旋转！！！</p><p><strong>补充：</strong>上面说到的 Unsafe 类中的 compareAndSwapInt 是一个本地方法，该方法的实现位于unsafe.cpp 中</p><ul><li>先想办法拿到变量 value 在内存中的地址</li><li>通过 Atomic::cmpxchg 实现比较替换，其中参数 X 是即将更新的值，参数 e 是原内存的值</li></ul><hr><h2 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h2><p>CAS 是一种乐观锁，它避免了悲观锁独占锁对象的情况，同时也提高了并发性能</p><p>存在问题如下：</p><ul><li><p>乐观锁只能保证一个共享变量的原子操作。如果存在多个变量，乐观锁将显得力不从心【但互斥锁能轻易解决，不管对象数量的多少级对象颗粒的大小】</p></li><li><p><strong>长时间自旋可能导致开销大。</strong>加入 CAS 长时间操作不成功一直自旋，会给 CPU带来很大的开销。</p></li><li><p>*<em>ABA 问题  <em>。</em></em>CAS 的核心思想是通过比较内存值和预期值是否一样而判断内存值是否被更改过，但此判断逻辑不严谨，假如内存值为 A，后来一条线程修改为 B，最后又被另一个线程改成了 A，则 CAS 认为内存值并没有发生过改变，但实际情况是有被其他线程修改，这种情况对依赖过程值的情景的运算结果影响很大。</p><p>解决办法：<strong>引入版本号</strong>，每次变量更新都把版本号【时间戳】加一。</p></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的更新值 B。</p><p>CAS 是 compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止 ！！</p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_谈谈volatile</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/1-%E8%B0%88%E8%B0%88volatile/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/1-%E8%B0%88%E8%B0%88volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="1-谈谈Volatile"><a href="#1-谈谈Volatile" class="headerlink" title="1_谈谈Volatile"></a>1_谈谈Volatile</h1><h2 id="1-Volatile-和-JMM-内存模型的可见性"><a href="#1-Volatile-和-JMM-内存模型的可见性" class="headerlink" title="1_Volatile 和 JMM 内存模型的可见性"></a>1_Volatile 和 JMM 内存模型的可见性</h2><ul><li>JUC（java.util.concurrent）<ul><li>进程和线程<ul><li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li><li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li></ul></li><li>并发和并行<ul><li>并发：同时访问某个东西，就是并发</li><li>并行：一起做某些事情，就是并行</li></ul></li></ul></li><li>JUC 下的三个包<ul><li>java.util.concurrent<ul><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul></li></ul></li></ul><h3 id="谈谈你对-Volatile-的理解"><a href="#谈谈你对-Volatile-的理解" class="headerlink" title="谈谈你对 Volatile 的理解"></a>谈谈你对 Volatile 的理解</h3><p>volatile 在日常的单线程环境是应用不到的</p><p>volatile 是 Java 虚拟机提供的 <strong>轻量级</strong> 【乞丐版 synchronized】的同步机制。</p><p>volatile 修饰的变量具有三种特性：</p><ol><li>保证可见性</li><li><strong>不保证原子性</strong>【原子性：完整性，不可缺性，中间不可以被分割，要么成功，要么失败】</li><li>禁止指令重排序【计算机底层实现是：会在其前后加内存屏障，禁止内存屏障前后的指令进行重排序优化】</li></ol><h4 id="那你能否写一个-Demo-验证一下可见性-？"><a href="#那你能否写一个-Demo-验证一下可见性-？" class="headerlink" title="那你能否写一个 Demo 验证一下可见性 ？"></a>那你能否写一个 Demo 验证一下可见性 ？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始执行&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 线程睡眠3秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                date.setNumber();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟线程B：一直在这里等待循环，直到 number 的值不等于零</span></span><br><span class="line">        <span class="keyword">while</span> (date.number == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要变量的值被修改，就会执行下面的语句</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    <span class="comment">//volatile 保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程就是：</p><ul><li>线程 a 从主内存读取 共享变量 到对应的工作内存</li><li>对共享变量进行更改</li><li>线程 b 读取共享变量的值到对应的工作内存</li><li>线程 a 将修改后的值刷新到主内存，失效其他线程对 共享变量的副本</li><li>线程 b 对共享变量进行操作时，发现已经失效，重新从主内存读取最新值，放入到对应工作内存。</li></ul><h4 id="你能否写个-Demo-验证一下-不保证原子性？"><a href="#你能否写个-Demo-验证一下-不保证原子性？" class="headerlink" title="你能否写个 Demo 验证一下 不保证原子性？"></a>你能否写个 Demo 验证一下 不保证原子性？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Date2 date2 = <span class="keyword">new</span> Date2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启20个线程</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//每个线程执行1000次++操作</span></span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">0</span>;j &lt; <span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    date2.setNumberPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="built_in">String</span>.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让20个线程全部执行完</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123; <span class="comment">//main + GC</span></span><br><span class="line">            <span class="comment">//礼让线程</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看最终结果</span></span><br><span class="line">        System.out.println(date2.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date2</span></span>&#123;</span><br><span class="line">    volatile int number;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">setNumberPlus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//让其自增</span></span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程是：</p><ul><li><p>假设现在共享变量的值是 100 ，线程 A 需要对变量进行自增 1，首先它从主内存中读取变量值，由于 CPU 切换关系，此时切换到 B线程；  </p></li><li><p>B 线程也从主内存中读取变量值，此时读取到的变量值还是 100，然后在自己的工作内存中进行了 + 1 操作，但是还未刷新回主内存；</p></li><li><p>此时，CPU 又切换到了 A线程，由于 B 线程还未将工作内存中的值刷新回主内存，因此 A 线程中的值还是 100，A 线程对工作内存中的变量进行 + 1 操作；</p></li><li><p>线程 B 刷新 新的值 101 到主内存 ；</p></li><li><p>线程 A 刷新 新的值 101 到主内存；</p><p>结果就是：两次 +1 操作，却只进行了 1 次修改</p></li></ul><h4 id="那如何才能保证原子性呢-？"><a href="#那如何才能保证原子性呢-？" class="headerlink" title="那如何才能保证原子性呢 ？"></a>那如何才能保证原子性呢 ？</h4><p>方式1：使用 synchronized 【大材小用】</p><p>方式2：使用 JUC 下的 AtomicInteger 原子类【底层是基于 CAS】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Date3 date3 = <span class="keyword">new</span> Date3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启20个线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//每个线程执行1000次++操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    date3.setAtomic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让20个线程全部执行完</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123; <span class="comment">//主线程 + GC</span></span><br><span class="line">            Thread.yield();<span class="comment">//礼让线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看最终结果</span></span><br><span class="line">        System.out.println(date3.number); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date3</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个原子 Integer 包装类，默认为0</span></span><br><span class="line">    AtomicInteger number = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtomic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//相当于 atomicInter ++</span></span><br><span class="line">        number.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的-Demo-？"><a href="#什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的-Demo-？" class="headerlink" title="什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的 Demo ？"></a>什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的 Demo ？</h4><p>为了提高性能，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105309.png"></p><p>单线程环境里面确保最终执行结果和代码顺序的结果一致 。</p><blockquote><p>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></p></blockquote><p>但是，当多线程交替执行时，由于编译器优化重排，两个线程在使用的变量能否保住一致性是无法确定的，结果无法预测 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date4</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a; <span class="comment">//使用 volatile 禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">5</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;打印成功&quot;</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile-针对指令重排做了啥"><a href="#volatile-针对指令重排做了啥" class="headerlink" title="volatile 针对指令重排做了啥"></a>volatile 针对指令重排做了啥</h4><p>volatile 实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象</p><p>首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，它的作用有两个：</p><ul><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）</li></ul><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器 和 CPU，不管什么指令都不能和这条 Memory Barrier 指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是刷新出各种 CPU 的缓存数，因此任何 CPU 上的线程都能读取到这些数据的最新版本。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105310.png"></p><p>也就是过在 volatile 的写 和 读的时候，加入屏障，防止出现指令重排的！！！</p><h4 id="那么你在什么场景下有使用到-volatile-呢-？"><a href="#那么你在什么场景下有使用到-volatile-呢-？" class="headerlink" title="那么你在什么场景下有使用到 volatile 呢 ？"></a>那么你在什么场景下有使用到 volatile 呢 ？</h4><p><strong>单例模式中【双重检查机制</strong>】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.提供静态变量保存实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton6 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供获取对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一重检查：针对很多个线程同时想要创建对象的情况</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步代码块锁定</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton6.class)&#123;</span><br><span class="line">     <span class="comment">//第二重锁检查(针对比如A,B两个线程都为null，第一个线程创建完对象，第二个等待锁的线程拿到锁的情况)</span></span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请你说说为什么要在这里加上 volatile 呢？</strong></p><p>因为创建对象分为 3 步：</p><ol><li>分配内存空间；</li><li>初始化对象</li><li>设置实例执行刚分配的内存地址【正常流程走：instance ! = null】</li></ol><p>但是，由于这 3 步<strong>不存在数据依赖关系</strong> ，所以可能进行重排序优化，造成下列现象：</p><ol><li>分配内存空间</li><li>设置实例执行刚分配的内存地址【instance ! = null 有名无实，初始化并未完成！】</li><li>初始化对象</li></ol><p><strong>所有当另一条线程访问 instance 时 不为null，但是 instance实例化未必已经完成，也就造成线程安全问题！</strong></p><hr><h3 id="JMM-是什么"><a href="#JMM-是什么" class="headerlink" title="JMM  是什么"></a>JMM  是什么</h3><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105311.png" style="zoom:67%;" /><p>JMM （Java 内存模型）是一种抽象的概念 <strong>并不真实存在</strong>，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素，不包括局部变量和方法参数，这是线程私有的，不存在竞争关系）的访问方式。</p><ul><li><p>具体的 JMM 规定如下：</p><ol><li> 所有 共享变量 储存于 主内存 中；</li><li> 每条线程拥有自己的工作内存，保存了被线程使用的变量的副本拷贝；</li><li> 线程对变量的所有操作（读，写）都必须在自己的 工作内存 中完成，而不能直接读写 主内存 中的变量；</li><li> 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存中转来完成</li></ol></li></ul><p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU</p><p>两个概念：主内存 和 工作内存</p><ul><li><p>主内存：就是计算机的内存，也就是经常提到的 8G 内存，16G 内存</p></li><li><p>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中</p><ul><li>当同时有三个线程同时访问 student 中的 age 变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝 。</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105312.png"></p><p>即：JMM 内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><hr><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>为什么这里主线程中某个值被更改后，其它线程能马上知晓呢？其实这里是用到了<strong>总线嗅探技术</strong></p><p>在说嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一。</p><p><strong>为了解决缓存一致性的问题</strong>，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有 MSI、MESI 等等。</p><h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><p>当 CPU 写数据时，如果发现操作的变量是共享变量，即在其它 CPU中 也存在该变量的副本，会发出信号通知其它 CPU 将该内存变量的缓存行设置为无效，因此当其它 CPU 读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。</p><h4 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h4><p><strong>那么是如何发现数据是否失效呢？</strong></p><p>这里是用到了总线嗅探技术，就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p><h4 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h4><p><strong>总线嗅探技术有哪些缺点？</strong></p><p>由于 volatile 的 MESI 缓存一致性协议，需要不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用 volatile 关键字，至于什么时候使用 volatile、什么时候用锁以及 Syschonized 都是需要根据实际场景的。</p><hr><h3 id="线程安全获得保证"><a href="#线程安全获得保证" class="headerlink" title="线程安全获得保证"></a>线程安全获得保证</h3><p><strong>工作内存与主内存同步延迟现象导致的可见性问题</strong></p><ul><li>可通过 synchronized 或 volatile 关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见 。</li></ul><p><strong>对于指令重排导致的可见性问题和有序性问题</strong></p><ul><li>可以使用 volatile 关键字解决，因为 volatile 关键字的另一个作用就是禁止重排序优化 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_垃圾收集器</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5_垃圾收集器"></a>5_垃圾收集器</h1><blockquote><p>问题5：GC垃圾回收算法和垃圾收集器关系？分别是什么请你谈谈？</p><ul><li>天上飞的理念，要有落地的实现（垃圾收集器就是GC垃圾回收算法的实现）</li><li>GC算法是内存回收的方法论，垃圾收集器就是算法的落地实现</li></ul></blockquote><p><strong>GC算法主要有以下几种：</strong></p><ul><li><del>引用计数（几乎不用，无法解决循环引用的问题）</del></li><li>复制拷贝（用于新生代）</li><li>标记清除（用于老年代）</li><li>标记整理（用于老年代）</li><li>因为目前为止还没有完美的收集器出现，更没有万能的收集器，只是针对具体应用最合适的收集器，进行<font color='red'>;</font></li></ul><hr><p> <strong>四种主要的垃圾收集器：</strong></p><ul><li>Serial：串行回收 <code>-XX:+UseSeriallGC</code></li><li>Parallel：并行回收 <code>-XX:+UseParallelGC</code></li><li>CMS：并发标记清除</li><li>G1</li><li>ZGC：（java 11 出现的）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105011.png"></p><hr><h2 id="四种主要的垃圾收集器"><a href="#四种主要的垃圾收集器" class="headerlink" title="四种主要的垃圾收集器"></a>四种主要的垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><blockquote><p>串行垃圾回收器，它为单线程环境设计且值<code>使用一个线程进行垃圾收集，会暂停所有的用户线程</code>，只有当垃圾回收完成时，才会重新唤醒主线程继续执行。所以不适合服务器环境</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105012.png"></p><hr><h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><blockquote><p>并行垃圾收集器，<code>多个垃圾收集线程并行工作，此时用户线程也是阻塞的</code>，适用于科学计算 / 大数据处理等弱交互场景，</p><p>也就是说Serial 和 Parallel其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停，但是并行垃圾收集器处理时间，<strong>肯定比串行的垃圾收集器要更短</strong></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105013.png"></p><hr><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><blockquote><p>并发标记清除，<code>用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程</code>，互联网公司都在使用，适用于响应时间有要求的场景。</p><p>并发是可以有交互的，也就是说可以一边进行收集，一边执行应用程序。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105014.png"></p><hr><h3 id="串行-并行-并发-垃圾收集器总结"><a href="#串行-并行-并发-垃圾收集器总结" class="headerlink" title="串行/并行/并发 垃圾收集器总结"></a>串行/并行/并发 垃圾收集器总结</h3><p>注意：并行垃圾回收在单核CPU下可能会更慢</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105015.png"></p><hr><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><blockquote><p>G1垃圾回收器将堆内存<code>分割成不同区域，然后并发的进行垃圾回收</code>.</p><p>Java 7 和 Java 8 开始使用G1，Java 11开始换成了ZGC</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105016.png"></p><hr><h2 id="默认垃圾收集器"><a href="#默认垃圾收集器" class="headerlink" title="默认垃圾收集器"></a>默认垃圾收集器</h2><blockquote><p>问题7：怎么查看服务器的默认GC收集器？生产上如何配置GC收集器？谈谈你的GC收集器的理解？</p></blockquote><h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><p>使用下面JVM命令，查看配置的初始参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure><p>然后运行一个程序后，能够看到它的一些初始配置信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105017.png"></p><p>移动到最后一句，就能看到 <code>-XX:+UseParallelGC</code> 说明使用的是并行垃圾回收。</p><hr><h3 id="默认垃圾收集器种类"><a href="#默认垃圾收集器种类" class="headerlink" title="默认垃圾收集器种类"></a>默认垃圾收集器种类</h3><p>Java中一共有7大垃圾收集器</p><ul><li>UserSerialGC：串行垃圾收集器</li><li>UserParallelGC：并行垃圾收集器</li><li>UseConcMarkSweepGC：（CMS）并发标记清除</li><li>UseParNewGC：年轻代的并行垃圾回收器</li><li>UseParallelOldGC：老年代的并行垃圾回收器</li><li>UseG1GC：G1垃圾收集器</li><li><del>UserSerialOldGC：串行老年代垃圾收集器（已经被移除）</del></li></ul><hr><p><strong>底层源码：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105018.png"></p><hr><h3 id="各垃圾收集器的使用范围"><a href="#各垃圾收集器的使用范围" class="headerlink" title="各垃圾收集器的使用范围"></a>各垃圾收集器的使用范围</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105019.png"></p><p>新生代使用的：</p><ul><li>Serial Copying： UserSerialGC，串行垃圾回收器</li><li>Parallel Scavenge：UserParallelGC，并行垃圾收集器</li><li>ParNew：UserParNewGC，新生代并行垃圾收集器</li></ul><p>老年区使用的：</p><ul><li><del>Serial Old：UseSerialOldGC，老年代串行垃圾收集器</del></li><li>Parallel Compacting（Parallel Old）：UseParallelOldGC，老年代并行垃圾收集器</li><li>CMS：UseConcMarkSwepp，并行标记清除垃圾收集器</li></ul><p>各区都能使用的：</p><p>G1：UseG1GC，G1垃圾收集器</p><blockquote><p><font color='red'>垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大</font></p></blockquote><hr><p>HotSpot中包含的收集器如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105020.png"></p><h3 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h3><ul><li>DefNew：Default New Generation</li><li>Tenured：Old</li><li>ParNew：Parallel New Generation</li><li>PSYoungGen：Parallel Scavenge</li><li>ParOldGen：Parallel Old Generation</li></ul><hr><h3 id="Java中的Server和Client模式"><a href="#Java中的Server和Client模式" class="headerlink" title="Java中的Server和Client模式"></a>Java中的Server和Client模式</h3><blockquote><p>使用范围：一般使用Server模式，Client模式基本不会使用</p></blockquote><p>操作系统</p><ul><li>32位的Window操作系统，不论硬件如何都默认使用Client的JVM模式</li><li>32位的其它操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式</li><li>64位只有Server模式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105021.png"></p><hr><h2 id="新生代下的垃圾收集器"><a href="#新生代下的垃圾收集器" class="headerlink" title="新生代下的垃圾收集器"></a>新生代下的垃圾收集器</h2><h3 id="串行GC-Serial"><a href="#串行GC-Serial" class="headerlink" title="串行GC(Serial)"></a>串行GC(Serial)</h3><blockquote><p>串行GC（Serial）（Serial Copying）：是一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105022.png"></p><p>串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在垃圾收集过程中可能会产生较长的停顿(Stop-The-World 状态)。 虽然在收集垃圾过程中需要暂停所有其它的工作线程，但是它<strong>简单高效</strong>，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是Java虚拟机运行在Client模式下默认的新生代垃圾收集器</p><p><font color='red'>对应JVM参数是：-XX:+UseSerialGC</font></p><p><font color='red'>开启后会使用：Serial(Young区用) + Serial Old(Old区用) 的收集器组合</font></p><p><strong>表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法</strong></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105023.png"></p><p>对应： DefNew + Tenured</p><hr><h3 id="并行GC-ParNew"><a href="#并行GC-ParNew" class="headerlink" title="并行GC(ParNew)"></a>并行GC(ParNew)</h3><blockquote><p>并行收集器，使用<code>多线程进行垃圾回收</code>，在垃圾收集，会 Stop-the-World 暂停其他所有的工作线程直到它收集结束</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105024.png"></p><p>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景时配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。<strong>它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</strong></p><p><font color='red'>常见对应JVM参数：-XX:+UseParNewGC 启动ParNew收集器，只影响新生代的收集，不影响老年代</font></p><p><font color='red'>开启上述参数后，会使用：ParNew（Young区用） + Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</font></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParNewGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105025.png"></p><p>但是会出现警告，即 ParNew 和 Serial Old 这样搭配，Java8已经不再被推荐</p><p>对应： ParNew + Tenured</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105020.png"></p><p>备注： -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数</p><hr><h3 id="并行回收GC（Parallel）-（Parallel-Scavenge）"><a href="#并行回收GC（Parallel）-（Parallel-Scavenge）" class="headerlink" title="并行回收GC（Parallel）/ （Parallel Scavenge）"></a>并行回收GC（Parallel）/ （Parallel Scavenge）</h3><blockquote><p>因为Serial 和 ParNew都不推荐使用了，因此现在新生代默认使用的是Parallel Scavenge，也就是新生代和老年代都是使用并行</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105026.png"></p><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。一句话：<strong>串行收集器在新生代和老年代的并行化</strong></p><p>它关注的重点是：</p><p><font color='red'>可控制的吞吐量（Thoughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。</font>高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。</p><p><font color='red'>自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。</font>（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间( -XX:MaxGCPauseMills)）或最大的吞吐量。</p><p><font color='red'>常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC（可互相激活）使用Parallel Scanvenge收集器</font></p><p><strong>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</strong></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105027.png"></p><p>对应：PSYoungGen + ParOldGen</p><hr><h2 id="老年代下的垃圾收集器"><a href="#老年代下的垃圾收集器" class="headerlink" title="老年代下的垃圾收集器"></a>老年代下的垃圾收集器</h2><h3 id="并行GC（Parallel-Old）-（Parallel-MSC）"><a href="#并行GC（Parallel-Old）-（Parallel-MSC）" class="headerlink" title="并行GC（Parallel Old）/ （Parallel MSC）"></a>并行GC（Parallel Old）/ （Parallel MSC）</h3><blockquote><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p></blockquote><p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。<font color='red'>在JDK1.6以前(Parallel Scavenge + Serial Old)</font></p><p>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以考虑新生代Parallel Scavenge和老年代Parallel Old 收集器的搭配策略。<font color='red'>在JDK1.8及后（Parallel Scavenge + Parallel Old）</font></p><p><font color='red'>JVM常用参数：-XX +UseParallelOldGC：使用Parallel Old收集器，设置该参数后，新生代Parallel+老年代 Parallel Old</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105028.png"></p><hr><p>实例：</p><p>使用老年代并行收集器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelOldlGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105029.png"></p><p>对应：PSYoungGen + ParOldGen</p><hr><h3 id="并发标记清除GC（CMS）"><a href="#并发标记清除GC（CMS）" class="headerlink" title="并发标记清除GC（CMS）"></a>并发标记清除GC（CMS）</h3><blockquote><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以最短回收停顿时间为目标的收集器适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，<strong>希望系统停顿时间最短。</strong></p><p>CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105030.png"></p><p>Concurrent Mark Sweep：并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行</p><p><font color='red'>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后，会自动将 -XX:+UseParNewGC打开，开启该参数后，使用ParNew(young 区用）+ CMS（Old 区用） + Serial Old 的收集器组合，Serial Old将作为CMS出错的后备收集器</font></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105031.png"></p><hr><h4 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h4><ul><li>初始标记（CMS initial mark）<ul><li>只是标记一个GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程</li></ul></li><li>并发标记（CMS concurrent mark）和用户线程一起<ul><li>进行GC Roots跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象</li></ul></li><li>重新标记（CMS remark）<ul><li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，在做修正</li></ul></li><li>并发清除（CMS concurrent sweep）和用户线程一起<ul><li>清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105032.png"></p><hr><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li><font color='red'>并发收集低停顿</font></li></ul><p>缺点：</p><ul><li>并发执行，对CPU资源压力大，采用的标记清除算法<font color='red'>会导致大量碎片</font></li></ul><p>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW方式进行一次GC，从而造成较大的停顿时间</p><p>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩，CMS也提供了参数 -XX:CMSFullGCSBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</p><hr><h3 id="串行GC（Serial-Old）-Serial-MSC"><a href="#串行GC（Serial-Old）-Serial-MSC" class="headerlink" title="串行GC（Serial Old） / (Serial MSC)"></a>串行GC（Serial Old） / (Serial MSC)</h3><blockquote><p>Serial Old是Serial垃圾收集器老年代版本，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机中默认的老年代垃圾收集器</p></blockquote><p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）</p><ul><li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用（Parallel Scavenge + Serial Old）</li><li>作为老年代版中使用CMS收集器的后备垃圾收集方案。</li></ul><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialOldlGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105033.png"></p><p><del><font color='red'>该垃圾收集器，目前已经不推荐使用了！！！</font></del></p><hr><h2 id="为什么新生代采用复制算法，老年代采用标整算法"><a href="#为什么新生代采用复制算法，老年代采用标整算法" class="headerlink" title="为什么新生代采用复制算法，老年代采用标整算法"></a>为什么新生代采用复制算法，老年代采用标整算法</h2><p><strong>新生代使用复制算法</strong></p><blockquote><p>因为新生代对象的生存时间比较短，80%的都要回收的对象，采用标记-清除算法则内存碎片化比较严重，采用复制算法可以灵活高效，且便与整理空间。</p></blockquote><p><strong>老年代采用标记整理</strong></p><blockquote><p>标记整理算法主要是为了解决标记清除算法存在内存碎片的问题，又解决了复制算法两个Survivor区的问题，因为老年代的空间比较大，不可能采用复制算法，特别占用内存空间</p></blockquote><h2 id="垃圾收集器如何选择"><a href="#垃圾收集器如何选择" class="headerlink" title="垃圾收集器如何选择"></a>垃圾收集器如何选择</h2><p><strong>组合的选择</strong></p><ul><li>单CPU或者小内存，单机程序<ul><li>-XX:+UseSerialGC</li></ul></li><li>多CPU，需要最大的吞吐量，如后台计算型应用<ul><li>-XX:+UseParallelGC（这两个相互激活）</li><li>-XX:+UseParallelOldGC</li></ul></li><li>多CPU，追求低停顿时间，需要快速响应如互联网应用<ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+ParNewGC</li></ul></li></ul><table><thead><tr><th>参数</th><th>新生代垃圾收集器</th><th>新生代算法</th><th>老年代垃圾收集器</th><th>老年代算法</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>SerialGC</td><td>复制</td><td>SerialOldGC</td><td>标记整理</td></tr><tr><td>-XX:+UseParNewGC</td><td>ParNew</td><td>复制</td><td>SerialOldGC</td><td>标记整理</td></tr><tr><td>-XX:+UseParallelGC</td><td>Parallel [Scavenge]</td><td>复制</td><td>Parallel Old</td><td>标记整理</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>ParNew</td><td>复制</td><td>CMS + Serial Old的收集器组合，Serial Old作为CMS出错的后备收集器</td><td><strong>标记清除</strong></td></tr><tr><td>-XX:+UseG1GC</td><td>G1整体上采用标记整理算法</td><td>局部复制</td><td></td><td></td></tr></tbody></table><hr><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><blockquote><p>问题8：G1垃圾收集器</p></blockquote><p>开启G1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><p><strong>以前收集器的特点：</strong></p><ul><li>年轻代和老年代是各自独立且连续的内存块</li><li>年轻代收集使用单eden + S0 + S1 进行复制算法</li><li>老年代收集必须扫描珍整个老年代区域</li><li>都是以尽可能少而快速地执行GC为设计原则</li></ul><hr><h3 id="G1是什么"><a href="#G1是什么" class="headerlink" title="G1是什么"></a>G1是什么</h3><blockquote><p>G1：Garbage-First 收集器，是一款面向服务端应用的收集器，应用在多处理器和大容量内存环境中，<code>在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求。</code></p></blockquote><p>另外，它还具有一下特征：</p><ul><li>像CMS收集器一样，能与应用程序并发执行</li><li>整理空闲空间更快</li><li>需要更多的时间来预测GC停顿时间</li><li>不希望牺牲大量的吞吐量性能</li><li>不需要更大的Java Heap</li></ul><p>G1收集器设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色</p><ul><li>G1是一个有整理内存过程的垃圾收集器，<font color='red'>不会产生很多内存碎片。</font></li><li>G1的Stop The World（STW）更可控，<font color='red'>G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</font></li></ul><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器</p><p>G1是在2012才在JDK1.7中可用，Oracle官方计划在JDK9中将G1变成默认的垃圾收集器以替代CMS，它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换Java8以前的CMS收集器</p><p><font color='orange'>主要改变时：Eden，Survivor 和 Tenured 等内存区域不再是连续了，而是变成一个个大小一样的region，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</font></p><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW</li><li>G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片</li><li>宏观上看G1之中不再区分年轻代和老年代。把内存划分成多个独立的子区域（Region），可以近似理解为一个围棋的棋盘</li><li>G1收集器里面将整个内存区域都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但他们不再是物理隔离的，而是通过一部分Region的集合且不需要Region是连续的，也就是说依然会采取不同的GC方式来处理不同的区域</li><li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的Survivor（to space）堆做复制准备，<strong>G1只有逻辑上的分代概念</strong>，或者说每个分区都可能随G1的运行在不同代之间前后切换。</li></ul><hr><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><blockquote><p>Region区域化垃圾收集器，化整为零，打破了原来新生区和老年区的壁垒，<code>避免了全内存扫描，只需要按照区域来进行扫描即可。</code></p></blockquote><p>区域化内存划片Region，整体遍为了一些列不连续的内存区域，避免了全内存区的GC操作。</p><p>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置子区域大小</p><p><strong>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可</strong>，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code> 可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。</p><p>大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048 = 64G内存</p><p>Region区域化垃圾收集器</p><h4 id="Region区域化垃圾收集器"><a href="#Region区域化垃圾收集器" class="headerlink" title="Region区域化垃圾收集器"></a>Region区域化垃圾收集器</h4><p>G1将新生代、老年代的物理空间划分取消了</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105034.png"></p><p>同时对内存进行了区域划分</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105035.png" alt="image-20200326120130427"></p><p>G1算法将堆划分为若干个区域（Reign），它仍然属于分代收集器，这些Region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</p><p>这些Region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片的问题存在了。</p><p>在G1中，还有一种特殊的区域，叫做Humongous（巨大的）区域，如果一个对象占用了空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象，这些巨型对象默认直接分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p><hr><h4 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h4><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是<strong>小区域收集 + 形成连续的内存块</strong>，避免内碎片</p><ul><li>Eden区的数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会晋升到Old区</li><li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区</li><li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105036.png" alt="image-20200326121409237"></p><p>回收完成后</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105037.png" alt="image-20200326121622208"></p><p>小区域收集 + 形成连续的内存块，最后在收集完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p><hr><h4 id="四步过程"><a href="#四步过程" class="headerlink" title="四步过程"></a>四步过程</h4><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105038.png"></p><hr><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>开发人员仅仅需要申明以下参数即可</p><p>三步归纳：<code>-XX:+UseG1GC -Xmx32G -XX:MaxGCPauseMillis=100</code></p><p>-XX:MaxGCPauseMillis=n：最大GC停顿时间单位毫秒，这是个软目标，JVM尽可能停顿小于这个时间 </p><p><strong>常用配置（了解）：</strong></p><ul><li>-XX:UseG1GC：使用G1垃圾回收器</li><li>-XX:G1HeapRegionSize=n：划分region大小</li><li>-XX:MaxGCPauseMillis：最大GC停顿时间，是个软目标，尽量达到。</li><li>-XX:InitiatingHeapOccupancyPercent：堆占用了多少执行GC，默认45%</li><li>-XX:ConcGCThreads：并发GC使用的线程数</li><li>-XX:G1ReservePercent：设置为空闲空间的预留内存比</li></ul><hr><h3 id="G1和CMS比较"><a href="#G1和CMS比较" class="headerlink" title="G1和CMS比较"></a>G1和CMS比较</h3><ul><li>G1不会产生内碎片</li><li>是可以精准控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。</li></ul><hr><h2 id="SpringBoot结合JVMGC"><a href="#SpringBoot结合JVMGC" class="headerlink" title=" SpringBoot结合JVMGC"></a><font color='red'> SpringBoot结合JVMGC</font></h2><p>启动微服务时候，就可以带上JVM和GC的参数</p><ul><li>IDEA开发完微服务工程</li><li>maven进行clean package：打成jar包或者war包</li><li>要求微服务启动的时候，同时配置我们的JVM/GC的调优参数<ul><li>我们就可以根据具体的业务配置我们启动的JVM参数</li></ul></li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xms1024m -Xmx1024 -XX:UseG1GC -jar   xxx.jar</span><br></pre></td></tr></table></figure><p>可以使用<code>jps -l</code>查看端口号，使用<code>jinfo -flags 端口号</code>查看我们配置的参数</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_Java内存溢出OOM</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/4-Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAOOM/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/4-Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAOOM/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Java内存溢出OOM"><a href="#4-Java内存溢出OOM" class="headerlink" title="4_Java内存溢出OOM"></a>4_Java内存溢出OOM</h1><p>JVM中常见的两个错误</p><p>StackoverFlowError ：栈溢出</p><p>OutofMemoryError: java heap space：堆溢出</p><p>除此之外，还有以下的错误</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><hr><p><strong>架构：</strong></p><p>OutOfMemoryError和StackOverflowError是属于Error，不是Exception</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104822.png"></p><h2 id="StackoverFlowError"><a href="#StackoverFlowError" class="headerlink" title="StackoverFlowError"></a>StackoverFlowError</h2><blockquote><p>堆栈溢出，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p></blockquote><p>栈一般是512K，不断的深度调用，直到栈被撑破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowErrorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈一般是512K，不断的深度调用，直到栈被撑破</span><br><span class="line">     * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void stackOverflowError() &#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.moxi.interview.study.oom.StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:17)</span><br></pre></td></tr></table></figure><hr><h2 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h2><blockquote><p><code>java heap space</code></p><p>创建了很多对象，导致堆空间不够存储</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Java堆内存不足</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JavaHeapSpaceDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 堆空间的大小 -Xms10m -Xmx10m</span><br><span class="line">        &#x2F;&#x2F; 创建一个 80M的字节数组</span><br><span class="line">        byte [] bytes &#x3D; new byte[80 * 1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个80M的数组，会直接出现Java heap space</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><hr><h2 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h2><blockquote><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，<font color='red'>超过了98%的时间用来做GC，并且回收了不到2%的堆内存</font></p></blockquote><p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p><p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104823.png"></p><hr><p><strong>代码演示：</strong></p><p>为了更快的达到效果，我们首先需要设置JVM启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br></pre></td></tr></table></figure><p>这个异常出现的步骤就是，我们不断的向list中插入String对象，直到启动GC回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * GC 回收超时</span><br><span class="line"> * JVM参数配置: -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class GCOverheadLimitDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                list.add(String.valueOf(++i).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;***************i:&quot; + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7106K-&gt;7106K(7168K)] 9154K-&gt;9154K(9728K), [Metaspace: 3504K-&gt;3504K(1056768K)], 0.0311093 secs] [Times: user&#x3D;0.13 sys&#x3D;0.00, real&#x3D;0.03 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7136K-&gt;667K(7168K)] 9184K-&gt;667K(9728K), [Metaspace: 3540K-&gt;3540K(1056768K)], 0.0058093 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 114K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 5% used [0x00000000ffd00000,0x00000000ffd1c878,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 667K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a6ff8,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3605K, capacity 4540K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 399K, capacity 428K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">at java.lang.Integer.toString(Integer.java:403)</span><br><span class="line">at java.lang.String.valueOf(String.java:3099)</span><br><span class="line">at com.moxi.interview.study.oom.GCOverheadLimitDemo.main(GCOverheadLimitDemo.java:18)</span><br></pre></td></tr></table></figure><p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 <code>GC overhead limit</code></p><hr><h2 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h2><blockquote><p>Netty + NIO：<code>这是由于NIO引起的</code></p><p>写NIO程序的时候经常会使用ByteBuffer来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</p></blockquote><p>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><ul><li>ByteBuffer.allocate(capability)：第一种方式是<font color='red'>分配JVM堆内存，属于GC管辖范围</font>，由于需要拷贝所以速度相对较慢</li><li>ByteBuffer.allocteDirect(capability)：第二种方式是<font color='red'>分配OS本地内存，不属于GC管辖范围</font>，由于不需要内存的拷贝，所以速度相对较快</li></ul><p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104824.png"></p><p><font color='orange'>一句话说：本地内存不足，但是堆内存充足的时候，就会出现这个问题</font></p><hr><p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br></pre></td></tr></table></figure><p>然后我们申请一个6M的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只设置了5M的物理内存使用，但是却分配 6M的空间</span><br><span class="line">ByteBuffer bb &#x3D; ByteBuffer.allocateDirect(6 * 1024 * 1024);</span><br></pre></td></tr></table></figure><p>这个时候，运行就会出现问题了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">配置的maxDirectMemory：5.0MB</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2030K-&gt;488K(2560K)] 2030K-&gt;796K(9728K), 0.0008326 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 308K-&gt;712K(7168K)] 796K-&gt;712K(9728K), [Metaspace: 3512K-&gt;3512K(1056768K)], 0.0052052 secs] [Times: user&#x3D;0.09 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:693)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">at com.moxi.interview.study.oom.DIrectBufferMemoryDemo.main(DIrectBufferMemoryDemo.java:19)</span><br></pre></td></tr></table></figure><hr><h2 id="unable-to-create-new-native-thread"><a href="#unable-to-create-new-native-thread" class="headerlink" title="unable to create new native thread"></a>unable to create new native thread</h2><blockquote><p>不能够创建更多的新的线程了，也就是说<code>创建线程的上限达到了</code></p></blockquote><p>在高并发场景的时候，会应用到</p><p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p><p><strong>导致原因：</strong></p><ul><li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li><li>服务器并不允许你的应用程序创建这么多线程，linux系统默认运行单个进程可以创建的线程为1024个，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li></ul><p><strong>解决方法：</strong></p><ol><li>想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li><li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过修改linux服务器配置，扩大linux默认限制</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">![4](images&#x2F;4.png)&#x2F;**</span><br><span class="line"> * 无法创建更多的线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UnableCreateNewThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; ; i++) &#123;</span><br><span class="line">            System.out.println(&quot;************** i &#x3D; &quot; + i);</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，就会出现下列的错误，线程数大概在 900多个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to cerate new native thread</span><br></pre></td></tr></table></figure><p>如何查看线程数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -u</span><br></pre></td></tr></table></figure><p>修改配置方法：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104825.png"></p><hr><h2 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h2><blockquote><p>元空间内存不足，Matespace元空间应用的是本地内存</p><p><code>-XX:MetaspaceSize</code> 的初始化化大小为20M</p></blockquote><h3 id="元空间是什么"><a href="#元空间是什么" class="headerlink" title="元空间是什么"></a>元空间是什么</h3><p><strong>元空间就是我们的方法区，存放的是类模板，类信息，常量池等</strong></p><p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p><p>永久代（java8后背元空间Metaspace取代了）存放了以下信息：</p><ul><li>虚拟机加载的类信息</li><li>常量池</li><li>静态变量</li><li>即时编译后的代码</li></ul><hr><p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;8m -XX:MaxMetaspaceSize&#x3D;8m</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 元空间溢出</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MetaspaceOutOfMemoryDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态类</span><br><span class="line">    static class OOMTest &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟计数多少次以后发生异常</span><br><span class="line">        int i &#x3D;0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                &#x2F;&#x2F; 使用Spring的动态字节码技术</span><br><span class="line">                Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">                enhancer.setSuperclass(OOMTest.class);</span><br><span class="line">                enhancer.setUseCache(false);</span><br><span class="line">                enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">                        return methodProxy.invokeSuper(o, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;发生异常的次数:&quot; + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发生异常的次数: 201</span><br><span class="line">java.lang.OutOfMemoryError:Metaspace</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_Java中的引用</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/3-Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/3-Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Java中的引用"><a href="#3-Java中的引用" class="headerlink" title="3_Java中的引用"></a>3_Java中的引用</h1><p>在原来的时候，我们谈到一个类的实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; new Person()</span><br></pre></td></tr></table></figure><p>在等号的左边，就是一个对象的引用，存储在栈中</p><p>而等号右边，就是实例化的对象，存储在堆中</p><p>其实这样的一个引用关系，就被称为强引用</p><hr><p> 整体架构</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104721.png"></p><hr><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><blockquote><p>当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，<font color='red'>就算是出现了OOM也不会对该对象进行回收，打死也不回收~！</font></p></blockquote><p>强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。</p><p>在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，<strong>因此强引用是造成Java内存泄漏的主要原因之一。</strong></p><p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用于或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p><hr><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这样定义的默认就是强应用</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用第二个引用，指向刚刚创建的Object对象</span></span><br><span class="line">        Object obj2 = obj1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置空</span></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并没有将该对象进行垃圾回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">java.lang.Object@14ae5a5</span><br></pre></td></tr></table></figure><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><blockquote><p>软引用是一种相对弱化了一些的引用，需要用<code>Java.lang.ref.SoftReference</code>类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p><ul><li><font color='red'>当系统内存充足时，它不会被回收</font></li><li><font color='red'>当系统内存不足时，它会被回收</font></li></ul></blockquote><p>软引用通常在对内存敏感的程序中，比如高速缓存就用到了软引用，<strong>内存够用 的时候就保留，不够用就回收</strong></p><hr><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存够用的时候</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个强应用</span></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个软引用</span></span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span></span><br><span class="line"><span class="comment">     * -Xms5m -Xmx5m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryNoEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个强应用</span></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个软引用</span></span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟OOM自动GC</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建30M的大对象</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        softRefMemoryEnough();</span><br><span class="line"></span><br><span class="line">        softRefMemoryNoEnough();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>情况一：</strong></p><p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p><p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p><p>然后我们把o1设置为null，执行手动GC后，我们发现softReference的值还存在，说明内存充足的时候，软引用的对象不会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1396K-&gt;504K(1536K)] 1504K-&gt;732K(5632K), <span class="number">0.0007842</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 504K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 228K-&gt;651<span class="title">K</span><span class="params">(4096K)</span>] 732K-&gt;651<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3480K-&gt;3480<span class="title">K</span><span class="params">(1056768K)</span>], 0.0058450 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">java.lang.Object@14ae5a5</span><br></pre></td></tr></table></figure><hr><p><strong>情况二：</strong></p><p>下面我们看当内存不够的时候，我们使用了JVM启动参数配置，给初始化堆内存为5M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms5m -Xmx5m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>但是在创建对象的时候，我们创建了一个30M的大对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建30M的大对象</span><br><span class="line">byte[] bytes &#x3D; new byte[30 * 1024 * 1024];</span><br></pre></td></tr></table></figure><p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明，软引用在内存不足的时候，会自动回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@7f31245a</span><br><span class="line">java.lang.Object@7f31245a</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 31K-&gt;160K(1536K)] 682K-&gt;811K(5632K), <span class="number">0.0003603</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 160K-&gt;96K(1536K)] 811K-&gt;747K(5632K), <span class="number">0.0006385</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 96K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 651K-&gt;646<span class="title">K</span><span class="params">(4096K)</span>] 747K-&gt;646<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3488K-&gt;3488<span class="title">K</span><span class="params">(1056768K)</span>], 0.0067976 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 646K-&gt;646K(5632K), <span class="number">0.0004024</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 646K-&gt;627<span class="title">K</span><span class="params">(4096K)</span>] 646K-&gt;627<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3488K-&gt;3488<span class="title">K</span><span class="params">(1056768K)</span>], 0.0065506 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><hr><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><blockquote><p><font color='red'>不管内存是否够，只要有GC操作就会进行回收</font></p><p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的空间。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看结果，能够发现，我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5246K-&gt;808K(76288K)] 5246K-&gt;816K(251392K), 0.0008236 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;675K(175104K)] 816K-&gt;675K(251392K), [Metaspace: 3494K-&gt;3494K(1056768K)], 0.0035953 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line"></span><br><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure><hr><h2 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h2><blockquote><p>场景：假如有一个应用需要读取大量的本地图片</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能</li><li>如果一次性全部加载到内存中，又可能造成内存溢出</li></ul><p>说明：下面方式使用<code>弱引用</code>也可以完成！</p></blockquote><p>此时使用软引用可以解决这个问题</p><p><strong>设计思路：</strong> 使用HashMap来保存图片的路径和相应图片<code>对象关联的软引用</code>之间的映射关系，<font color='red'>在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache &#x3D; new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure><hr><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>比如一些常常和底层打交道的，mybatis等，底层都应用到了WeakHashMap</p><blockquote><p>WeakHashMap和HashMap类似，只不过它的Key是使用了弱引用的，也就是说，当执行GC的时候，HashMap中的key会进行回收，</p></blockquote><p>下面我们使用例子来测试一下</p><p>我们使用了两个方法，一个是普通的HashMap方法</p><p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    String value = <span class="string">&quot;HashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    System.gc();</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个是使用了WeakHashMap，完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        myHashMap();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        myWeakHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        String value = <span class="string">&quot;HashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        String value = <span class="string">&quot;WeakHashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;1&#x3D;HashMap&#125;</span><br><span class="line">&#123;1&#x3D;HashMap&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#123;1&#x3D;WeakHashMap&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p><p>但是WeakHashMap，在进行GC操作后，弱引用的就会被回收</p><hr><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><blockquote><p>虚引用又称为幽灵引用，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p><p>顾名思义，就是<code>形同虚设</code>，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p><p>如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，<strong>虚引用必须和引用队列ReferenceQueue联合使用。</strong></p><p><font color='red'>虚引用的主要作用和跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</font></p><p><strong>PhantomReference的get方法总是返回null</strong>，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>换句话说，设置虚引用关联的唯一目的，<strong>就是在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</strong></p><p>这个就相当于Spring AOP里面的后置通知</p></blockquote><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><blockquote><p>一般用于在回收时候做通知相关操作</p></blockquote><p>软引用，弱引用，虚引用在回收之前，需要在引用队列保存一下</p><p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object o1 &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建引用队列</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个弱引用</span><br><span class="line">WeakReference&lt;Object&gt; weakReference &#x3D; new WeakReference&lt;&gt;(o1, referenceQueue);</span><br></pre></td></tr></table></figure><p>那么在进行GC回收的时候，弱引用和虚引用的对象都会被回收，但是在回收之前，它会被送至引用队列中</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个弱引用</span></span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个弱引用</span></span><br><span class="line"><span class="comment">//        PhantomReference&lt;Object&gt; weakReference = new PhantomReference&lt;&gt;(o1, referenceQueue);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        <span class="comment">// 取队列中的内容</span></span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行GC操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        <span class="comment">// 取队列中的内容</span></span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">null</span><br><span class="line">执行GC操作</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">java.lang.ref.WeakReference@7f3124</span><br></pre></td></tr></table></figure><p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例被放置引用队列中了，我们可以通过引用队列进行一些后置操作</p><hr><h2 id="GCRoots和四大引用小总结"><a href="#GCRoots和四大引用小总结" class="headerlink" title="GCRoots和四大引用小总结"></a>GCRoots和四大引用小总结</h2><ul><li>红色部分在垃圾回收之外，也就是强引用的</li><li>蓝色部分：属于软引用，在内存不够的时候，才回收</li><li>虚引用和弱引用：每次垃圾回收的时候，都会被干掉，但是它在干掉之前还会存在引用队列中，我们可以通过引用队列进行一些通知机制</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104722.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_JVM参数调优</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/2-JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/2-JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="2-JVM参数调优"><a href="#2-JVM参数调优" class="headerlink" title="2_JVM参数调优"></a>2_JVM参数调优</h1><blockquote><p>题目2：你说你做过JVM调优和参数配置，请问如何盘点查看 <code>JVM系统默认值</code>？</p></blockquote><p>使用 jps 和 jinfo 进行查看</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 调整JVM初始化参数（-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收）</span></span><br><span class="line">-Xms：初始堆空间</span><br><span class="line">-Xmx：堆最大值</span><br><span class="line">-Xss：栈空间</span><br></pre></td></tr></table></figure><hr><h2 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h2><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><blockquote><p>从JDK1.0 - Java12都在，很稳定</p></blockquote><ul><li>-version</li><li>-help</li><li>java -showversion</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104624.png"></p><hr><h3 id="X参数（了解）"><a href="#X参数（了解）" class="headerlink" title="X参数（了解）"></a>X参数（了解）</h3><ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104625.png"></p><hr><h3 id="XX参数（重点）"><a href="#XX参数（重点）" class="headerlink" title="XX参数（重点）"></a><font color='red'>XX参数（重点）</font></h3><h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><blockquote><p>公式：</p><ul><li>-XX:+ 或者-某个属性</li><li>+表示开启，-表示关闭</li></ul></blockquote><hr><h5 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h5><blockquote><p>-XX:-PrintGCDetails：表示关闭了GC详情输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps：查看java的后台进程</span><br><span class="line">jinfo：查看正在运行的java程序</span><br></pre></td></tr></table></figure><p><strong>查看运行的Java程序，JVM参数是否开启，具体值为多少？</strong></p></blockquote><p>首先我们运行一个HelloGC的 Java 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-27 13:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello GC&quot;</span>);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104626.png"></p><hr><p>然后查看java的后台进程：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 得到进程号</span></span><br><span class="line">jps -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104627.png"></p><hr><p>然后查看是否开启PrintGCDetails这个参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># + 表示开启，-号 表示没开启</span></span><br><span class="line">jinfo -flag PrintGCDetails 9936</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104628.png"></p><p>结果表明：-号表示关闭，即没有开启PrintGCDetails这个参数</p><hr><p>最后：需要在启动HelloGC的时候，增加 PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104629.png"></p><p>在VM Options中加入下面的代码，现在+号表示开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104630.png"></p><hr><p>重启启动程序，使用 <code>jps -l</code>得到进程号，使用<code>jinfo -flag PrintGCDetails 进程号</code>得到配置结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104631.png"></p><p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p><hr><p>也可以使用下列命令，会把jvm的全部默认参数输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags 进程号</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104632.png"></p><hr><h4 id="KV设值类型"><a href="#KV设值类型" class="headerlink" title="KV设值类型"></a>KV设值类型</h4><blockquote><p>-XX:属性key=值value</p></blockquote><h5 id="Case-1"><a href="#Case-1" class="headerlink" title="Case"></a>Case</h5><blockquote><p>-XX:MetaspaceSize=128m   调整元空间大小</p><p>-XX:MaxTenuringThreshold=15  调整存活年龄</p></blockquote><p>还是刚刚那个程序，首先我们查看默认的元空间大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看进程号</span></span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看默认空间（此时是键值对类型）</span></span><br><span class="line">jinfo -flag MetaspaceSize 11080</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104633.png"></p><hr><p>配置元空间大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 配置元空间大小为1024m</span></span><br><span class="line">-XX:MetaspaceSize=1024m</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104634.png"></p><p>重新启动程序，查看：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104635.png"></p><p>配置生效！</p><hr><p>同样操作：配置存活年龄</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold&#x3D;10</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104636.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104637.png"></p><hr><h4 id="jinfo：如何查看当前程序运行的配置"><a href="#jinfo：如何查看当前程序运行的配置" class="headerlink" title="jinfo：如何查看当前程序运行的配置"></a><font color='red'>jinfo：如何查看当前程序运行的配置</font></h4><blockquote><p>jinfo -flag 某个参数 pid </p><p>或者</p><p>jinfo -flags pid 显示所有参数</p></blockquote><h5 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看堆内存初始化大小</span></span><br><span class="line">jinfo -flag InitialHeapSize  15276</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104638.png"></p><hr><h5 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看全部配置信息</span></span><br><span class="line">jinfo -flags 15276</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 结果：</span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=<span class="number">12</span> -XX:InitialHeapSize=<span class="number">268435456</span> -XX:MaxHeapSize=<span class="number">4278190080</span> -XX:MaxNewSize=<span class="number">1426063360</span></span><br><span class="line">-XX:MetaspaceSize=<span class="number">1073741824</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">89128960</span> -XX:OldSize=<span class="number">179306496</span> -XX:+</span><br><span class="line">UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndivi</span><br><span class="line">dualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><hr><h4 id="题外话（坑题）"><a href="#题外话（坑题）" class="headerlink" title="题外话（坑题）"></a><font color='red'>题外话（坑题）</font></h4><blockquote><p>两个经典参数：<code>-Xms </code>和 <code>-Xmx</code>，这两个参数 如何解释？</p></blockquote><p>这两个参数，还是属于XX参数，因为取了别名</p><ul><li>-Xms 等价于 -XX:InitialHeapSize ：初始化堆内存（默认只会用最大物理内存的64分1）</li><li>-Xmx 等价于 -XX:MaxHeapSize ：最大堆内存（默认只会用最大物理内存的4分1）</li></ul><hr><p>与机器本身配置有关：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104639.png"></p><p>我们进行重新配置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 设置初始化大小200m，最大3g</span></span><br><span class="line">-Xms200m -Xmx3g</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104640.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104641.png"></p><hr><h4 id="查看JVM默认参数"><a href="#查看JVM默认参数" class="headerlink" title="查看JVM默认参数"></a>查看JVM默认参数</h4><blockquote><p>-XX:+PrintFlagsInitial</p></blockquote><h5 id="方式一：查看初始默认值"><a href="#方式一：查看初始默认值" class="headerlink" title="方式一：查看初始默认值"></a>方式一：查看<code>初始默认值</code></h5><blockquote><p>公式：</p><ul><li>java -XX:+PrintFlagsInitial -version</li><li>java -XX:+PrintFlagsInitial（重要参数）</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104642.png"></p><hr><h5 id="方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）"><a href="#方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）" class="headerlink" title="方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）"></a>方式二：<code>查看修改后的，最终的值</code>（可能是JVM，也可能是人为修改）</h5><blockquote><p>公式：</p><ul><li>-XX:+PrintFlagsFinal -version</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104643.png"></p><p>会将JVM的各个结果都进行打印</p><p><font color='red'>如果有 := 表示修改过的， = 表示没有修改过的</font></p><p>以初始化堆内存为例：我的机器是16G内存，所以JVM会划内存的1/64给堆初始化，即270m左右</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104644.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104645.png"></p><p>实例2：运行java<strong>命令的同时打印出参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -Xss128k javaClass</span><br></pre></td></tr></table></figure><hr><h5 id="方式三：查看一些常见的参数"><a href="#方式三：查看一些常见的参数" class="headerlink" title="方式三：查看一些常见的参数"></a><font color='red'>方式三：查看一些<code>常见的参数</code></font></h5><blockquote><p> -XX:+PrintCommandLineFlags</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104646.png"></p><p>该命令主要是用来查看当前使用的垃圾回收器</p><hr><h2 id="工作中常用的JVM基本配置参数"><a href="#工作中常用的JVM基本配置参数" class="headerlink" title="工作中常用的JVM基本配置参数"></a>工作中常用的JVM基本配置参数</h2><blockquote><p>题目3：用过的JVM常用基本配置参数有哪些？</p></blockquote><p>知识复习：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104647.png"></p><hr><h3 id="查看堆内存"><a href="#查看堆内存" class="headerlink" title="查看堆内存"></a>查看堆内存</h3><blockquote><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p></blockquote><p>代码方式查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-27 13:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中内存的总量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回Java虚拟机中试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="string">&quot;(字节)、&quot;</span> + (totalMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="string">&quot;(字节)、&quot;</span> + (maxMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104648.png"></p><p>-Xms 初始堆内存为：物理内存的1/64 -Xmx 最大堆内存为：系统物理内存的 1/4</p><hr><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><h4 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h4><blockquote><p>-Xms：<code>初始化堆内存</code>，默认为物理内存的1/64，</p><p>等价于 -XX:initialHeapSize</p></blockquote><hr><h4 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h4><blockquote><p>-Xmx：<code>最大堆内存</code>，默认为物理内存的1/4，</p><p>等价于-XX:MaxHeapSize</p></blockquote><hr><h4 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h4><blockquote><p>-Xss：设计<code>单个线程栈的大小</code>，一般默认为512K~1024K，</p><p>等价于 -XX:ThreadStackSize</p></blockquote><p>使用 jinfo -flag ThreadStackSize 会发现 -XX:ThreadStackSize = 0</p><p>原因：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 官网解释（JDK8）</span></span><br><span class="line">Linux/x64:1024KB</span><br><span class="line">OS X：1024KB</span><br><span class="line">Oracle Solaris：1024KB</span><br><span class="line">Windows：取决于虚拟内存的大小</span><br></pre></td></tr></table></figure><hr><h4 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h4><blockquote><p>设置<code>元空间大小</code>。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。</p><p>元空间与永久代的最大区别在于，永久代在虚拟机中（占用堆内存），而元空间在本地内存中（占用物理内存）。</p><p>为了防止在频繁的实例化对象的时候，让元空间出现OOM，因此可以把元空间设置的大一些</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看默认配置大小(大约21m)</span></span><br><span class="line">java -XX:+PrintFlagsFinal -version</span><br><span class="line"></span><br><span class="line"><span class="section"># 设置元空间大小</span></span><br><span class="line">-XX:+MetaspaceSize=1024m</span><br></pre></td></tr></table></figure><hr><h4 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a><font color='red'>-XX:+PrintGCDetails</font></h4><blockquote><p>输出GC收集<code>日志信息</code></p><p>分为：</p><ul><li>GC</li><li>Full GC</li></ul></blockquote><p>我们使用一段代码，制造出垃圾回收的过程</p><p>首先我们设置一下程序的启动配置: 设置初始堆内存为10M，最大堆内存为10M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>然后用下列代码，创建一个 非常大空间的byte类型数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte [] byteArray &#x3D; new byte[50 * 1024 * 1024];</span><br></pre></td></tr></table></figure><p>运行后，发现会出现下列错误，这就是OOM：<code>java内存溢出，也就是堆空间不足</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104649.png"></p><p>同时还打印出了GC垃圾回收时候的详情</p><p>问题发生的原因：因为们通过 -Xms10m 和 -Xmx10m 只给Java堆栈设置了10M的空间，但是创建了50M的对象，因此就会出现空间不足，而导致出错</p><p>同时在垃圾收集的时候，我们看到有两个对象：GC 和 Full GC</p><hr><h6 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h6><blockquote><p>GC垃圾回收发生在<code>新生代</code>。</p></blockquote><hr><p><strong>参数图：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104650.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># GC信息（GC (Allocation Failure)：表示分配失败，那么就需要触发年轻代空间中的内容被回收）</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1580K-&gt;504K(2560K)] 1580K-&gt;764K(9728K), 0.0167268 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] </span><br></pre></td></tr></table></figure><hr><h6 id="Full-GC垃圾回收"><a href="#Full-GC垃圾回收" class="headerlink" title="Full GC垃圾回收"></a>Full GC垃圾回收</h6><blockquote><p>Full GC大部分发生在<code>养老区</code></p></blockquote><p><strong>参数图：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104651.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Full GC</span></span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 592K-&gt;574K(7168K)] 592K-&gt;574K(9728K), [Metaspace: 3158K-&gt;3158K(1056768K)], 0.0040996 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br></pre></td></tr></table></figure><hr><p><font color='red'>规律：</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[名称： GC前内存占用 -&gt; GC后内存占用 (该区内存总大小)]</span><br></pre></td></tr></table></figure><p><font color='red'>当我们出现了老年代都扛不住的时候，就会出现OOM异常</font></p><hr><h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><p>VM综合配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss1024k -Xms200m -Xmx4g -XX:MetaspaceSize&#x3D;1024m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><ul><li>-Xss1024k  栈大小</li><li>-Xms200m  堆初始化大小</li><li>-Xmx4g   堆最大值</li><li>-XX:MetaspaceSize=1024m  元空间大小</li><li>-XX:+PrintCommandLineFlags  打印常用配置</li><li>-XX:+PrintGCDetails   打印日志信息</li><li>-XX:+UseSerialGC   使用垃圾回收器的名称（串行回收器）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104652.png"></p><hr><h4 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h4><blockquote><p>调节新生代中<code> eden 和 S0、S1的空间比例，</code></p></blockquote><p>默认为 -XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104653.png"></p><p>我们设置如下参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 分配堆内存为10m（此时新生代大约占2~3m）</span></span><br><span class="line">-Xms10m -Xmx10m  -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><hr><p>假如设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p><p>SurvivorRatio值就是设置eden区的比例占多少？S0和S1相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m  -XX:+PrintGCDetails -XX:SurvivorRatio&#x3D;4</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104654.png"></p><hr><h4 id="XX-NewRatio（了解）"><a href="#XX-NewRatio（了解）" class="headerlink" title="-XX:NewRatio（了解）"></a>-XX:NewRatio（了解）</h4><blockquote><p>配置<code>年轻代new 和老年代old 在堆结构的占比</code></p><p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p></blockquote><p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p><p><font color='orange'>新生代特别小，会造成频繁的进行GC收集</font></p><hr><h4 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h4><blockquote><p>设置<code>垃圾最大年龄</code></p><p>SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代。</p><p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看默认进入老年代年龄：</span></span><br><span class="line">jinfo -flag MaxTenuringThreshold 进程号</span><br><span class="line"></span><br><span class="line"><span class="section"># 设置年龄：</span></span><br><span class="line"> -XX:MaxTenuringThreshold=15</span><br></pre></td></tr></table></figure><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_GC Roots分析</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/1-GC-Roots%E5%88%86%E6%9E%90/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/1-GC-Roots%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-GC-Roots分析"><a href="#1-GC-Roots分析" class="headerlink" title="1_GC Roots分析"></a>1_GC Roots分析</h1><blockquote><p>题目1：JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots</p></blockquote><hr><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><blockquote><p>简单来说就是：内存中已经不再被使用的空间就是垃圾</p></blockquote><hr><h2 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><del>引用计数法</del></h3><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收</p><p>简单说，给对象中添加一个<code>引用计数器</code>，每当有一个地方引用它，计数器值加1，每当有一个引用失效，计数器值减1，任何时刻计数器值<code>为零</code>的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104521.png"></p><p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它<code>很难解决对象之间相互循环引用的问题</code>。该算法存在但目前无人用了，解决不了循环引用的问题，了解即可。</p><hr><h3 id="枚举根节点做可达性分析"><a href="#枚举根节点做可达性分析" class="headerlink" title="枚举根节点做可达性分析"></a>枚举根节点做可达性分析</h3><blockquote><p><code>根搜索路径算法</code>：为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法</p><p>所谓 GC Roots 或者说 Tracing Roots的“根集合” 就是<font color='red'>一组必须活跃的引用 </font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104522.png"></p><p>基本思路：就是通过<font color='red'>一系列名为 GC Roots的对象作为起始点</font>，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的对象就被判定为死亡</p><hr><p><strong>举例1说明：</strong></p><blockquote><p>必须从<code>GC Roots对象</code>开始，这个类似于linux的 / 也就是根目录：</p><ul><li>蓝色部分是从GC Roots出发，能够循环可达</li><li>而白色部分未从GC Roots出发，无法到达</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104523.png"></p><hr><p><strong>举例2说明：</strong></p><blockquote><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p></blockquote><p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p><p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p><p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p><hr><h2 id="哪些对象可以当做GC-Roots"><a href="#哪些对象可以当做GC-Roots" class="headerlink" title="哪些对象可以当做GC Roots"></a>哪些对象可以当做GC Roots</h2><ul><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li><li>本地方法栈中的JNI（Native方法）的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><hr><p> <strong>代码说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Java中，可以作为GC Roots的对象有：</span></span><br><span class="line"><span class="comment"> * - 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</span></span><br><span class="line"><span class="comment"> * - 方法区中的类静态属性引用的对象</span></span><br><span class="line"><span class="comment"> * - 方法区中常量引用的对象</span></span><br><span class="line"><span class="comment"> * - 本地方法栈中的JNI（Native方法）的引用对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法区中的类静态属性引用的对象</span></span><br><span class="line">    <span class="comment">// private static GCRootDemo2 t2;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span></span><br><span class="line">    <span class="comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种，虚拟机栈中的引用对象</span></span><br><span class="line">        GCRootDemo t1 = <span class="keyword">new</span> GCRootDemo();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0_JVM体系结构</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/0-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/0-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="0-JVM体系结构"><a href="#0-JVM体系结构" class="headerlink" title="0_JVM体系结构"></a>0_JVM体系结构</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104258.jpg"></p><hr><p>Java gc 主要回收的是 <strong>方法区</strong> 和 <strong>堆</strong> 中的内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104259.png"></p><hr><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>常考考点：</p><ul><li>类加载器是什么</li><li>双亲委派机制</li><li>Java类加载的沙箱安全机制</li></ul><hr><h2 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a><del>引用计数</del></h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104300.png"></p><hr><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><blockquote><p>复制算法在<code>年轻代</code>的时候，进行使用，复制时候有交换</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104301.png"></p><p>优点：没有内存碎片</p><p>缺点：消耗内存</p><hr><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><blockquote><p>先标记，后清除。用于<code>老年代</code>多一些</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104302.png"></p><p>优点：不会消耗那么多内存</p><p>缺点：会产生内存碎片</p><hr><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><blockquote><p>也叫标记清除整理，多用于<code>老年代</code></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104303.png"></p><p>优点：不会消耗太多内存；不会有内存碎片</p><p>缺点：比较耗时</p><hr><p>总结：没有完美的算法，只有合适的算法，一般采用<code>分代收集算法</code></p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux诊断原因</title>
      <link href="2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Linux/Linux%E8%AF%8A%E6%96%AD%E5%8E%9F%E5%9B%A0/"/>
      <url>2021/02/17/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Linux/Linux%E8%AF%8A%E6%96%AD%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux诊断原因"><a href="#Linux诊断原因" class="headerlink" title="Linux诊断原因"></a>Linux诊断原因</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><blockquote><p>问题9：生产环境服务器变慢，诊断思路和性能评估谈谈？</p></blockquote><p>运行服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xms xxx参数名字 -jar </span><br></pre></td></tr></table></figure><hr><h3 id="top：查看整机系统新能"><a href="#top：查看整机系统新能" class="headerlink" title="top：查看整机系统新能"></a>top：查看整机系统新能</h3><blockquote><ul><li>load average三个指标：分别代表1、5、15分钟的负载情况</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104152.png"></p><p>重点关注的是 %CPU、%MEM 、load average 三个指标</p><p>在这个命令下，按1的话，可以看到每个CPU的占用情况</p><hr><h3 id="uptime精简版"><a href="#uptime精简版" class="headerlink" title="uptime精简版"></a>uptime精简版</h3><blockquote><p>系统性能命令的精简版</p></blockquote><hr><h3 id="CPU：vmstat"><a href="#CPU：vmstat" class="headerlink" title="CPU：vmstat"></a>CPU：vmstat</h3><blockquote><p>查看CPU（包含但是不限于）</p><p>查看额外</p><ul><li>查看所有CPU核信息：mpstat -p ALL 2</li><li>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</li></ul></blockquote><hr><p>命令格式：<code>vmstat -n 2 3</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104153.png"></p><p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数（单位秒），第二个参数是采样的次数</p><p><strong>procs</strong></p><ul><li> r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了2，说明现在压力过大</li><li> b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等</li></ul><p><strong>cpu</strong></p><ul><li> us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序</li><li> sy：内核进程消耗的CPU时间百分比</li><li> us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明CPU消耗不是很高</li><li> id：处于空闲的CPU百分比</li><li> wa：系统等待IO的CPU时间百分比</li><li> st：来自于一个虚拟机偷取的CPU时间比</li></ul><hr><h3 id="内存：free"><a href="#内存：free" class="headerlink" title="内存：free"></a>内存：free</h3><p>应用程序可用内存数：free -m</p><ul><li>应用程序可用内存/系统物理内存 &gt; 70% 内存充足</li><li>应用程序可用内存/系统物理内存 &lt; 20% 内存不足，需要增加内存</li><li>20% &lt; 应用程序可用内存/系统物理内存 &lt; 70%，表示内存基本够用</li></ul><hr><p>free -h：以人类能看懂的方式查看物理内存</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104154.png"></p><hr><p>free -m：以MB为单位，查看物理内存</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104155.png"></p><hr><p>free -g：以GB为单位，查看物理内存</p><hr><h3 id="硬盘：df"><a href="#硬盘：df" class="headerlink" title="硬盘：df"></a>硬盘：df</h3><blockquote><p>格式：<code>df -h /</code> (-h：human，表示以人类能看到的方式换算)</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104156.png"></p><hr><h3 id="硬盘IO：iostat"><a href="#硬盘IO：iostat" class="headerlink" title="硬盘IO：iostat"></a>硬盘IO：iostat</h3><blockquote><p>系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作</p></blockquote><p>格式：<code>iostat -xdk 2 3</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104157.png" alt="image-20200326170522559"></p><p>磁盘块设备分布：</p><ul><li>rkB /s：每秒读取数据量kB；</li><li>wkB/s：每秒写入数据量kB；</li><li>svctm I/O：请求的平均服务时间，单位毫秒</li><li>await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好</li><li>util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘；</li><li>rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</li><li>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘</li></ul><hr><h3 id="网络IO：ifstat"><a href="#网络IO：ifstat" class="headerlink" title="网络IO：ifstat"></a>网络IO：ifstat</h3><blockquote><p>默认本地没有，下载ifstat</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104158.png"></p><hr><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><blockquote><p>问题10：假如生产环境CPU占用过高，谈谈分析思路和定位？</p></blockquote><p>分析步骤：</p><ol><li><p>先用top命令找出CPU占比最高的进程</p></li><li><p>ps -ef或者jps查看进程编号</p></li><li><p>定位到具体的线程或者代码</p><blockquote><p>ps -mp 进程 -o THREAD，tid，time</p><p>参数：</p><ul><li>-m：显示所有的线程</li><li>-p：pid进程使用CPU的时间</li><li>-o：该参数后是用户自定义格式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104159.png"></p></blockquote></li><li><p>将线程的id转换为16进制</p><blockquote><p>printf “%x\n” 有问题的线程ID</p></blockquote></li><li><p>jstack 线程id | grep tid （16进制） 得到java程序详细信息，定位到第几行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104200.png"></p><hr></li></ol><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><blockquote><p>问题11：对于JDK自带的JVM监控和性能分析工具用过哪些？一般怎么用的？</p></blockquote><ul><li>jps 进程状态工具</li><li>jinfo java配置信息工具</li><li>jmap 内存映像工具</li><li>jstat 统计信息监视工具</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10_Docker 私有仓库</title>
      <link href="2021/02/17/Docker/10-Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
      <url>2021/02/17/Docker/10-Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="10-Docker-私有仓库"><a href="#10-Docker-私有仓库" class="headerlink" title="10_Docker 私有仓库"></a>10_Docker 私有仓库</h1><p>Docker官方的Docker hub（<a href="https://hub.docker.com)是一个用于管理公共镜像的仓库,我们可以从上面拉/">https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉</a> 取镜像 到本地，也可以把我们自己的镜像推送上去。但是，有时候我们不希望将自己的镜 像放到公网当中， 那么这时我们就需要搭建自己的私有仓库来存储和管理自己的镜像 </p><h2 id="私有仓库搭建"><a href="#私有仓库搭建" class="headerlink" title="私有仓库搭建"></a>私有仓库搭建</h2><p><strong>步骤：</strong></p><h3 id="1、拉取私有仓库镜像"><a href="#1、拉取私有仓库镜像" class="headerlink" title="1、拉取私有仓库镜像"></a>1、拉取私有仓库镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><h3 id="2、启动私有仓库容器"><a href="#2、启动私有仓库容器" class="headerlink" title="2、启动私有仓库容器"></a>2、启动私有仓库容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure><h3 id="3、访问仓库"><a href="#3、访问仓库" class="headerlink" title="3、访问仓库"></a>3、访问仓库</h3><p>打开浏览器 输入地址：http://私有仓库服务器ip:5000/v2/_catalog，看到{“repositories”:[]} 表示私有仓 库 搭建成功 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102238.png"></p><h3 id="4、修改-daemon-json"><a href="#4、修改-daemon-json" class="headerlink" title="4、修改 daemon.json"></a>4、修改 daemon.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p># 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器 ip 修改为自 己私有仓库服务器真实 ip </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125;</span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.220.12:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102239.png"></p><p><strong>我的文件源码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;y1ye9vg6.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;:[&quot;192.168.77.138:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、重启docker-服务"><a href="#5、重启docker-服务" class="headerlink" title="5、重启docker 服务"></a>5、重启docker 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker </span><br></pre></td></tr></table></figure><h3 id="6、重启-私有仓库容器"><a href="#6、重启-私有仓库容器" class="headerlink" title="6、重启 私有仓库容器"></a>6、重启 私有仓库容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure><hr><h2 id="将镜像上传至私有仓库"><a href="#将镜像上传至私有仓库" class="headerlink" title="将镜像上传至私有仓库"></a>将镜像上传至私有仓库</h2><p>下面以 上传 nginx 镜像为例，</p><h3 id="1、标记镜像为私有仓库的镜像"><a href="#1、标记镜像为私有仓库的镜像" class="headerlink" title="1、标记镜像为私有仓库的镜像"></a>1、标记镜像为私有仓库的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><h3 id="2、上传标记的镜像"><a href="#2、上传标记的镜像" class="headerlink" title="2、上传标记的镜像"></a>2、上传标记的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><h3 id="3、查看私有仓库"><a href="#3、查看私有仓库" class="headerlink" title="3、查看私有仓库"></a>3、查看私有仓库</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102240.png"></p><hr><h2 id="从私有仓库拉取镜像"><a href="#从私有仓库拉取镜像" class="headerlink" title="从私有仓库拉取镜像"></a>从私有仓库拉取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9_服务编排</title>
      <link href="2021/02/17/Docker/9-%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/"/>
      <url>2021/02/17/Docker/9-%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1 id="9-服务编排"><a href="#9-服务编排" class="headerlink" title="9_服务编排"></a>9_服务编排</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启 动停止，维护的工作量会很大。来看下我们日常工作：</p><ul><li>要从Dockerfile build image 或者去 dockerhub 拉取 image </li><li>要创建多个 container </li><li>要管理这些 container（启动停止删除）</li></ul><p>通过服务编排可以大量简化上面的工作服务编排：<strong>按照一定的业务规则批量管理容器</strong></p><hr><h2 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h2><p>Docker Compose 是一个编排多容器分布式部署的工具，提供命令集中管理容器化应用的完整开发周期，包括服务 构建，启动和停止。使用步骤：</p><ol><li>利用 Dockerfile 定义运行环境镜像 </li><li>使用 docker-compose.yml 定义组成应用的各服务 </li><li>运行 docker-compose up 启动应用</li></ol><h3 id="1-安装-Docker-Compose"><a href="#1-安装-Docker-Compose" class="headerlink" title="1. 安装 Docker Compose"></a>1. 安装 Docker Compose</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.8.0&#x2F;run.sh &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="2-设置文件可执行权限"><a href="#2-设置文件可执行权限" class="headerlink" title="2. 设置文件可执行权限"></a>2. 设置文件可执行权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="3-查看版本信息"><a href="#3-查看版本信息" class="headerlink" title="3. 查看版本信息"></a>3. 查看版本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><h3 id="4-卸载-Docker-Compose"><a href="#4-卸载-Docker-Compose" class="headerlink" title="4. 卸载 Docker Compose"></a>4. 卸载 Docker Compose</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><hr><h2 id="编排-nginx-springboot"><a href="#编排-nginx-springboot" class="headerlink" title="编排 nginx+springboot"></a>编排 nginx+springboot</h2><p>安装之前的做法，我们需要使用先启动 nginx 容器 ，再启动 app 项目容器</p><p>现在我们使用 docker-compose 进行管理编排，让它帮我们进行启动、停止或者删除</p><p><strong>需求：</strong>  使用 nginx 做反向代理，当我们 访问 192.168.77.130:80 时，映射到 app 容器</p><h4 id="1-创建-docker-compose目录"><a href="#1-创建-docker-compose目录" class="headerlink" title="1. 创建 docker-compose目录"></a>1. 创建 docker-compose目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;docker-compose </span><br><span class="line">cd ~&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h4 id="2-编写-docker-compose-yml-文件"><a href="#2-编写-docker-compose-yml-文件" class="headerlink" title="2.编写 docker-compose.yml 文件"></a>2.编写 docker-compose.yml 文件</h4><p>编排 nginx 和 app 两个服务 ，nginx 服务使用到 nginx 镜像，当访问到 80 端口时，映射到 容器的 80 端口，同时链接到app ，对 nginx 配置文件进行挂载 [ 注意这里 conf.d 是目录 ]，而 app  服务需要使用到 app 镜像，同时暴露容器端口 80 </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line">   <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;80&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-创建-nginx-conf-d目录"><a href="#3-创建-nginx-conf-d目录" class="headerlink" title="3.创建./nginx/conf.d目录"></a>3.创建./nginx/conf.d目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p .&#x2F;nginx&#x2F;conf.d</span><br></pre></td></tr></table></figure><h4 id="4-在-nginx-conf-d目录下-编写app-conf文件"><a href="#4-在-nginx-conf-d目录下-编写app-conf文件" class="headerlink" title="4. 在./nginx/conf.d目录下 编写app.conf文件"></a>4. 在./nginx/conf.d目录下 编写app.conf文件</h4><p>当 nginx 监听其他主机访问 80 端口时，进行代理转发到  <a href="http://app/test">http://app:80/test</a></p><p>这里的 app 指 app 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;app:80&#x2F;test;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-在-docker-compose-目录下-使用docker-compose-启动容器"><a href="#5-在-docker-compose-目录下-使用docker-compose-启动容器" class="headerlink" title="5. 在~/docker-compose 目录下 使用docker-compose 启动容器"></a>5. 在~/docker-compose 目录下 使用docker-compose 启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d # -d表示已守护模式启动</span><br></pre></td></tr></table></figure><h4 id="6-测试访问"><a href="#6-测试访问" class="headerlink" title="6.测试访问"></a>6.测试访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:80</span><br></pre></td></tr></table></figure><p>当然，80 端口也可以省略</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102124.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8_本地镜像发布到阿里云</title>
      <link href="2021/02/17/Docker/8-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/"/>
      <url>2021/02/17/Docker/8-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h1 id="8-本地镜像发布到阿里云"><a href="#8-本地镜像发布到阿里云" class="headerlink" title="8_本地镜像发布到阿里云"></a>8_本地镜像发布到阿里云</h1><h2 id="本地镜像发布到阿里云流程"><a href="#本地镜像发布到阿里云流程" class="headerlink" title="本地镜像发布到阿里云流程"></a>本地镜像发布到阿里云流程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102008.png"></p><h2 id="镜像的生成方法"><a href="#镜像的生成方法" class="headerlink" title="镜像的生成方法"></a>镜像的生成方法</h2><h3 id="1、前面的-DockerFile"><a href="#1、前面的-DockerFile" class="headerlink" title="1、前面的 DockerFile"></a>1、前面的 DockerFile</h3><h3 id="2、从容器创建一个新的镜像"><a href="#2、从容器创建一个新的镜像" class="headerlink" title="2、从容器创建一个新的镜像"></a>2、从容器创建一个新的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102009.png"></p><h3 id="3、将本地镜像推送到阿里云"><a href="#3、将本地镜像推送到阿里云" class="headerlink" title="3、将本地镜像推送到阿里云"></a>3、将本地镜像推送到阿里云</h3><h4 id="本地镜像素材原型"><a href="#本地镜像素材原型" class="headerlink" title="本地镜像素材原型"></a>本地镜像素材原型</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102010.png"></p><h4 id="阿里云开发者平台"><a href="#阿里云开发者平台" class="headerlink" title="阿里云开发者平台"></a>阿里云开发者平台</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;cn-hangzhou&#x2F;instances&#x2F;repositories</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102011.png"></p><h4 id="创建仓库镜像"><a href="#创建仓库镜像" class="headerlink" title="创建仓库镜像"></a>创建仓库镜像</h4><p>命名空间 + 仓库名称</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102012.png"></p><h4 id="将镜像推送到-registry"><a href="#将镜像推送到-registry" class="headerlink" title="将镜像推送到 registry"></a>将镜像推送到 registry</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102013.png" alt="image-20201111183221165"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102014.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102015.png"></p><h4 id="公有云可以查询到"><a href="#公有云可以查询到" class="headerlink" title="公有云可以查询到"></a>公有云可以查询到</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102016.png" alt="image-20201111183454166"></p><h4 id="查看详情"><a href="#查看详情" class="headerlink" title="查看详情"></a>查看详情</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102017.png" alt="image-20201111183544458"></p><h3 id="4、下载到本地"><a href="#4、下载到本地" class="headerlink" title="4、下载到本地"></a>4、下载到本地</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102018.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装ElasticSearch 6.8.0</title>
      <link href="2021/02/17/Docker/Docker-%E5%AE%89%E8%A3%85ElasticSearch-6-8-0/"/>
      <url>2021/02/17/Docker/Docker-%E5%AE%89%E8%A3%85ElasticSearch-6-8-0/</url>
      
        <content type="html"><![CDATA[<h1 id="12-Docker-安装ElasticSearch-6-8-0"><a href="#12-Docker-安装ElasticSearch-6-8-0" class="headerlink" title="12_Docker 安装ElasticSearch 6.8.0"></a>12_Docker 安装ElasticSearch 6.8.0</h1><h4 id="1、拉取镜像"><a href="#1、拉取镜像" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:6.8.0</span><br></pre></td></tr></table></figure><h4 id="2、修改系统配置参数"><a href="#2、修改系统配置参数" class="headerlink" title="2、修改系统配置参数"></a>2、修改系统配置参数</h4><p>elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优</p><p>进入配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br></pre></td></tr></table></figure><p>追加内容 (nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制 ) </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure><p>进入配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><p>限制一个进程可以拥有的VMA(虚拟内存区域)的数量，末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;655360</span><br></pre></td></tr></table></figure><p>使配置生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>重启虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><hr><h4 id="3、启动容器"><a href="#3、启动容器" class="headerlink" title="3、启动容器"></a>3、启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;es -p 9200:9200 -p 9300:9300 elasticsearch:6.8.0</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 9200端口(Web管理平台端口) 9300(服务默认端口，kibana客户端或者集群节点之间交流时用该端口) </p><h4 id="4、访问ElasticSearch"><a href="#4、访问ElasticSearch" class="headerlink" title="4、访问ElasticSearch"></a>4、访问ElasticSearch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:9200</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101921.png"></p><p>代表ES启动成功！</p><hr><h4 id="5、远程访问"><a href="#5、远程访问" class="headerlink" title="5、远程访问"></a>5、远程访问</h4><p>虽然ES启动了，但是不能远程进行访问，，elasticsearch从5版本以后默认不开启远程连接，需要我们进行开启</p><p><strong>（1）登录容器</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it es &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><strong>（2）修改配置文件</strong></p><p>进入配置文件所在目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd configls</span><br></pre></td></tr></table></figure><p>vi命令无法识别，因为docker容器里面没有该命令，我们还需要安装该编辑器 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 集群名字</span><br><span class="line"># node.name: es</span><br><span class="line">cluster.name: &quot;cluster_es&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 允许elasticsearch跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line"># 示跨域访问允许的域名地址（表示任意）</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101922.png"></p><hr><p><strong>（3）重启容器</strong></p><p>ctrl + P+Q 退出容器（并未停止），重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><p><strong>（4）远程访问测试</strong></p><p>浏览器输入：[主机ip:web访问端口]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101923.png"></p><hr><h2 id="Head客户端安装"><a href="#Head客户端安装" class="headerlink" title="Head客户端安装"></a>Head客户端安装</h2><p>ElasticSearch不同于Solr自带图形化界面，我们可以通过安装ElasticSearch的head插件，完成图形化界面的效 </p><p>果，完成索引数据的查看。安装插件的方式有两种，在线安装和本地安装。本文档采用本地安装方式进行head插 </p><p>件的安装。elasticsearch-5-*以上版本安装head需要安装node和grunt </p><p><strong>windows下安装Head</strong></p><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>官网github地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head</span><br></pre></td></tr></table></figure><h4 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h4><h4 id="3、安装node"><a href="#3、安装node" class="headerlink" title="3、安装node"></a>3、安装node</h4><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;download&#x2F;</span><br></pre></td></tr></table></figure><p>完成后，控制台输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101924.png"></p><p>node安装成功！</p><h4 id="4、安装grunt"><a href="#4、安装grunt" class="headerlink" title="4、安装grunt"></a>4、安装grunt</h4><p>将grunt安装为全局命令 ，Grunt是基于Node.js的项目构建工具 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g grunt-cli</span><br></pre></td></tr></table></figure><p>cnpm 是换源的安装命令，如果你没有安装过cnpm可用选择使用npm</p><h4 id="5、启动Head"><a href="#5、启动Head" class="headerlink" title="5、启动Head"></a>5、启动Head</h4><p>进入elasticsearch-head-master目录启动head，进入cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt server</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101925.png"></p><h4 id="6、访问测试"><a href="#6、访问测试" class="headerlink" title="6、访问测试"></a>6、访问测试</h4><p>打开浏览器，输入 <a href="http://localhost:9100/">http://localhost:9100</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101926.png"></p><h4 id="7、连接ElasticSearch"><a href="#7、连接ElasticSearch" class="headerlink" title="7、连接ElasticSearch"></a>7、连接ElasticSearch</h4><p>在Head页面中输入ElasticSearch的访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101927.png"></p><p>至此，Head的安装就完成了！</p><hr><h2 id="Postman工具客户端"><a href="#Postman工具客户端" class="headerlink" title="Postman工具客户端"></a>Postman工具客户端</h2><p>依赖Restful接口进行访问</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; &#39;&lt;PROTOCOL&gt;:&#x2F;&#x2F;&lt;HOST&gt;:&lt;PORT&gt;&#x2F;&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#39; -d &#39;&lt;BODY&gt;&#39;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101928.png"></p><h4 id="创建索引index和映射mapping"><a href="#创建索引index和映射mapping" class="headerlink" title="创建索引index和映射mapping"></a>创建索引index和映射mapping</h4><p>地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;book</span><br></pre></td></tr></table></figure><p>请求体：访问格式必须是Json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;musicbook&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;name&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;price&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;double&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;desc&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;text&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101929.png"></p><hr><h4 id="创建索引后设置Mapping"><a href="#创建索引后设置Mapping" class="headerlink" title="创建索引后设置Mapping"></a>创建索引后设置Mapping</h4><p>我们可以在创建索引时设置mapping信息，当然也可以先创建索引然后再设置mapping</p><p>在上一个步骤中不设置maping信息，直接使用put方法创建一个索引，然后设置mapping信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT   http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems1&#x2F;emp&#x2F;_mapping </span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;musicbook&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;double&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;desc&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101930.png"></p><hr><h4 id="删除索引index"><a href="#删除索引index" class="headerlink" title="删除索引index"></a>删除索引index</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems1</span><br></pre></td></tr></table></figure><hr><h4 id="创建文档document"><a href="#创建文档document" class="headerlink" title="创建文档document"></a>创建文档document</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems&#x2F;emp&#x2F;1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;音乐书&quot;,</span><br><span class="line">  &quot;price&quot;:&quot;22.0&quot;,</span><br><span class="line">  &quot;desc&quot;:&quot;这是一本音乐书&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101931.png"></p><hr><h4 id="修改文档document"><a href="#修改文档document" class="headerlink" title="修改文档document"></a>修改文档document</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST   http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems&#x2F;emp&#x2F;1&#x2F;_update</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;price&quot;:&quot;40&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101932.png"></p><hr><h4 id="删除文档document"><a href="#删除文档document" class="headerlink" title="删除文档document"></a>删除文档document</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems&#x2F;emp&#x2F;1</span><br></pre></td></tr></table></figure><hr><h4 id="查询文档document"><a href="#查询文档document" class="headerlink" title="查询文档document"></a>查询文档document</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems&#x2F;emp&#x2F;1</span><br></pre></td></tr></table></figure><hr><h2 id="ElasticSearch安装IK分词器"><a href="#ElasticSearch安装IK分词器" class="headerlink" title="ElasticSearch安装IK分词器"></a>ElasticSearch安装IK分词器</h2><h4 id="1、下载安装包-1"><a href="#1、下载安装包-1" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>注意：下载版本需要和你的ElasticSearch版本一致</p><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases</span><br></pre></td></tr></table></figure><h4 id="2、解压-1"><a href="#2、解压-1" class="headerlink" title="2、解压"></a>2、解压</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 创建目录来保存解压后的文件</span></span><br><span class="line">mkdir IK</span><br><span class="line"></span><br><span class="line"><span class="section"># 解压[在IK中解压]</span></span><br><span class="line">unzip elasticsearch-analysis-ik-6.8.0.zip</span><br></pre></td></tr></table></figure><h4 id="3、拷贝IK目录到ES容器"><a href="#3、拷贝IK目录到ES容器" class="headerlink" title="3、拷贝IK目录到ES容器"></a>3、拷贝IK目录到ES容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  IK es:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</span><br></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><h4 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;_analyze</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;:&quot;中华人民共和国人民大会堂&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>IK分词器有两种标准：”ik_smart”表示粗粒度划分，”ik_max_word”表示细粒度划分</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101933.png"></p><hr><h2 id="Kibana-客户端"><a href="#Kibana-客户端" class="headerlink" title="Kibana 客户端"></a>Kibana 客户端</h2><p>Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可 以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。 </p><p>Kibana 可以使大数据通俗易懂。它很简单，基于浏览器的界面便于您快速创建和分享动态数据仪表板来追踪 </p><p>Elasticsearch 的实时数据变化。</p><h4 id="1、拉取镜像-1"><a href="#1、拉取镜像-1" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:6.8.0</span><br></pre></td></tr></table></figure><h4 id="2、启动容器"><a href="#2、启动容器" class="headerlink" title="2、启动容器"></a>2、启动容器</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 后台方式启动</span><br><span class="line">docker run  -id --name kibana -e ELASTICSEARCH_URL=http://192.168.77.138:9200 -p 5601:5601  kibana:6.8.0</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>ELASTICSEARCH_URL=<a href="http://192.168.220.100:9200：是指链接的ES地址">http://192.168.220.100:9200：是指链接的ES地址</a> </li><li>5601是kibana的默认端口</li></ul><h4 id="3、访问测试"><a href="#3、访问测试" class="headerlink" title="3、访问测试"></a>3、访问测试</h4><p>注意开启端口或者关闭防火墙</p><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:5601&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101934.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装 ElasticSearch 5.6.8</title>
      <link href="2021/02/17/Docker/Docker-%E5%AE%89%E8%A3%85-ElasticSearch-5-6-8/"/>
      <url>2021/02/17/Docker/Docker-%E5%AE%89%E8%A3%85-ElasticSearch-5-6-8/</url>
      
        <content type="html"><![CDATA[<h1 id="11-Docker-安装-ElasticSearch-5-6-8"><a href="#11-Docker-安装-ElasticSearch-5-6-8" class="headerlink" title="11_Docker 安装 ElasticSearch 5.6.8"></a>11_Docker 安装 ElasticSearch 5.6.8</h1><h4 id="1、拉取镜像"><a href="#1、拉取镜像" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:5.6.8</span><br></pre></td></tr></table></figure><h4 id="2、修改系统配置参数"><a href="#2、修改系统配置参数" class="headerlink" title="2、修改系统配置参数"></a>2、修改系统配置参数</h4><p>elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优</p><p>进入配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br></pre></td></tr></table></figure><p>追加内容 (nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制 ) </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure><p>进入配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><p>限制一个进程可以拥有的VMA(虚拟内存区域)的数量，末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;655360</span><br></pre></td></tr></table></figure><p>使配置生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>重启虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><hr><h4 id="3、启动容器"><a href="#3、启动容器" class="headerlink" title="3、启动容器"></a>3、启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;es -p 9200:9200 -p 9300:9300 elasticsearch:5.6.8</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 9200端口(Web管理平台端口) 9300(服务默认端口，kibana客户端或者集群节点之间交流时用该端口) </p><h4 id="4、访问ElasticSearch"><a href="#4、访问ElasticSearch" class="headerlink" title="4、访问ElasticSearch"></a>4、访问ElasticSearch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:9200</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101752.png"></p><p>代表ES启动成功！</p><hr><h4 id="5、远程访问"><a href="#5、远程访问" class="headerlink" title="5、远程访问"></a>5、远程访问</h4><p>虽然ES启动了，但是不能远程进行访问，，elasticsearch从5版本以后默认不开启远程连接，需要我们进行开启</p><p><strong>（1）登录容器</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it es &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><strong>（2）修改配置文件</strong></p><p>进入配置文件所在目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd configls</span><br></pre></td></tr></table></figure><p>vi命令无法识别，因为docker容器里面没有该命令，我们还需要安装该编辑器 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 设置apt下载源</span></span><br><span class="line">docker cp sources.list es:/etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>sources.list 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]&#x2F; xenial main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security multiverse</span><br></pre></td></tr></table></figure><p>进入es容器，安装vim编辑器 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 集群名字</span><br><span class="line"># node.name: es</span><br><span class="line">cluster.name: &quot;cluster_es&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 允许elasticsearch跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line"># 示跨域访问允许的域名地址（表示任意）</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101753.png"></p><hr><p><strong>（3）重启容器</strong></p><p>ctrl + P+Q 退出容器（并未停止），重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><p><strong>（4）远程访问测试</strong></p><p>浏览器输入：[主机ip:web访问端口]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101754.png"></p><hr><h2 id="Head客户端安装"><a href="#Head客户端安装" class="headerlink" title="Head客户端安装"></a>Head客户端安装</h2><p>ElasticSearch不同于Solr自带图形化界面，我们可以通过安装ElasticSearch的head插件，完成图形化界面的效 </p><p>果，完成索引数据的查看。安装插件的方式有两种，在线安装和本地安装。本文档采用本地安装方式进行head插 </p><p>件的安装。elasticsearch-5-*以上版本安装head需要安装node和grunt </p><p><strong>windows下安装Head</strong></p><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>官网github地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head</span><br></pre></td></tr></table></figure><h4 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h4><h4 id="3、安装node"><a href="#3、安装node" class="headerlink" title="3、安装node"></a>3、安装node</h4><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;download&#x2F;</span><br></pre></td></tr></table></figure><p>完成后，控制台输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101755.png"></p><p>node安装成功！</p><h4 id="4、安装grunt"><a href="#4、安装grunt" class="headerlink" title="4、安装grunt"></a>4、安装grunt</h4><p>将grunt安装为全局命令 ，Grunt是基于Node.js的项目构建工具 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g grunt-cli</span><br></pre></td></tr></table></figure><p>cnpm 是换源的安装命令，如果你没有安装过cnpm可用选择使用npm</p><h4 id="5、启动Head"><a href="#5、启动Head" class="headerlink" title="5、启动Head"></a>5、启动Head</h4><p>进入elasticsearch-head-master目录启动head，进入cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt server</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101756.png"></p><h4 id="6、访问测试"><a href="#6、访问测试" class="headerlink" title="6、访问测试"></a>6、访问测试</h4><p>打开浏览器，输入 <a href="http://localhost:9100/">http://localhost:9100</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101757.png"></p><h4 id="7、连接ElasticSearch"><a href="#7、连接ElasticSearch" class="headerlink" title="7、连接ElasticSearch"></a>7、连接ElasticSearch</h4><p>在Head页面中输入ElasticSearch的访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101758.png"></p><p>至此，Head的安装就完成了！</p><hr><h2 id="ElasticSearch安装IK分词器"><a href="#ElasticSearch安装IK分词器" class="headerlink" title="ElasticSearch安装IK分词器"></a>ElasticSearch安装IK分词器</h2><h4 id="1、下载安装包-1"><a href="#1、下载安装包-1" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>注意：下载版本需要和你的ElasticSearch版本一致</p><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases</span><br></pre></td></tr></table></figure><h4 id="2、解压-1"><a href="#2、解压-1" class="headerlink" title="2、解压"></a>2、解压</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 创建目录来保存解压后的文件</span></span><br><span class="line">mkdir IK</span><br><span class="line"></span><br><span class="line"><span class="section"># 解压[在IK中解压]</span></span><br><span class="line">unzip elasticsearch-analysis-ik-5.6.8.zip</span><br></pre></td></tr></table></figure><h4 id="3、拷贝IK目录到ES容器"><a href="#3、拷贝IK目录到ES容器" class="headerlink" title="3、拷贝IK目录到ES容器"></a>3、拷贝IK目录到ES容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  IK es:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</span><br></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><h4 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.211.132:9200&#x2F;_analyze?analyzer&#x3D;ik_max_word&amp;pretty&#x3D;true&amp;text&#x3D;中华人民共和国人民大会堂</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>IK分词器有两种标准：”ik_smart”表示粗粒度划分，”ik_max_word”表示细粒度划分</p><hr><h2 id="Kibana-客户端"><a href="#Kibana-客户端" class="headerlink" title="Kibana 客户端"></a>Kibana 客户端</h2><p>Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可 以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。 </p><p>Kibana 可以使大数据通俗易懂。它很简单，基于浏览器的界面便于您快速创建和分享动态数据仪表板来追踪 </p><p>Elasticsearch 的实时数据变化。</p><h4 id="1、拉取镜像-1"><a href="#1、拉取镜像-1" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io&#x2F;kibana:5.6.8</span><br></pre></td></tr></table></figure><h4 id="2、启动容器"><a href="#2、启动容器" class="headerlink" title="2、启动容器"></a>2、启动容器</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 后台方式启动</span><br><span class="line">docker run  -id --name kibana -e ELASTICSEARCH_URL=http://192.168.77.138:9200 -p 5601:5601  kibana:5.6.8</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>ELASTICSEARCH_URL=<a href="http://192.168.220.100:9200：是指链接的ES地址">http://192.168.220.100:9200：是指链接的ES地址</a> </li><li>5601是kibana的默认端口</li></ul><h4 id="3、访问测试"><a href="#3、访问测试" class="headerlink" title="3、访问测试"></a>3、访问测试</h4><p>注意开启端口或者关闭防火墙</p><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:5601&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101759.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7_Docker常用安装</title>
      <link href="2021/02/17/Docker/7-Docker%E5%B8%B8%E7%94%A8%E5%AE%89%E8%A3%85/"/>
      <url>2021/02/17/Docker/7-Docker%E5%B8%B8%E7%94%A8%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="7-Docker常用安装"><a href="#7-Docker常用安装" class="headerlink" title="7_Docker常用安装"></a>7_Docker常用安装</h1><h2 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h2><ul><li>搜索镜像</li><li>拉取镜像</li><li>查看镜像</li><li>启动镜像</li><li>停止容器</li><li>移除容器</li></ul><hr><h2 id="tomcat-部署"><a href="#tomcat-部署" class="headerlink" title="tomcat 部署"></a>tomcat 部署</h2><h3 id="1、docker-hub上面查找-tomcat-镜像"><a href="#1、docker-hub上面查找-tomcat-镜像" class="headerlink" title="1、docker hub上面查找 tomcat 镜像"></a>1、docker hub上面查找 tomcat 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101655.png"></p><h3 id="2、从-docker-hub-上拉取-tomcat-镜像到本地"><a href="#2、从-docker-hub-上拉取-tomcat-镜像到本地" class="headerlink" title="2、从 docker hub 上拉取 tomcat 镜像到本地"></a>2、从 docker hub 上拉取 tomcat 镜像到本地</h3><p>不指定版本时，拉取为：latest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101656.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101657.png" alt="image-20201112080607304"></p><h3 id="3、docker-images-查看是否有拉取到的-tomcat"><a href="#3、docker-images-查看是否有拉取到的-tomcat" class="headerlink" title="3、docker images 查看是否有拉取到的 tomcat"></a>3、docker images 查看是否有拉取到的 tomcat</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101658.png"></p><h3 id="4、使用-tomcat-镜像创建容器-也叫运行镜像"><a href="#4、使用-tomcat-镜像创建容器-也叫运行镜像" class="headerlink" title="4、使用 tomcat 镜像创建容器(也叫运行镜像)"></a>4、使用 tomcat 镜像创建容器(也叫运行镜像)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">-p 主机端口:docker容器端口</span><br><span class="line">-P 随机分配端口</span><br><span class="line">-it 交互终端</span><br></pre></td></tr></table></figure><p>如果是随机分配终端，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101659.png" alt="image-20201112080848910"></p><hr><h2 id="mysql-部署"><a href="#mysql-部署" class="headerlink" title="mysql 部署"></a>mysql 部署</h2><h3 id="1、docker-hub上面查找-mysql-镜像"><a href="#1、docker-hub上面查找-mysql-镜像" class="headerlink" title="1、docker hub上面查找 mysql 镜像"></a>1、docker hub上面查找 mysql 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101700.png" alt="image-20201112081011330"></p><h3 id="2、从docker-hub上-阿里云加速器-拉取-mysql-镜像到本地标签为-5-6"><a href="#2、从docker-hub上-阿里云加速器-拉取-mysql-镜像到本地标签为-5-6" class="headerlink" title="2、从docker hub上(阿里云加速器)拉取 mysql 镜像到本地标签为 5.6"></a>2、从docker hub上(阿里云加速器)拉取 mysql 镜像到本地标签为 5.6</h3><p>拉取指定版本到本地</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101701.png" alt="image-20201112081108267"></p><h3 id="3、使用-mysql5-6-镜像创建容器-也叫运行镜像"><a href="#3、使用-mysql5-6-镜像创建容器-也叫运行镜像" class="headerlink" title="3、使用 mysql5.6 镜像创建容器(也叫运行镜像)"></a>3、使用 mysql5.6 镜像创建容器(也叫运行镜像)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 12345:3306 --name mysql</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;logs:&#x2F;logs</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456</span><br><span class="line">-d mysql:5.6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">命令说明：</span><br><span class="line"></span><br><span class="line">-p 12345:3306：将主机的12345端口映射到docker容器的3306端口。[一般使用软件默认的端口就行]</span><br><span class="line">--name mysql：运行服务名字</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d ：将主机&#x2F;zzyyuse&#x2F;mysql录下的conf&#x2F;my.cnf 挂载到容器的 &#x2F;etc&#x2F;mysql&#x2F;conf.d</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;logs:&#x2F;logs：将主机&#x2F;zzyyuse&#x2F;mysql目录下的 logs 目录挂载到容器的 &#x2F;logs。</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql ：将主机&#x2F;zzyyuse&#x2F;mysql目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456：初始化 root 用户的密码。</span><br><span class="line">-d mysql:5.6 : 后台程序运行mysql5.6</span><br></pre></td></tr></table></figure><p>进入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it MySQL运行成功后的容器ID     &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101702.png" alt="image-20201112081549644"></p><h3 id="4、外部-Win10-也来连接运行在-dokcer上的-mysql-服务"><a href="#4、外部-Win10-也来连接运行在-dokcer上的-mysql-服务" class="headerlink" title="4、外部 Win10 也来连接运行在 dokcer上的 mysql 服务"></a>4、外部 Win10 也来连接运行在 dokcer上的 mysql 服务</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101703.png" alt="image-20201112081830145"></p><h3 id="5、备份测试"><a href="#5、备份测试" class="headerlink" title="5、备份测试"></a>5、备份测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec myql服务容器ID sh -c &#39; exec mysqldump --all-databases -uroot -p&quot;123456&quot; &#39; &gt; &#x2F;zzyyuse&#x2F;all-databases.sql</span><br></pre></td></tr></table></figure><hr><h2 id="redis-部署"><a href="#redis-部署" class="headerlink" title="redis 部署"></a>redis 部署</h2><h3 id="1、docker-hub上面查找-redis-镜像"><a href="#1、docker-hub上面查找-redis-镜像" class="headerlink" title="1、docker hub上面查找 redis 镜像"></a>1、docker hub上面查找 redis 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure><h3 id="2、从docker-hub上-阿里云加速器-拉取-redis-镜像到本地标签为-3-2"><a href="#2、从docker-hub上-阿里云加速器-拉取-redis-镜像到本地标签为-3-2" class="headerlink" title="2、从docker hub上(阿里云加速器)拉取 redis 镜像到本地标签为 3.2"></a>2、从docker hub上(阿里云加速器)拉取 redis 镜像到本地标签为 3.2</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101704.png" alt="image-20201112082107134"></p><h3 id="3、使用-redis-3-2-镜像创建容器-也叫运行镜像"><a href="#3、使用-redis-3-2-镜像创建容器-也叫运行镜像" class="headerlink" title="3、使用 redis 3.2  镜像创建容器(也叫运行镜像)"></a>3、使用 redis 3.2  镜像创建容器(也叫运行镜像)</h3><p>注意这里主机下面 redis.conf 是一层目录 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 \</span><br><span class="line">-v &#x2F;xj0927&#x2F;myredis&#x2F;data:&#x2F;data \</span><br><span class="line">-v &#x2F;xj0927&#x2F;myredis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf  \</span><br><span class="line">-d redis:3.2 \</span><br><span class="line">redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span><br><span class="line">--appendonly yes</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101705.png" alt="image-20201112082336274"></p><h3 id="4、测试-redis-cli-连接上来"><a href="#4、测试-redis-cli-连接上来" class="headerlink" title="4、测试 redis-cli 连接上来"></a>4、测试 redis-cli 连接上来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 运行着Rediis服务的容器ID redis-cli</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101706.png" alt="image-20201112082424493"></p><h3 id="5、测试持久化文件生成"><a href="#5、测试持久化文件生成" class="headerlink" title="5、测试持久化文件生成"></a>5、测试持久化文件生成</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101707.png" alt="image-20201112082501645"></p><hr><h2 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h2><h3 id="1、搜索-nginx-镜像"><a href="#1、搜索-nginx-镜像" class="headerlink" title="1、搜索 nginx 镜像"></a>1、搜索 nginx 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure><h3 id="2、拉取-nginx-镜像"><a href="#2、拉取-nginx-镜像" class="headerlink" title="2、拉取 nginx 镜像"></a>2、拉取 nginx 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="3、创建容器，设置目录映射"><a href="#3、创建容器，设置目录映射" class="headerlink" title="3、创建容器，设置目录映射"></a>3、创建容器，设置目录映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br><span class="line">mkdir conf</span><br><span class="line">cd conf </span><br><span class="line"></span><br><span class="line"># 在~&#x2F;nginx&#x2F;conf&#x2F;下创建nginx.conf文件,粘贴下面内容 </span><br><span class="line">vim nginx.conf </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">user nginx;   </span><br><span class="line">worker_processes 1;   </span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  worker_connections  1024;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  include    &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">  default_type application&#x2F;octet-stream;</span><br><span class="line">  log_format   main &#39;$remote_addr - $remote_user [$time_local]  $status &#39;</span><br><span class="line">    &#39;&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">  access_log   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line">  sendfile     on;</span><br><span class="line">  #tcp_nopush   on;  keepalive_timeout  65;</span><br><span class="line">  #gzip on;</span><br><span class="line">  </span><br><span class="line">  # 后面需要应用的端口文件都放在conf.d下面</span><br><span class="line">  include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、运行镜像"><a href="#4、运行镜像" class="headerlink" title="4、运行镜像"></a>4、运行镜像</h3><p>当前目录：nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-p 81:81 \</span><br><span class="line">-p 82:82 \ </span><br><span class="line">-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \</span><br><span class="line">-v $PWD&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \</span><br><span class="line">-v $PWD&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \</span><br><span class="line">-v $PWD&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong> </p><ul><li><strong>-p 80:80：</strong>将容器的80端口映射到宿主机的 80 端口</li><li><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：</strong>将主机当前目录下的 /conf/nginx.conf 挂载到容 器的 :/etc/nginx/nginx.conf  [配置目录 ]</li><li><strong>-v $PWD/logs:/var/log/nginx：</strong>将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx [ 日志目录]</li><li><strong>-v $PWD/conf.d:/etc/nginx/conf.d ：</strong> [应用目录]</li><li><strong>-v $PWD/html:/usr/share/nginx/html ：</strong> [静态资源目录]</li></ul><h3 id="5、端口映射"><a href="#5、端口映射" class="headerlink" title="5、端口映射"></a>5、端口映射</h3><p>路径：nginx/conf.d/80.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">listen 80; # 监听的端口</span><br><span class="line">    server_name localhost; # 域名或ip</span><br><span class="line">    location &#x2F; &#123; # 访问路径配置</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;# 根目录</span><br><span class="line">       index index.html index.htm; # 默认首页</span><br><span class="line">    &#125;</span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html; # 错误页面</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123; </span><br><span class="line">    root html; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、静态页面"><a href="#6、静态页面" class="headerlink" title="6、静态页面"></a>6、静态页面</h3><p>在 主机的 html 目录下新增 index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;hello docker nginx&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><h3 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h3><p>访问：192.168.77.138</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101708.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6_DockerFile 解析</title>
      <link href="2021/02/17/Docker/6-DockerFile-%E8%A7%A3%E6%9E%90/"/>
      <url>2021/02/17/Docker/6-DockerFile-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="6-DockerFile-解析"><a href="#6-DockerFile-解析" class="headerlink" title="6_DockerFile 解析"></a>6_DockerFile 解析</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Dockerfile 是用来构建 Docker 镜像的构建文件，是由一系列命令和参数构成的脚本。</p><h3 id="构建三步骤"><a href="#构建三步骤" class="headerlink" title="构建三步骤"></a>构建三步骤</h3><ol><li>编写 Dockerfile 文件</li><li>docker build</li><li>docker run</li></ol><h3 id="文件什么样？？？"><a href="#文件什么样？？？" class="headerlink" title="文件什么样？？？"></a>文件什么样？？？</h3><p>以我们熟悉的 CentOS 为例 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101509.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101510.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101511.png"></p><h2 id="DockerFile-构建过程解析"><a href="#DockerFile-构建过程解析" class="headerlink" title="DockerFile 构建过程解析"></a>DockerFile 构建过程解析</h2><h3 id="Dockerfile内容基础知识"><a href="#Dockerfile内容基础知识" class="headerlink" title="Dockerfile内容基础知识"></a>Dockerfile内容基础知识</h3><ul><li>1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>2：指令按照从上到下，顺序执行</li><li>3：# 表示注释</li><li>4：每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ul><h3 id="Docker-执行-Dockerfile-的大致流程"><a href="#Docker-执行-Dockerfile-的大致流程" class="headerlink" title="Docker 执行 Dockerfile 的大致流程"></a>Docker 执行 Dockerfile 的大致流程</h3><p>类似千层饼，一层包一层 ，每一层都是一个镜像。 </p><p>（1）docker 从基础镜像运行一个容器</p><p>（2）执行一条指令并对容器作出修改</p><p>（3）执行类似 docker commit 的操作提交一个新的镜像层</p><p>（4）docker 再基于刚提交的镜像运行一个新容器</p><p>（5）执行 dockerfile 中的下一条指令直到所有指令都执行完成</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、Docker 镜像与 Docker 容器分别代表软件的三个不同段，</p><ul><li>Dockerfile 是软件的原材料</li><li>Docker 镜像是软件的交付品</li><li>Docker 容器则可以认为是软件的运行态。</li></ul><p>Dockerfile 面向开发，Docker 镜像成为交付标准，Docker 容器则涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101512.png"></p><p>1、Dockerfile，需要定义一个Dockerfile，Dockerfile 定义了进程需要的一切东西。Dockerfile 涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p><p>2 、Docker 镜像，在用 Dockerfile 定义一个文件之后，docker build 时会产生一个Docker 镜像，当运行 Docker 镜像时，会真正开始提供服务;</p><p>3、 Docker 容器，容器是直接提供服务的。</p><h2 id="DockerFile-体系结构-保留字指令"><a href="#DockerFile-体系结构-保留字指令" class="headerlink" title="DockerFile 体系结构(保留字指令)"></a>DockerFile 体系结构(保留字指令)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM  基础镜像，当前新镜像是基于哪个镜像的</span><br><span class="line"></span><br><span class="line">MAINTAINER  镜像维护者的姓名和邮箱地址</span><br><span class="line"></span><br><span class="line">RUN  容器构建时需要运行的命令</span><br><span class="line"></span><br><span class="line">EXPOSE  当前容器对外暴露出的端口</span><br><span class="line"></span><br><span class="line">WORKDIR  指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点[进入容器时,默认的目录位置]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENV 用来在构建镜像过程中设置环境变量</span><br><span class="line"></span><br><span class="line">ENV MY_PATH &#x2F;usr&#x2F;mytest</span><br><span class="line">这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</span><br><span class="line">也可以在其它指令中直接使用这些环境变量，比如：WORKDIR $MY_PATH</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADD 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</span><br><span class="line"></span><br><span class="line">COPY 类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</span><br><span class="line">COPY src dest</span><br><span class="line">COPY [&quot;src&quot;, &quot;dest&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME 容器数据卷，用于数据保存和持久化工作</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD 指定一个容器启动时要运行的命令</span><br><span class="line">Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101513.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT  指定一个容器启动时要运行的命令</span><br><span class="line">   但docker run之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD   当构建一个被继承的 Dockerfile 时运行命令，父镜像在被子继承后父镜像的 onbuild 被触发</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101514.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101515.png"></p><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101516.png"></p><hr><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Base镜像-scratch"><a href="#Base镜像-scratch" class="headerlink" title="Base镜像(scratch)"></a>Base镜像(scratch)</h3><p>Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101517.png"></p><h3 id="自定义镜像-mycentos"><a href="#自定义镜像-mycentos" class="headerlink" title="自定义镜像 mycentos"></a>自定义镜像 mycentos</h3><h4 id="1、编写"><a href="#1、编写" class="headerlink" title="1、编写"></a>1、编写</h4><h5 id="（1）Hub-默认CentOS-镜像什么情况"><a href="#（1）Hub-默认CentOS-镜像什么情况" class="headerlink" title="（1）Hub 默认CentOS 镜像什么情况"></a>（1）Hub 默认CentOS 镜像什么情况</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101518.png"></p><p>自定义 mycentos 目的 使我们自己的镜像具备如下：</p><ul><li>​     登陆后的默认路径</li><li>​     vim 编辑器</li><li>​     查看网络配置 ifconfig 支持</li></ul><h5 id="（2）准备编写-DockerFile-文件"><a href="#（2）准备编写-DockerFile-文件" class="headerlink" title="（2）准备编写 DockerFile 文件"></a>（2）准备编写 DockerFile 文件</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101519.png"></p><h5 id="（3）myCentOS-内容-DockerFile"><a href="#（3）myCentOS-内容-DockerFile" class="headerlink" title="（3）myCentOS 内容 DockerFile"></a>（3）myCentOS 内容 DockerFile</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER zzyy&lt;zzyy167@126.com&gt;</span><br><span class="line"></span><br><span class="line"># 默认路径</span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line"># 构建时需要运行的指令</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line"># mycentos 暴露的端口</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success--------------ok&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h4 id="2、构建"><a href="#2、构建" class="headerlink" title="2、构建"></a>2、构建</h4><p>docker build 命令最后有一个 .                  . 表示当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 新镜像名字:TAG .</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101520.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101521.png"></p><h4 id="3、运行"><a href="#3、运行" class="headerlink" title="3、运行"></a>3、运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 新镜像名字:TAG </span><br></pre></td></tr></table></figure><p>可以看到，我们自己的新镜像已经支持 vim / ifconfig 命令，扩展成功了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101522.png"></p><h4 id="4、列出镜像的变更历史"><a href="#4、列出镜像的变更历史" class="headerlink" title="4、列出镜像的变更历史"></a>4、列出镜像的变更历史</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history 镜像名</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101523.png"></p><h3 id="CMD-ENTRYPOINT-镜像案例"><a href="#CMD-ENTRYPOINT-镜像案例" class="headerlink" title="CMD / ENTRYPOINT 镜像案例"></a>CMD / ENTRYPOINT 镜像案例</h3><p>都是指定一个容器启动时要运行的命令 </p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换！！！</p><h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>tomcat 的讲解演示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8888:8080 tomcat ls -l</span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101524.png"></p><h5 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h5><p>制作 CMD 版可以查询 IP 信息的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install -y curl</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101525.png"></p><blockquote><p>crul 命令解释：</p><p>curl 命令可以用来执行下载、发送各种HTTP请求，指定 HTTP 头部等操作。</p><p>如果系统没有 curl 可以使用 yum install curl 安装，也可以下载安装。</p><p>curl 是将下载文件输出到 stdout </p><p>使用命令：curl <a href="http://www.baidu.com/">http://www.baidu.com</a></p><p>执行后，<a href="http://www.baidu.com/">www.baidu.com</a> 的 html 就会显示在屏幕上了</p><p>这是最简单的使用方法。用这个命令获得了<a href="http://curl.haxx.se指向的页面,同样,如果这里的url指向的是一个文件或者一幅图都可以直接下载到本地.如果下载的是html文档,那么缺省的将只显示文件头部,即html文档的header.要全部显示,请加参数/">http://curl.haxx.se指向的页面，同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数</a> -i</p></blockquote><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如果我们希望显示 HTTP 头信息，就需要加上 -i 参数</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101526.png"></p><h5 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h5><p>我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。</p><p>因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s <a href="http://ip.cn/">http://ip.cn</a> 后面。而 -i 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip curl -s http:&#x2F;&#x2F;ip.cn -i</span><br></pre></td></tr></table></figure><h5 id="制作-ENTRYPOINT-版查询-IP-信息的容器"><a href="#制作-ENTRYPOINT-版查询-IP-信息的容器" class="headerlink" title="制作 ENTRYPOINT 版查询 IP 信息的容器"></a>制作 ENTRYPOINT 版查询 IP 信息的容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">RUN yum install -y curl</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101527.png"></p><h3 id="自定义镜像-Tomcat9"><a href="#自定义镜像-Tomcat9" class="headerlink" title="自定义镜像 Tomcat9"></a>自定义镜像 Tomcat9</h3><h5 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;zzyyuse&#x2F;mydockerfile&#x2F;tomcat9</span><br></pre></td></tr></table></figure><h5 id="2、在上述目录下-touch-c-txt"><a href="#2、在上述目录下-touch-c-txt" class="headerlink" title="2、在上述目录下 touch c.txt"></a>2、在上述目录下 touch c.txt</h5><h5 id="3、将-jdk-和-tomcat-安装的压缩包拷贝进上一步目录"><a href="#3、将-jdk-和-tomcat-安装的压缩包拷贝进上一步目录" class="headerlink" title="3、将 jdk 和 tomcat 安装的压缩包拷贝进上一步目录"></a>3、将 jdk 和 tomcat 安装的压缩包拷贝进上一步目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apache-tomcat-9.0.8.tar.gz</span><br><span class="line">jdk-8u171-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h5 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h5><p>在 /zzyyuse/mydockerfile/tomcat9 目录下新建 Dockerfile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM         centos</span><br><span class="line">MAINTAINER    zzyy&lt;zzyybs@126.com&gt;</span><br><span class="line">#把宿主机当前上下文的c.txt拷贝到容器&#x2F;usr&#x2F;local&#x2F;路径下</span><br><span class="line">COPY c.txt &#x2F;usr&#x2F;local&#x2F;cincontainer.txt</span><br><span class="line">#把java与tomcat添加到容器中</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">ADD apache-tomcat-9.0.8.tar.gz &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#设置工作访问时候的WORKDIR路径，登录落脚点</span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">#配置java与tomcat环境变量</span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_171</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">ENV CATALINA_HOME &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8</span><br><span class="line">ENV CATALINA_BASE &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME&#x2F;bin:$CATALINA_HOME&#x2F;lib:$CATALINA_HOME&#x2F;bin</span><br><span class="line">#容器运行时监听的端口</span><br><span class="line">EXPOSE  8080</span><br><span class="line">#启动时运行tomcat</span><br><span class="line"># ENTRYPOINT [&quot;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;startup.sh&quot; ]</span><br><span class="line"># CMD [&quot;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;catalina.sh&quot;,&quot;run&quot;]</span><br><span class="line">CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;startup.sh &amp;&amp; tail -F &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;logs&#x2F;catalina.out</span><br></pre></td></tr></table></figure><p>此时，目录内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101528.png"></p><h5 id="5、构建"><a href="#5、构建" class="headerlink" title="5、构建"></a>5、构建</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101529.png"></p><h5 id="6、run"><a href="#6、run" class="headerlink" title="6、run"></a>6、run</h5><p>运行且和主机之间建立数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9080:8080 --name myt9</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mydockerfile&#x2F;tomcat9&#x2F;test:&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;webapps&#x2F;test</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mydockerfile&#x2F;tomcat9&#x2F;tomcat9logs&#x2F;:&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;logs</span><br><span class="line">--privileged&#x3D;true</span><br><span class="line">zzyytomcat9</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101530.png"></p><blockquote><p>备注：Docker 挂载主机目录 Docker 访问出现 cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个 –privileged=true 参数即可</p></blockquote><h5 id="7、验证"><a href="#7、验证" class="headerlink" title="7、验证"></a>7、验证</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101531.png"></p><h5 id="8、"><a href="#8、" class="headerlink" title="8、"></a>8、</h5><p>结合前述的容器卷将测试的 web 服务 tes t发布</p><h6 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101532.png"></p><h6 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">  xsi: schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot;</span><br><span class="line">  id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;2.5&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;display-name&gt;test&lt;&#x2F;display-name&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure><h6 id="a-jsp"><a href="#a-jsp" class="headerlink" title="a.jsp"></a>a.jsp</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">     &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">     &lt;title&gt;Insert title here&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      -----------welcome------------</span><br><span class="line">     &lt;%&#x3D;&quot;i am in docker tomcat self &quot;%&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;% System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;docker tomcat self&quot;);%&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101533.png"></p><hr><h2 id="自定义-dockerFile-镜像"><a href="#自定义-dockerFile-镜像" class="headerlink" title="自定义 dockerFile 镜像"></a>自定义 dockerFile 镜像</h2><h3 id="自定义-centos7-镜像"><a href="#自定义-centos7-镜像" class="headerlink" title="自定义 centos7 镜像"></a>自定义 centos7 镜像</h3><p>使用官方的镜像，我们发现没有没有 ifconfig ，vim 等功能，我们可以在官方的镜像基础上进行自定义，构建我们希望的镜像，然后运行容器</p><p><strong>需求：</strong></p><ol><li><p>默认登录路径为 /usr </p></li><li><p>可以使用 vim </p></li></ol><p><strong>步骤：</strong></p><ol><li>定义父镜像：FROM centos:7 </li><li>定义作者信息：MAINTAINER xj0927  <a href="mailto:&#x78;&#x6a;&#48;&#57;&#x32;&#x37;&#64;&#108;&#120;&#115;&#x2e;&#x63;&#110;">&#x78;&#x6a;&#48;&#57;&#x32;&#x37;&#64;&#108;&#120;&#115;&#x2e;&#x63;&#110;</a> </li><li>执行安装 vim 命令： RUN yum install -y vim </li><li>定义默认的工作目录：WORKDIR /usr </li><li>定义容器启动执行的命令：CMD /bin/bash </li><li>通过 dockerfile 构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本 . </li></ol><p>现在开始构建 dockerFile 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;docker-files</span><br><span class="line">cd ~&#x2F;docker-files</span><br><span class="line">vim centos_dockerfile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7 </span><br><span class="line">MAINTAINER xj0927  xj0927@lxs.cn </span><br><span class="line">RUN yum install -y vim </span><br><span class="line">WORKDIR &#x2F;usr </span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><strong>构建：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f .&#x2F;centos_dockerfile -t mycentos:1 .</span><br></pre></td></tr></table></figure><ul><li>-f：镜像文件 </li><li>-t：新镜像名 </li><li>. 寻址路径</li></ul><p><strong>查看镜像：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>运行容器：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name&#x3D;mycentos mycentos:1</span><br></pre></td></tr></table></figure><hr><h3 id="发布-springboot-项目"><a href="#发布-springboot-项目" class="headerlink" title="发布 springboot 项目"></a>发布 springboot 项目</h3><p>Spring Boot 项目：</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/1.png)</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/2.png)</p><p>使用 maven 打包项目：</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/3.png)</p><p>windows 下，使用 cmd 运行 jar 包：</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/4.png)</p><p>浏览器便可以访问：<a href="http://localhost/test">http://localhost/test</a></p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/5.png)</p><hr><p>现在，把 jar 放在docker 环境中，使用 dockerFile 进行构建成镜像，然后运行容器，进行访问</p><p>Spring Boot 项目依赖 java 8，所以需要先拉取 Java 8 的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull java:8</span><br></pre></td></tr></table></figure><p>现在开始构建 dockerFile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim springboot</span><br></pre></td></tr></table></figure><p><strong>步骤：</strong></p><ol><li>定义父镜像：FROM java:8</li><li>定义作者信息：MAINTAINER xj0927  <a href="mailto:&#x78;&#106;&#x30;&#x39;&#50;&#55;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;">&#x78;&#106;&#x30;&#x39;&#50;&#55;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a> </li><li>将 jar 包添加到容器并重命名： ADD springboot.jar app.jar</li><li>定义容器启动执行的命令：CMD [“java”,”-jar”,”app.jar”] </li><li>通过 dockerfile 构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本 . </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">MAINTAINER xj0927  xj0927@163.com </span><br><span class="line">ADD springboot.jar app.jar</span><br><span class="line">CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure><p><strong>构建：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker bulid –f .&#x2F;springboot –t app .</span><br></pre></td></tr></table></figure><p><strong>查看镜像：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>启动容器 ：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id -p 9090:80 --name&#x3D;springboot app</span><br></pre></td></tr></table></figure><p>**访问测试： **<a href="http://192.168.77.138:9090/test">http://192.168.77.138:9090/test</a></p><p>此时，便可以在别的主机上[ 这里使用的windows ]访问 Linux 上的 9090端口的宿主机，因为进行了端口映射，便可以访问到 启动的 springboot 容器</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/6.png)</p><hr><h2 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101534.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_Docker容器数据卷</title>
      <link href="2021/02/17/Docker/5-Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
      <url>2021/02/17/Docker/5-Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Docker-容器数据卷"><a href="#5-Docker-容器数据卷" class="headerlink" title="5_Docker 容器数据卷"></a>5_Docker 容器数据卷</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>先来看看 Docker 的理念：</p><ul><li>将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望<strong>是持久化的</strong></li><li>容器之间希望有可能<strong>共享数据</strong></li></ul><p>Docker 容器产生的数据，如果不通过 docker commit 生成新的镜像，使得数据做为镜像的一部分保存下来，</p><p>那么当容器删除后，数据自然也就没有了。</p><p>为了能保存数据在 docker 中我们使用卷。</p><p>一句话：有点类似我们 Redis 里面的 rdb 和 aof 文件</p><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><p>卷就是目录或文件，存在于一个或多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System 提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷 。特点：</p><ul><li>1：数据卷可在容器之间共享或重用数据</li><li>2：卷中的更改可以直接生效</li><li>3：数据卷中的更改不会包含在镜像的更新中</li><li>4：数据卷的生命周期一直持续到没有容器使用它为止</li></ul><p><strong>总结</strong></p><h3 id="（1）容器的持久化"><a href="#（1）容器的持久化" class="headerlink" title="（1）容器的持久化"></a>（1）容器的持久化</h3><h3 id="（2）容器间继承-共享数据"><a href="#（2）容器间继承-共享数据" class="headerlink" title="（2）容器间继承 + 共享数据"></a>（2）容器间继承 + 共享数据</h3><hr><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>前提：容器内添加</p><h3 id="1、直接命令添加"><a href="#1、直接命令添加" class="headerlink" title="1、直接命令添加"></a>1、直接命令添加</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>也就是将主机中的某个文件与容器间的某个文件进行挂载，达到数据共享的目的 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录   镜像名</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;宿主机目录:&#x2F;容器内目录 centos &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101356.png"></p><h4 id="查看数据卷是否挂载成功"><a href="#查看数据卷是否挂载成功" class="headerlink" title="查看数据卷是否挂载成功"></a>查看数据卷是否挂载成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101357.png"></p><h4 id="容器和宿主机之间数据共享"><a href="#容器和宿主机之间数据共享" class="headerlink" title="容器和宿主机之间数据共享"></a>容器和宿主机之间数据共享</h4><p>数据共享！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101358.png"></p><h4 id="容器停止退出后，主机修改后数据是否同步"><a href="#容器停止退出后，主机修改后数据是否同步" class="headerlink" title="容器停止退出后，主机修改后数据是否同步"></a>容器停止退出后，主机修改后数据是否同步</h4><p>仍然同步！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101359.png"></p><h4 id="命令-带权限"><a href="#命令-带权限" class="headerlink" title="命令(带权限)"></a>命令(带权限)</h4><p>如果想要 容器“仅读”，不能写操作，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101400.png"></p><h3 id="2、DockerFile-添加"><a href="#2、DockerFile-添加" class="headerlink" title="2、DockerFile 添加"></a>2、DockerFile 添加</h3><p>出于可移植和分享的考虑，用 -v  主机目录 ：容器目录这种方法不能够直接在 Dockerfile 中实现 。</p><p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p><h4 id="根目录下新建-mydocker-文件夹并进入"><a href="#根目录下新建-mydocker-文件夹并进入" class="headerlink" title="根目录下新建 mydocker 文件夹并进入"></a>根目录下新建 mydocker 文件夹并进入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir mydocker</span><br></pre></td></tr></table></figure><h4 id="可在-Dockerfile-中使用-VOLUME-指令来给镜像添加一个或多个数据卷"><a href="#可在-Dockerfile-中使用-VOLUME-指令来给镜像添加一个或多个数据卷" class="headerlink" title="可在 Dockerfile 中使用 VOLUME 指令来给镜像添加一个或多个数据卷"></a>可在 Dockerfile 中使用 VOLUME 指令来给镜像添加一个或多个数据卷</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME[&quot;&#x2F;dataVolumeContainer&quot;,&quot;&#x2F;dataVolumeContainer2&quot;,&quot;&#x2F;dataVolumeContainer3&quot;]</span><br></pre></td></tr></table></figure><h4 id="File-构建"><a href="#File-构建" class="headerlink" title="File 构建"></a>File 构建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># volume test</span><br><span class="line"># 基于 centos 基础镜像</span><br><span class="line">FROM centos</span><br><span class="line"># 添加数据卷</span><br><span class="line">VOLUME [&quot;&#x2F;dataVolumeContainer1&quot;,&quot;&#x2F;dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;finished,--------success1&quot;</span><br><span class="line"># 启动命令</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101401.png"></p><h4 id="build-后生成镜像"><a href="#build-后生成镜像" class="headerlink" title="build 后生成镜像"></a>build 后生成镜像</h4><p>如果此时所在位置下面就有 目的构建文件 可以省略 -f </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101402.png"></p><p>获得一个新镜像 zzyy/centos ！！！</p><h4 id="run-容器"><a href="#run-容器" class="headerlink" title="run 容器"></a>run 容器</h4><p>使用刚刚我们构建的镜像，创建容器实例并启动</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101403.png"></p><p>通过上述步骤，容器内的卷目录地址已经知道！！</p><p>那对应的主机目录地址哪？？</p><p>使用下列命令便可以找到主机对应的卷目录的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101404.png"></p><h4 id="主机对应默认地址"><a href="#主机对应默认地址" class="headerlink" title="主机对应默认地址"></a>主机对应默认地址</h4><p>根据上面信息显示的位置目录便可以找到！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101405.png"></p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>Docker 挂载主机目录 Docker 访问出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot open directory .: Permission denied</span><br></pre></td></tr></table></figure><p>解决办法：在挂载目录后多加一个参数即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--privileged&#x3D;true</span><br></pre></td></tr></table></figure><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器 。</p><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>以上一步新建的镜像 zzyy/centos 为模板并运行容器 dc01/dc02/dc03</p><p>它们已经具有容器卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dataVolumeContainer1</span><br><span class="line">&#x2F;dataVolumeContainer2</span><br></pre></td></tr></table></figure><h3 id="容器间传递共享-–volumes-from"><a href="#容器间传递共享-–volumes-from" class="headerlink" title="容器间传递共享(–volumes-from)"></a>容器间传递共享(–volumes-from)</h3><h5 id="先启动一个父容器-dc01"><a href="#先启动一个父容器-dc01" class="headerlink" title="先启动一个父容器 dc01"></a>先启动一个父容器 dc01</h5><p>在 dataVolumeContainer2 新增内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101406.png"></p><h5 id="dc02-dc03-继承自-dc01"><a href="#dc02-dc03-继承自-dc01" class="headerlink" title="dc02/dc03 继承自 dc01"></a>dc02/dc03 继承自 dc01</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加如下命令</span><br><span class="line">--volumes-from 父容器</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dc02 --volumes-from dc01 zzyy&#x2F;centos</span><br></pre></td></tr></table></figure><p>同时，dc02/dc03 分别在 dataVolumeContainer2 各自新增内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101407.png"></p><h5 id="回到-dc01-可以看到-02-03-各自添加的都能共享了"><a href="#回到-dc01-可以看到-02-03-各自添加的都能共享了" class="headerlink" title="回到 dc01 可以看到 02/03 各自添加的都能共享了"></a>回到 dc01 可以看到 02/03 各自添加的都能共享了</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101408.png"></p><h5 id="删除-dc01，dc02-修改后-dc03-可否访问"><a href="#删除-dc01，dc02-修改后-dc03-可否访问" class="headerlink" title="删除 dc01，dc02 修改后 dc03 可否访问"></a>删除 dc01，dc02 修改后 dc03 可否访问</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101409.png"></p><h5 id="删除-dc02-后-dc03-可否访问"><a href="#删除-dc02-后-dc03-可否访问" class="headerlink" title="删除 dc02 后 dc03 可否访问"></a>删除 dc02 后 dc03 可否访问</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101410.png"></p><h5 id="如果-再以-dc03-为父容器创建容器实例-dc04"><a href="#如果-再以-dc03-为父容器创建容器实例-dc04" class="headerlink" title="如果 再以 dc03 为父容器创建容器实例 dc04"></a>如果 再以 dc03 为父容器创建容器实例 dc04</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101411.png"></p><h5 id="新建-dc04-继承-dc03-后再删除-dc03"><a href="#新建-dc04-继承-dc03-后再删除-dc03" class="headerlink" title="新建 dc04 继承 dc03 后再删除 dc03"></a>新建 dc04 继承 dc03 后再删除 dc03</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101412.png"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止！！！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_Docker 镜像</title>
      <link href="2021/02/17/Docker/4-Docker-%E9%95%9C%E5%83%8F/"/>
      <url>2021/02/17/Docker/4-Docker-%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Docker-镜像"><a href="#4-Docker-镜像" class="headerlink" title="4_Docker 镜像"></a>4_Docker 镜像</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，<strong>用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容</strong>，包括代码、运行时、库、环境变量和配置文件。</p><h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101223.png"></p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><h3 id="Docker-镜像加载原理"><a href="#Docker-镜像加载原理" class="headerlink" title="Docker 镜像加载原理"></a>Docker 镜像加载原理</h3><p> docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</p><p>bootfs(boot file system) 主要包含 bootloader 和 kernel, bootloader 主要是引导加载 kernel, Linux 刚启动时会加载 bootfs 文件系统，在 Docker 镜像的最底层是 bootfs。这一层与我们典型的 Linux/Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p><p>rootfs (root file system) ，在 bootfs 之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu，Centos 等等。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101224.png"></p><p> 平时我们安装进虚拟机的 CentOS 都是好几个G，为什么 docker 这里才200M ？？</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101225.png"></p><p>对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的 linux发行版, bootfs 基本是一致的, rootfs 会有差别, 因此不同的发行版可以公用 bootfs。</p><h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p>以我们的 pull 为例，在下载的过程中我们可以看到 docker 的镜像好像是在一层一层的在下载 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101226.png"></p><h3 id="为什么-Docker-镜像要采用这种分层结构呢"><a href="#为什么-Docker-镜像要采用这种分层结构呢" class="headerlink" title="为什么 Docker 镜像要采用这种分层结构呢"></a>为什么 Docker 镜像要采用这种分层结构呢</h3><p>最大的一个好处就是 ：<strong>共享资源</strong></p><p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份 base镜像，</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Docker 镜像都是只读的</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。</p><p>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><hr><h2 id="Docker-镜像-commit-操作补充"><a href="#Docker-镜像-commit-操作补充" class="headerlink" title="Docker 镜像 commit 操作补充"></a>Docker 镜像 commit 操作补充</h2><p> 提交容器副本使之成为一个新的镜像 [ 这里也可以省略 ‘’=’’ ，直接: 参数 值 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit</span><br><span class="line">docker commit -m&#x3D;“提交的描述信息” -a&#x3D;“作者” 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><hr><h2 id="容器转镜像"><a href="#容器转镜像" class="headerlink" title="容器转镜像"></a>容器转镜像</h2><h3 id="转化-tomcat-镜像"><a href="#转化-tomcat-镜像" class="headerlink" title="转化 tomcat 镜像"></a>转化 tomcat 镜像</h3><p>1、从 Hub 上下载 tomcat 镜像到本地并成功运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat</span><br></pre></td></tr></table></figure><ul><li><p>-p 主机端口: docker容器端口</p></li><li><p>-P 随机分配端口</p></li><li><p>-it 交互终端</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101227.png"></p><p>如果，第一次访问时出现，参考</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101228.png"></p><p>2、故意删除上一步镜像生产 tomcat 容器的文档 ，此时在页面访问文档选项，便要出现错误！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101229.png"></p><p>3、也即当前的 tomcat 运行实例是一个没有文档内容的容器，以它为模板 commit 一个没有doc 的 tomcat 新镜像 atguigu/tomcat02</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101230.png"></p><p>4、启动我们的新镜像并和原来的对比</p><p>（1）启动 atguigu/tomcat02，它没有 docs</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101231.png"></p><p>（2）新启动原来的 tomcat，它有 docs</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101232.png"></p><p>这样我们便可以在标准的容器基础上，增加我们想要的功能，commit 成镜像，后面需要时，再以此镜像创建容器实例，便是我们想要的样子！！！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_Docker常用命令</title>
      <link href="2021/02/17/Docker/3-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/02/17/Docker/3-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Docker常用命令"><a href="#3-Docker常用命令" class="headerlink" title="3_Docker常用命令"></a>3_Docker常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="查看-docker-版本"><a href="#查看-docker-版本" class="headerlink" title="查看 docker 版本"></a>查看 docker 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="查看-docker-镜像数、Register等详细信息"><a href="#查看-docker-镜像数、Register等详细信息" class="headerlink" title="查看 docker 镜像数、Register等详细信息"></a>查看 docker 镜像数、Register等详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><h3 id="更多指令查看"><a href="#更多指令查看" class="headerlink" title="更多指令查看"></a>更多指令查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><hr><h2 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h2><p>启动docker服务: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>重启docker服务: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看docker服务状态: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>设置开机启动docker服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="（1）查看-docker-本地主机镜像"><a href="#（1）查看-docker-本地主机镜像" class="headerlink" title="（1）查看 docker 本地主机镜像"></a>（1）查看 docker 本地主机镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101119.png"></p><p><strong>各个选项说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY：表示镜像的仓库源</span><br><span class="line">TAG：镜像的标签[类似版本号]</span><br><span class="line">IMAGE ID：镜像ID[唯一]</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br></pre></td></tr></table></figure><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 <code>REPOSITORY:TAG </code>来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用<code>ubuntu:latest</code>镜像</p><p><strong>OPTIONS说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a :列出本地所有的镜像（含中间映像层）[一个镜像可能不止一层，类似千层饼]</span><br><span class="line">-q :只显示镜像ID [在删除镜像时,可能要 -qa 结合使用]</span><br><span class="line">--digests :显示镜像的摘要信息</span><br><span class="line">--no-trunc :显示完整的镜像信息</span><br></pre></td></tr></table></figure><h3 id="（2）docker-search-某个XXX镜像名字"><a href="#（2）docker-search-某个XXX镜像名字" class="headerlink" title="（2）docker search 某个XXX镜像名字"></a>（2）docker search 某个XXX镜像名字</h3><p><strong>网站：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;hub.docker.com</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101120.png"></p><p><strong>命令：</strong>搜索镜像是从 docker Hub 官网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] 镜像名字</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明：</span><br><span class="line">--no-trunc : 显示完整的镜像描述</span><br><span class="line">-s : 列出收藏数不小于指定值的镜像</span><br><span class="line">--automated : 只列出 automated build类型的镜像；</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101121.png"></p><h3 id="（3）docker-pull-某个XXX镜像名字"><a href="#（3）docker-pull-某个XXX镜像名字" class="headerlink" title="（3）docker  pull  某个XXX镜像名字"></a>（3）docker  pull  某个XXX镜像名字</h3><p>下载镜像：如果不指定版本，则默认下载 latest 最新版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名字[:TAG]</span><br></pre></td></tr></table></figure><h3 id="（4）docker-rmi-某个XXX镜像名字-ID"><a href="#（4）docker-rmi-某个XXX镜像名字-ID" class="headerlink" title="（4）docker  rmi  某个XXX镜像名字 ID"></a>（4）docker  rmi  某个XXX镜像名字 ID</h3><p>删除镜像：如果不指定版本，则默认删除 latest 最新版</p><p>删除单个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像ID&#x2F;镜像名字</span><br></pre></td></tr></table></figure><p>删除多个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG </span><br></pre></td></tr></table></figure><p>删除全部：先找到所有镜像 ID，再进行删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><hr><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>根本前提：必须要有镜像才能创建容器</p><p> <strong>CentOS 镜像演示</strong></p><h4 id="从仓库下载镜像"><a href="#从仓库下载镜像" class="headerlink" title="从仓库下载镜像"></a>从仓库下载镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101122.png"></p><h4 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101123.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPTIONS说明（常用）：有些是一个减号，有些是两个减号</span><br><span class="line"></span><br><span class="line">--name&#x3D;&quot;容器新名字&quot;: 为容器指定一个名称；[不指定时,会默认给1个名字]</span><br><span class="line">-d: 后台运行容器，并返回容器ID，也即启动守护式容器；[后台启动]</span><br><span class="line"></span><br><span class="line">-i：以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；[两者结合使用,启动并显示伪终端]</span><br><span class="line"></span><br><span class="line">-P: 随机端口映射；[不指定时,会默认给定端口,使用 docker ps 查看]</span><br><span class="line">-p: 指定端口映射，有以下四种格式[一般使用第三种,主机端口:容器端口]</span><br><span class="line">      ip:hostPort:containerPort</span><br><span class="line">      ip::containerPort</span><br><span class="line">      hostPort:containerPort</span><br><span class="line">      containerPort</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动交互式容器:</span><br><span class="line">可简单理解为:要显示伪终端, &#x2F;bin&#x2F;bash 可加可不加,这是因为在构建时加上了CMD 末尾有这个命令；同时如果不指定版本，默认启动 latest </span><br></pre></td></tr></table></figure><h4 id="列出当前所有正在运行的容器"><a href="#列出当前所有正在运行的容器" class="headerlink" title="列出当前所有正在运行的容器"></a>列出当前所有正在运行的容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101124.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明（常用）：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的 [列出所有容器]</span><br><span class="line"></span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line"></span><br><span class="line">-n：显示最近n个创建的容器。</span><br><span class="line"></span><br><span class="line">-q :静默模式，只显示容器编号。[配合 -aq 使用，用于删除所有容器]</span><br><span class="line"></span><br><span class="line">--no-trunc :不截断输出。</span><br></pre></td></tr></table></figure><h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><h5 id="方式-1：容器停止退出"><a href="#方式-1：容器停止退出" class="headerlink" title="方式 1：容器停止退出"></a>方式 1：容器停止退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit   容器就停止运行了</span><br></pre></td></tr></table></figure><h5 id="方式-2：容器不停止退出"><a href="#方式-2：容器不停止退出" class="headerlink" title="方式 2：容器不停止退出"></a>方式 2：容器不停止退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + P + Q    容器在后台运行</span><br></pre></td></tr></table></figure><p>如何再次进入正在运行中的容器也有两种方式，看后面介绍 。</p><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><p>有时候需要停止正在运行的容器，就是用这个命令 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除一个容器:</span><br><span class="line">docker rm 容器ID</span><br><span class="line">一次性删除多个容器:</span><br><span class="line">方式 1: docker rm -f $(docker ps -a -q)</span><br><span class="line">方式 2: docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure><hr><h4 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h4><h5 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>以后台模式启动一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure><p>会发现容器已经退出！！！</p><p>很重要的要说明的一点: Docker 容器后台运行,就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p>这个是 docker 的机制问题,比如你的 web 容器,我们以 nginx 为例，正常情况下,我们配置启动服务只需要启动响应的 service 即可。例如 service nginx start</p><p>但是,这样做,nginx 为后台进程模式运行,就导致 docker 前台没有运行的应用,</p><p>这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.</p><p>所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行 。</p><hr><h5 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail 容器ID</span><br><span class="line"></span><br><span class="line">*   -t 是加入时间戳</span><br><span class="line">*   -f 跟随最新的日志打印</span><br><span class="line">*   --tail 数字 显示最后多少条</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><p>运行容器，并让其不断输出语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos &#x2F;bin&#x2F;sh -c &quot;while true;do echo hello zzyy;sleep 2;done&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101125.png"></p><p>查看每个时间下，日志尾的最新 10 条</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101126.png"></p><h5 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure><h5 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h5><p>此命令可以用来查看该容器进行数据卷的主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><h5 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h5><p>前面提到 使用 ctrl + Q + P 退出伪终端后，想要再次进入该怎么办，</p><p><strong>方式 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID bashShell</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101127.png"></p><p><strong>方式 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101128.png"></p><p><strong>上述两个区别</strong></p><p>attach 直接进入容器启动命令的终端，不会启动新的进程 。</p><p>exec 是在容器中打开新的终端，并且可以启动新的进程 【隔山打牛】。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101129.png"></p><h5 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101130.png"></p><hr><p><strong>容器命令总结：</strong></p><p>查看容器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 查看正在运行的容器 </span><br><span class="line">docker ps –a # 查看所有容器</span><br></pre></td></tr></table></figure><p>创建并启动容器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run 参数</span><br><span class="line"></span><br><span class="line">i：保持容器运行。通常与-t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容 器自动关闭。 </span><br><span class="line">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</span><br><span class="line">-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容 器不会关闭。</span><br><span class="line">-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</span><br><span class="line">--name：为创建的容器命名。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name&#x3D;c1 centos:7 &#x2F;bin&#x2F;bash #创建交互式容器 </span><br><span class="line">docker run -id --name&#x3D;c2 centos:7 #创建守护式容器</span><br></pre></td></tr></table></figure><p>**注意： ** 交互式容器，exit后容器自动关闭，守护式容器会在后台执行</p><p>进入容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it c2 &#x2F;bin&#x2F;bash #进入容器</span><br></pre></td></tr></table></figure><p>停止容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名称</span><br></pre></td></tr></table></figure><p>删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称</span><br></pre></td></tr></table></figure><p>查看容器信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名称</span><br></pre></td></tr></table></figure><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>常用命令</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101131.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">attach  Attach to a running container  # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line"></span><br><span class="line">build   Build an image from a Dockerfile   # 通过 Dockerfile 定制镜像</span><br><span class="line"></span><br><span class="line">commit  Create a new image from a container changes  # 提交当前容器为新的镜像</span><br><span class="line"></span><br><span class="line">cp   Copy files&#x2F;folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line"></span><br><span class="line">create  Create a new container   # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line"></span><br><span class="line">diff  Inspect changes on a container&#39;s filesystem  # 查看 docker 容器变化</span><br><span class="line"></span><br><span class="line">events Get real time events from the server   # 从 docker 服务获取容器实时事件</span><br><span class="line"></span><br><span class="line">exec   Run a command in an existing container    # 在已存在的容器上运行命令</span><br><span class="line"></span><br><span class="line">export Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line"></span><br><span class="line">history  Show the history of an image     # 展示一个镜像形成历史</span><br><span class="line"></span><br><span class="line">images    List images                          # 列出系统当前镜像</span><br><span class="line"></span><br><span class="line">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line"></span><br><span class="line">info      Display system-wide information               # 显示系统相关信息</span><br><span class="line"></span><br><span class="line">inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line"></span><br><span class="line">kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line"></span><br><span class="line">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line"></span><br><span class="line">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span><br><span class="line"></span><br><span class="line">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</span><br><span class="line"></span><br><span class="line">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line"></span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span><br><span class="line"></span><br><span class="line">pause     Pause all processes within a container        # 暂停容器</span><br><span class="line"></span><br><span class="line">ps        List containers                               # 列出容器列表</span><br><span class="line"></span><br><span class="line">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line"></span><br><span class="line">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line"></span><br><span class="line">restart   Restart a running container                   # 重启运行的容器</span><br><span class="line"></span><br><span class="line">rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line"></span><br><span class="line">rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line"></span><br><span class="line">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line"></span><br><span class="line">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">start     Start a stopped containers                    # 启动容器</span><br><span class="line"></span><br><span class="line">stop      Stop a running containers                     # 停止容器</span><br><span class="line"></span><br><span class="line">tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line"></span><br><span class="line">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line"></span><br><span class="line">unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line"></span><br><span class="line">version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line"></span><br><span class="line">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_Docker安装</title>
      <link href="2021/02/17/Docker/2-Docker%E5%AE%89%E8%A3%85/"/>
      <url>2021/02/17/Docker/2-Docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Docker安装"><a href="#2-Docker安装" class="headerlink" title="2_Docker安装"></a>2_Docker安装</h1><h2 id="前提说明"><a href="#前提说明" class="headerlink" title="前提说明"></a>前提说明</h2><h3 id="CentOS-Docker-安装"><a href="#CentOS-Docker-安装" class="headerlink" title="CentOS Docker 安装"></a>CentOS Docker 安装</h3><p>Docker 支持以下的 CentOS 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS 7 (64-bit)</span><br><span class="line">CentOS 6.5 (64-bit) 或更高的版本</span><br></pre></td></tr></table></figure><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>目前，CentOS 仅发行版本中的内核支持 Docker。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。</span><br><span class="line"></span><br><span class="line">Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</span><br></pre></td></tr></table></figure><h3 id="查看自己的内核"><a href="#查看自己的内核" class="headerlink" title="查看自己的内核"></a>查看自己的内核</h3><p>uname 命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100950.png"></p><h3 id="查看已安装的CentOS版本信息"><a href="#查看已安装的CentOS版本信息" class="headerlink" title="查看已安装的CentOS版本信息"></a>查看已安装的CentOS版本信息</h3><p>CentOs 6：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100951.png"></p><p>CentOs 7：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100952.png"></p><h2 id="Docker-的基本组成"><a href="#Docker-的基本组成" class="headerlink" title="Docker 的基本组成"></a>Docker 的基本组成</h2><h3 id="镜像（images）"><a href="#镜像（images）" class="headerlink" title="镜像（images）"></a>镜像（images）</h3><p>Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，<strong>一个镜像可以创建很多容器</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100953.png"></p><h3 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h3><p>Docker 利用容器（Container）独立运行的一个或一组应用。<strong>容器是用镜像创建的运行实例。</strong></p><p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p><strong>可以把容器看做是一个简易版的 Linux 环境</strong>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><h3 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h3><p>仓库（Repository）是<strong>集中存放镜像</strong>文件的场所。</p><p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）【不同标签对应不同的版本】。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p><strong>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)%EF%BC%8C">https://hub.docker.com/)，</a></strong></p><p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等【一般下载镜像都在这上面下载，速度比较快】 。</p><p><strong>小总结</strong></p><p>需要正确的理解仓储/镜像/容器这几个概念:</p><p> Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。<strong>image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</strong></p><p>*  image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p><p>*  一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p><p>* 至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来就可以了。</p><h3 id="Docker-的架构图"><a href="#Docker-的架构图" class="headerlink" title="Docker 的架构图"></a>Docker 的架构图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100954.png"></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="CentOS-7-安装-Docker"><a href="#CentOS-7-安装-Docker" class="headerlink" title="CentOS 7 安装 Docker"></a>CentOS 7 安装 Docker</h3><p>可以选择参考官网：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100955.png"></p><h4 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤"></a>安装步骤</h4><h5 id="1-官网中文安装参考手册"><a href="#1-官网中文安装参考手册" class="headerlink" title="1.官网中文安装参考手册"></a>1.官网中文安装参考手册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker-cn.com&#x2F;engine&#x2F;installation&#x2F;linux&#x2F;docker-ce&#x2F;centos&#x2F;#prerequisites</span><br></pre></td></tr></table></figure><h5 id="2-确定你是CentOS7及以上版本"><a href="#2-确定你是CentOS7及以上版本" class="headerlink" title="2.确定你是CentOS7及以上版本"></a>2.确定你是CentOS7及以上版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;redhat-release</span><br></pre></td></tr></table></figure><h5 id="3-yum安装gcc相关"><a href="#3-yum安装gcc相关" class="headerlink" title="3.yum安装gcc相关"></a>3.yum安装gcc相关</h5><p>CentOS7能上外网</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100956.png"></p><blockquote><p>CentOs 7 如何连接外网，可参考我这篇博客</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><h5 id="4-卸载旧版本"><a href="#4-卸载旧版本" class="headerlink" title="4.卸载旧版本"></a>4.卸载旧版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>官网版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h5 id="5-安装需要的软件包"><a href="#5-安装需要的软件包" class="headerlink" title="5.安装需要的软件包"></a>5.安装需要的软件包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h5 id="6-设置-stable-镜像仓库"><a href="#6-设置-stable-镜像仓库" class="headerlink" title="6.设置 stable 镜像仓库"></a>6.设置 stable 镜像仓库</h5><p>大坑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h5 id="7-更新-yum-软件包索引"><a href="#7-更新-yum-软件包索引" class="headerlink" title="7.更新 yum 软件包索引"></a>7.更新 yum 软件包索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h5 id="8-安装DOCKER-CE"><a href="#8-安装DOCKER-CE" class="headerlink" title="8.安装DOCKER CE"></a>8.安装DOCKER CE</h5><p>CE 表示社区版，EE 表示企业版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><h5 id="9-启动-docker"><a href="#9-启动-docker" class="headerlink" title="9.启动 docker"></a>9.启动 docker</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h5 id="10-测试"><a href="#10-测试" class="headerlink" title="10.测试"></a>10.测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100957.png"></p><p>Docker 成功安装！！！</p><p>此时还可以从 docker 仓库下载其提供的镜像进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker </span><br><span class="line">yum -y remove docker-ce</span><br><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure><h2 id="永远的-HelloWorld"><a href="#永远的-HelloWorld" class="headerlink" title="永远的 HelloWorld"></a>永远的 HelloWorld</h2><p>每次下载镜像如果都从 docker 官网进行下载，速度太慢，所以需更换镜像下载的地址为国内的（阿里云或者网易云）</p><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><h4 id="1、注册一个属于自己的阿里云账户-可复用淘宝账号"><a href="#1、注册一个属于自己的阿里云账户-可复用淘宝账号" class="headerlink" title="1、注册一个属于自己的阿里云账户(可复用淘宝账号)"></a>1、注册一个属于自己的阿里云账户(可复用淘宝账号)</h4><h4 id="2、获得加速器地址连接"><a href="#2、获得加速器地址连接" class="headerlink" title="2、获得加速器地址连接"></a>2、获得加速器地址连接</h4><h5 id="（1）登陆阿里云开发者平台"><a href="#（1）登陆阿里云开发者平台" class="headerlink" title="（1）登陆阿里云开发者平台"></a>（1）登陆阿里云开发者平台</h5><h5 id="（2）获取加速器地址"><a href="#（2）获取加速器地址" class="headerlink" title="（2）获取加速器地址"></a>（2）获取加速器地址</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100958.png"></p><h4 id="3、配置本机Docker运行镜像加速器"><a href="#3、配置本机Docker运行镜像加速器" class="headerlink" title="3、配置本机Docker运行镜像加速器"></a>3、配置本机Docker运行镜像加速器</h4><p> CentoS 7：</p><p>（1）进入到 docker 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;etc&#x2F;docker</span><br></pre></td></tr></table></figure><p>（2）创建 daemon.json 文件，并添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100959.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>（3）重新启动 Docker 后台服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>（4）Linux 系统下配置完加速器需要检查是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep docker</span><br></pre></td></tr></table></figure><h3 id="网易云加速"><a href="#网易云加速" class="headerlink" title="网易云加速"></a>网易云加速</h3><p>基本同上述阿里云</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101000.png"></p><h3 id="启动Docker后台容器-测试运行-hello-world"><a href="#启动Docker后台容器-测试运行-hello-world" class="headerlink" title="启动Docker后台容器(测试运行 hello-world)"></a>启动Docker后台容器(测试运行 hello-world)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101001.png"></p><p>输出这段提示以后，hello world就会停止运行，容器自动终止。</p><p><strong>run干了什么</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101002.png"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="Docker是怎么工作的"><a href="#Docker是怎么工作的" class="headerlink" title="Docker是怎么工作的"></a>Docker是怎么工作的</h3><p>Docker是一个Client-Server结构的系统，Docker 守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 <strong>容器，是一个运行时环境，就是我们前面说到的集装箱。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101003.png"></p><h3 id="为什么Docker比较比VM快"><a href="#为什么Docker比较比VM快" class="headerlink" title="为什么Docker比较比VM快"></a>为什么Docker比较比VM快</h3><p>(1)docker 有着比虚拟机更少的抽象层。由于 docker <strong>不需要 Hypervisor 实现硬件资源虚拟化</strong>,运行在 docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>(2)<strong>docker 利用的是宿主机的内核</strong>,而不需要 Guest OS。因此,当新建一个容器时,docker 不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载 Guest OS,返个新建过程是分钟级别的。而 docker 由于直接利用宿主机的操作系统,则省略了返个过程,因此<strong>新建一个docker容器只需要几秒钟。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101004.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101005.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_Docker 简介</title>
      <link href="2021/02/17/Docker/1-Docker-%E7%AE%80%E4%BB%8B/"/>
      <url>2021/02/17/Docker/1-Docker-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker-简介"><a href="#1-Docker-简介" class="headerlink" title="1_Docker 简介"></a>1_Docker 简介</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h3 id="为什么会有docker出现"><a href="#为什么会有docker出现" class="headerlink" title="为什么会有docker出现"></a>为什么会有docker出现</h3><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验</p><p>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，<strong>软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100419.png"></p><p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿电商项目的环境来说吧 Java/Tomcat/MySQL/JDBC 驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p><p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<strong>开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</strong></p><h3 id="docker-理念"><a href="#docker-理念" class="headerlink" title="docker 理念"></a>docker 理念</h3><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“<strong>一次封装，到处运行</strong>”。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100420.png"></p><p>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</strong></p><h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><p>解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><h3 id="之前的虚拟化技术"><a href="#之前的虚拟化技术" class="headerlink" title="之前的虚拟化技术"></a>之前的虚拟化技术</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p><p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100421.png"></p><p>虚拟机的缺点：</p><p>1   资源占用多        2   冗余步骤多         3   启动慢</p><h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100422.png"></p><p><strong>比较了 Docker 和传统虚拟化方式的不同之处：</strong></p><p>*传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p><p>*而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且<strong>也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</p><p>* 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><h3 id="开发-运维（DevOps）"><a href="#开发-运维（DevOps）" class="headerlink" title="开发/运维（DevOps）"></a>开发/运维（DevOps）</h3><p><strong>一次构建、随处运行</strong></p><ul><li>更快速的应用交付和部署</li><li>更便捷的升级和扩缩容</li><li>更简单的系统运维</li><li>更高效的计算资源利用</li></ul><h2 id="企业级"><a href="#企业级" class="headerlink" title="企业级"></a>企业级</h2><p>美团</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100423.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100424.png"></p><p>蘑菇街</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100322.png"></p><h2 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a>去哪下</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p>docker官网：<a href="http://www.docker.com/">http://www.docker.com</a></p><p>docker中文网站：<a href="https://www.docker-cn.com/">https://www.docker-cn.com/</a></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Docker Hub官网: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="2021/02/17/%E5%B7%A5%E5%85%B7/Maven/"/>
      <url>2021/02/17/%E5%B7%A5%E5%85%B7/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="maven的使用"><a href="#maven的使用" class="headerlink" title="maven的使用"></a>maven的使用</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>Maven 项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。</p></blockquote><p><a href="http://maven.apache.org/">Maven官方地址</a></p><hr><p><strong>两个主要功能：</strong></p><ul><li>依赖管理-jar包管理 </li><li>项目构建-代码编译 </li></ul><hr><p> <strong>maven的模型：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095523.jpg"></p><hr><p> <strong>maven依赖管理原理分析：</strong></p><blockquote><p>优先从本地查找，若没有则从远程仓库，中央仓库查找,查找结果先返回给本地仓库，再返回给项目。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095524.png"></p><hr><p><strong>项目构建：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095525.png"></p><hr><p><strong>构建过程：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095526.png"></p><hr><p><strong>项目构建的方式：</strong></p><p>1.Ant </p><blockquote><p>Ant只是一个项目构建工具，它没有集成依赖管理。Ant在进行项目构建时，它没有对项目目录结构进行约定，需要手动指定源文件、类文件等目录地址。同 时它执行 task时，需要显示指定依赖的task，这样会造成大量的代码重复。</p></blockquote><p>2.Maven </p><blockquote><p>Maven不仅是一个<strong>项目构建工具</strong>，更是一个<strong>项目管理工具</strong>。它在项目构建工程中，比ant更全面，更灵活。 </p><p>Maven在进行项目构建时，它<strong>对项目目录结构拥有约定</strong>，知道你的源代码在哪里，类文件应该放到哪里 去。</p><p>它拥有<strong>生命周期的概念</strong>，maven的生命周期是有顺序的，在执行后面的生命周期的任务时，不需要显示的配</p><p>置前面任务的生命周期。</p><p>例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程。</p></blockquote><p>3.Gradle </p><blockquote><p>一个开源的自动化构建系统，建立在Apache Ant和Maven Apache概念的基础上，并引入了基于Groovy的 特定领 域语言（DSL），而不是使用Apache Maven宣布的项目配置XML形式。</p></blockquote><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="maven-安装"><a href="#maven-安装" class="headerlink" title="maven_安装"></a>maven_安装</h3><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>Maven下载：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 官网</span></span><br><span class="line">http://maven.apache.org/download.cgi</span><br><span class="line"></span><br><span class="line"><span class="section"># 百度云链接：https://pan.baidu.com/s/1N<span class="emphasis">_Xwk3aMefopq8Usi6m8cg </span></span></span><br><span class="line"><span class="section"><span class="emphasis"># 提取码：xjvo</span></span></span><br></pre></td></tr></table></figure><p>Maven中央仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mvnrepository.com&#x2F; </span><br></pre></td></tr></table></figure><hr><h4 id="2、确定jdk版本"><a href="#2、确定jdk版本" class="headerlink" title="2、确定jdk版本"></a>2、确定jdk版本</h4><blockquote><p>确定jdk 已经安装和配置(要求jdk版本最低1.8) </p></blockquote><p>​        <img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095527.jpg"></p><hr><h4 id="3、解压"><a href="#3、解压" class="headerlink" title="3、解压"></a>3、解压</h4><blockquote><p>把maven3.3.3解压到放到任意磁盘以及任意文件夹，注意:解压路径不要有中文 </p></blockquote><p>​        <img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095528.png"  /></p><hr><h4 id="4、确定IDEA版本"><a href="#4、确定IDEA版本" class="headerlink" title="4、确定IDEA版本"></a>4、确定IDEA版本</h4><blockquote><p>idea和maven的版本一定要兼容，我这里使用的idea版本:</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095529.png"></p><hr><h4 id="5、配置环境变量"><a href="#5、配置环境变量" class="headerlink" title="5、配置环境变量"></a>5、配置环境变量</h4><blockquote><p>“计算机”右键-&gt;“属性”-&gt;”高级系统设置”-&gt;“高级”-&gt;”环境变量”-&gt;”系统变量”-&gt;”新建” </p></blockquote><p><strong>添加系统变量：</strong></p><ul><li><p>变量名:M2_HOME （固定值） </p></li><li><p>变量值:F:\Maven\apache-maven-3.3.3（maven中bin文件夹的全路径） </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095530.png"></p></li></ul><p><strong>配置系统变量：</strong></p><p>在变量值的最前面添加下面代码:<code>%M2_HOME%\bin </code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095531.png"></p><hr><h6 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h6><p>打开cmd运行命令: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn –version</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095532.png"></p><p>若没有正确配置环境变量，可能显示找不到命令</p><hr><h3 id="Pom-xml"><a href="#Pom-xml" class="headerlink" title="Pom.xml"></a>Pom.xml</h3><p>Pom.xml文件说明: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 版本：4.0.0 --&gt;</span>                     <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 组织名称：暂时使用 组织名称+项目名称 作为组织名称 --&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 组织名称：实际名称 按照访问路径规范设置，通常以功能作为名称： eg: junit spring --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 当前项目版本号：同一个项目开发过程中可以发布多个版本，此处标示0.0.1版 --&gt;</span>      <span class="comment">&lt;!-- 当前项目版本号：每个工程发布后可以发布多个版本，依赖时调取不同的版本，使用不同的版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 名称：可省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖设置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖组织名称 --</span></span><br><span class="line"><span class="comment"> &lt;groupId&gt;junit&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment"> &lt;!-- 依赖项目名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖版本名称 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖范围：test包下依赖该设置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="搭建一个原生的Maven项目"><a href="#搭建一个原生的Maven项目" class="headerlink" title="搭建一个原生的Maven项目"></a>搭建一个原生的Maven项目</h3><p>1)通过文件夹的方式创建java项目 :</p><p>目录结构如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在某个磁盘的根目录按照下面结构创建文件夹</span><br><span class="line">ProjectName</span><br><span class="line">• |-src </span><br><span class="line">• |-main </span><br><span class="line">• |-java —— 存放项目的.java文件</span><br><span class="line">|-resources —— 存放项目资源文件 </span><br><span class="line">• |-test</span><br><span class="line">|-java ——存放所有测试.java文件，如JUnit测试类</span><br><span class="line">  |-target —— 目标文件输出位置例如.class、.jar、.war文件（不需要创建，会自动生成）     |-pom.xml ——maven项目核心配置文件</span><br></pre></td></tr></table></figure><p>2)src/main/java下创建目录，存放java代码</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095533.png"  /><p>注意:包目录是:com.kkb,而不包含前面的路径 </p><p>3)新建java文件,编写java代码</p><p>~~这里输出的内容最好是英文，中文会出乱码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kkb; <span class="comment">//注意这里的包路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;maven test success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4)在test/java文件夹下创建测试类的包结构</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095534.png"  /><p>5)编写测试类 </p><p>示例的包路径是:com.testkkb,</p><p>测试类文件名:TestDemo.java,</p><p>这里输出的内容最好是英文，中文会出乱码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testkkb;</span><br><span class="line"><span class="keyword">import</span> com.kkb.Demo;<span class="comment">//这里导入Demo类所在包，注意包路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;<span class="comment">//这里导入junit测试包，注意我们还没有给项目中添加依赖包 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I want get Demo Class&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Demo().test1();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6)在src同级文件夹下存放pom.xml文件</p><p>目的：这里开始引入Junit工具包 </p><p>注意:此时还未有target目录</p><p><img src= "/img/loading.gif" data-lazy-src="../../../Typora_%E5%B7%A5%E5%85%B7%E7%B1%BB/maven_%E4%BD%BF%E7%94%A8/images/pom_xml%E6%96%87%E4%BB%B6.png"></p><p>添加内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt; </span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.kkb.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;HelloWorld&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 依赖关系 --&gt;</span><br><span class="line">    &lt;dependencies&gt; </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>7)通过maven命令行的方式运行项目</p><p>打开cmd后，进入到项目文件夹，运行<code>mvn test</code>命令进行junit测试</p><p><img src= "/img/loading.gif" data-lazy-src="../../../Typora_%E5%B7%A5%E5%85%B7%E7%B1%BB/maven_%E4%BD%BF%E7%94%A8/images/%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9.png"></p><p>命令运行完后，程序会自动下载所需的依赖包，注意这里<strong>不仅仅是junit测试包，还有maven环境的依赖包</strong>，所以需 要耐心等待一段时间。这里依赖包会下载到本地磁盘，后续再使用的时候就不会重新下载了。 </p><hr><ol start="8"><li>运行结果:</li></ol><p>会在src同级目录下<code>生成target文件夹</code>，在cmd命令界面可以看到运行结果，说明maven项目结构运行成功。 </p><p><img src= "/img/loading.gif" data-lazy-src="../../../Typora_%E5%B7%A5%E5%85%B7%E7%B1%BB/maven_%E4%BD%BF%E7%94%A8/images/%E6%9E%84%E5%BB%BA%E7%BB%93%E6%9E%9C.png"></p><hr><h3 id="Maven-常用指令"><a href="#Maven-常用指令" class="headerlink" title="Maven_常用指令"></a>Maven_常用指令</h3><blockquote><p>前提：需要在 pom.xml 所在目录中执行以下命令。</p></blockquote><h5 id="1-Mvn-compile-编译"><a href="#1-Mvn-compile-编译" class="headerlink" title="1)Mvn compile_编译"></a>1)Mvn compile_编译</h5><ul><li>执行 <code>mvn compile</code>命令，完成编译操作 。</li><li>执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</li></ul><hr><h5 id="2-Mvn-clean-清除"><a href="#2-Mvn-clean-清除" class="headerlink" title="2)Mvn clean_清除"></a>2)Mvn clean_清除</h5><ul><li>执行 mvn clean命令,执行完毕后，会将target目录删除。 </li></ul><hr><h5 id="3-Mvn-test-测试"><a href="#3-Mvn-test-测试" class="headerlink" title="3)Mvn test _测试"></a>3)Mvn test _测试</h5><ul><li><p>执行 mvn test命令，完成单元测试操作。</p></li><li><p>执行完毕后，会在target目录中生成三个文件夹：</p><p>surefifire、 surefifire- reports（测试报告）、test-classes（测试的字节码文件）</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095535.png"></p><hr></li></ul><h5 id="4-Maven-package-打包"><a href="#4-Maven-package-打包" class="headerlink" title="4)Maven package_打包"></a>4)Maven package_打包</h5><ul><li>执行 mvn package命令，完成打包操作。</li><li>执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095536.png"></p><hr><h5 id="5-Mvn-install-部署"><a href="#5-Mvn-install-部署" class="headerlink" title="5)Mvn install _部署"></a>5)<strong>Mvn install</strong> _部署</h5><ul><li>执行 mvn install 命令，完成将打好的jar包安装到本地仓库的操作。</li><li>执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用。</li></ul><hr><p>如何查看本地仓库位置:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095537.png"></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095538.png" style="zoom: 80%;" /><p>打包到本地仓库的jar包</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095539.png"></p><hr><h5 id="6-mvn-clean-compile-清除并编译"><a href="#6-mvn-clean-compile-清除并编译" class="headerlink" title="6)mvn clean compile_清除并编译"></a>6)mvn clean compile_清除并编译</h5><ul><li>cmd 中录入 mvn clean compile 命令 </li><li>组合指令，先执行clean，再执行compile，通常应用于<strong>上线前执行</strong>，清除测试类 。</li></ul><hr><h5 id="7-mvn-clean-test-清除并测试"><a href="#7-mvn-clean-test-清除并测试" class="headerlink" title="7)mvn clean test_清除并测试"></a>7)mvn clean test_清除并测试</h5><ul><li>cmd 中录入 mvn clean test 命令 </li><li>组合指令，先执行clean，再执行test，通常应用于<strong>测试环节</strong> </li></ul><hr><h5 id="8-mvn-clean-package-清除并打包"><a href="#8-mvn-clean-package-清除并打包" class="headerlink" title="8)mvn clean package_清除并打包"></a>8)mvn clean package_清除并打包</h5><ul><li>cmd 中录入 mvn clean package命令 </li><li>组合指令，先执行clean，再执行package，将项目打包，通常应用于<strong>发布前</strong> </li></ul><p>执行过程： </p><ul><li>清理————清空环境 </li><li>编译————编译源码 </li><li>测试————测试源码 </li><li>打包————将编译的非测试类打包 </li></ul><hr><h5 id="9-mvn-clean-install-清除并部署"><a href="#9-mvn-clean-install-清除并部署" class="headerlink" title="9)mvn clean install_清除并部署"></a>9)mvn clean install_清除并部署</h5><ul><li>cmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中 </li><li>组合指令，先执行clean，再执行install，将项目打包，通常应用于<strong>发布前</strong> </li></ul><p>执行过程： </p><ul><li>清理————清空环境 </li><li>编译————编译源码 </li><li>测试————测试源码 </li><li>打包————将编译的非测试类打包 </li><li>部署————将打好的包发布到资源仓库中 </li></ul><hr><h3 id="IDEA搭建Maven项目"><a href="#IDEA搭建Maven项目" class="headerlink" title="IDEA搭建Maven项目"></a>IDEA搭建Maven项目</h3><h4 id="搭建Java项目"><a href="#搭建Java项目" class="headerlink" title="搭建Java项目"></a>搭建Java项目</h4><h5 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h5><p>主界面中选择<code>Create New Project</code>,然后在左侧项目类型中选择<code>Maven</code></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095540.jpg"  /><hr><p>Maven 项目结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095541.png"></p><hr><p>补充: </p><ul><li>maven中的仓库分为两种，<strong>snapshot快照仓库</strong>和<strong>release发布仓</strong>库。</li><li>snapshot快照仓库用于保存<strong>开发过程中 的不稳定版本</strong>，release正式仓库则是用来保存<strong>稳定的发行版本。</strong></li><li>定义一个组件/模块为快照版本，只需要在pom文 件中在该模块的版本号后加上**-SNAPSHOT**即可(注意这里必须是大写)。 maven2会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。</li><li>如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情 况下，直接编译打包时，maven会<strong>自动从镜像服务器上下载最新的快照版本。</strong></li><li>如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块<strong>则不会主动去镜像服务器上下载。</strong></li></ul><hr><h5 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h5><h6 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1)添加依赖"></a>1)添加依赖</h6><p>在pom.xml文件中添加junit依赖包 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你之前安装过jdk版本..此时maven不知道你用的哪个,需要指定一下，比如我这里用的JDK11</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--多个jdk版本存在时--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完依赖包后，可以在左侧External Libraries目录下查看依赖包，此时TestDemo1.java文件不再报错 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095542.png"></p><hr><h6 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2)编写代码"></a>2)编写代码</h6><blockquote><p>在src/main/java下编写java代码，在src/test/java下编写测试代码</p></blockquote><p>Java代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xj0927;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-09-08 19:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Demo方法~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a>3）测试</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testxj0927;</span><br><span class="line"><span class="keyword">import</span> com.xj0927.Demo;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-09-08 19:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Test</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是Demo测试类的方法~&quot;</span>);</span><br><span class="line">            Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">            demo.test(); </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="4）正常运行"><a href="#4）正常运行" class="headerlink" title="4）正常运行"></a>4）正常运行</h6><hr><h4 id="搭建Java-Web项目"><a href="#搭建Java-Web项目" class="headerlink" title="搭建Java Web项目"></a>搭建Java Web项目</h4><h5 id="1、创建项目-1"><a href="#1、创建项目-1" class="headerlink" title="1、创建项目"></a>1、创建项目</h5><blockquote><p>选择create New Project,左侧选择Maven,勾选右侧Create from archetype选项，选择下面区域中的 <code>maven-archetype-webapp</code>类型。 </p></blockquote><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095543.png"  /><hr><p><strong>补充:</strong></p><blockquote><p>archetype的意思就是<strong>模板原型</strong>的意思，原型是一个Maven项目模板工具包。</p></blockquote><p>开发中常用的archetype类型:</p><ul><li><code>maven-archetype-quickstart</code>(简单的java类型项目,除了pom.xml外，没有其他的xml了，但是有main、test两个包，包里放了一个App、AppTest类) </li><li><code>maven-archetype-webapp</code>(一个简单的Java Web应用程序)</li></ul><hr><h5 id="2、项目名称"><a href="#2、项目名称" class="headerlink" title="2、项目名称"></a>2、项目名称</h5><h5 id="3、配置属性"><a href="#3、配置属性" class="headerlink" title="3、配置属性"></a>3、配置属性</h5><h6 id="方式一：一次配置"><a href="#方式一：一次配置" class="headerlink" title="方式一：一次配置"></a>方式一：一次配置</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在Properties选项卡中，点击“＋”号，添加新属性 </span></span><br><span class="line">Name: archetypeCatalog </span><br><span class="line">Value :internal </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095544.png"></p><hr><h6 id="方式二：永久配置"><a href="#方式二：永久配置" class="headerlink" title="方式二：永久配置"></a>方式二：永久配置</h6><blockquote><p>在idea的主界面选择confifigure-&gt;settings</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095545.png"></p><hr><p>在搜索框中搜索:<code>runner</code>,在<code>VM Option选项卡</code>中添加配置代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DarchetypeCatalog&#x3D;internal</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095546.png"  /><p>保存退出后，重新启动软件。</p><hr><h3 id="修改本地仓库"><a href="#修改本地仓库" class="headerlink" title="修改本地仓库"></a>修改本地仓库</h3><h4 id="1、找到setting文件路径"><a href="#1、找到setting文件路径" class="headerlink" title="1、找到setting文件路径"></a>1、找到setting文件路径</h4><blockquote><p>maven路径的conf文件夹下</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095537.png"></p><hr><h4 id="2、默认仓库路径"><a href="#2、默认仓库路径" class="headerlink" title="2、默认仓库路径"></a>2、默认仓库路径</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095538.png"></p><hr><h4 id="3、修改Maven默认仓库"><a href="#3、修改Maven默认仓库" class="headerlink" title="3、修改Maven默认仓库"></a>3、修改Maven默认仓库</h4><blockquote><p>在任意磁盘下创建一个文件夹目录，该文件夹配置成你的本地仓库路径。</p><p>将localRepository标签配置到注释代码的外面，如上图↑</p></blockquote><hr><h3 id="IDEA改变maven版本"><a href="#IDEA改变maven版本" class="headerlink" title="IDEA改变maven版本"></a>IDEA改变maven版本</h3><blockquote><p>我们现在使用的idea都自带maven,但是实际开发中，可能idea自带的版本和我们使用的框架或jdk版本不兼容，那 么就需要我们更改idea中的maven版本。 </p></blockquote><h4 id="1、搜索“maven”"><a href="#1、搜索“maven”" class="headerlink" title="1、搜索“maven”"></a>1、搜索“maven”</h4><p>打开idea主界面，选择Confifigure-&gt;Setting,在搜索框搜索“maven”</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095547.png"  /><hr><h4 id="2、修改路径"><a href="#2、修改路径" class="headerlink" title="2、修改路径"></a>2、修改路径</h4><ul><li>修改<code>Maven home directory路径</code>，改成自己的<code>maven安装路径 </code></li><li>此时local repository会自动更新成我们修改的<code>本地仓库路径</code></li><li>修改settiing配置文件的路径，点击User settings fifile 选项后的<code>override</code>选项卡 </li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095548.png"  /><p>保存退出！！！</p><hr><h3 id="Maven相关概念"><a href="#Maven相关概念" class="headerlink" title="Maven相关概念"></a>Maven相关概念</h3><h4 id="maven-坐标"><a href="#maven-坐标" class="headerlink" title="maven_坐标"></a>maven_坐标</h4><blockquote><p>在maven中坐标就是为了<strong>定位一个唯一确定的jar包</strong>。</p><p>Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范。拥有了统一规范，就可以把查找工作交给机器 。</p></blockquote><p>坐标组成：</p><ul><li>groupId：定义当前Maven组织名称 </li><li>artifactId：定义实际项目名称 </li><li>version：定义当前项目的当前版本或者是所依赖的jar包的版本 </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demoProject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--快照版--&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="maven-特性"><a href="#maven-特性" class="headerlink" title="maven_特性"></a>maven_特性</h4><h5 id="1-依赖性"><a href="#1-依赖性" class="headerlink" title="1.依赖性"></a>1.依赖性</h5><h6 id="1-依赖管理"><a href="#1-依赖管理" class="headerlink" title="1)依赖管理"></a>1)依赖管理</h6><blockquote><p>就是<strong>对项目中jar 包的管理</strong>。可以在pom文件中定义jar包的<strong>GAV坐标</strong>，管理依赖。 </p></blockquote><p>依赖声明主要包含如下元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="2-依赖范围"><a href="#2-依赖范围" class="headerlink" title="2)依赖范围"></a>2)依赖范围</h6><p>即scope的属性值:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095549.png"></p><p><strong>scope属性值介绍:</strong> </p><p>1.compile ：编译范围，默认scope，在工程环境的 classpath（编译环境）和打包（<strong>如果是WAR包，会包含在WAR包中</strong>）时候都有效。 </p><p>2.provided ：容器或JDK已提供范围，表示该依赖包已经由目标容器（如tomcat）和JDK提供，只在编译的classpath中加载和使 用，<strong>打包的时候不会包含在目标包中 。</strong>最常见的是j2ee规范相关的servlet-api和jsp-api等jar包，一般由servlet容 器提供，无需在打包到war包中，如果不配置为provided，把这些包打包到工程war包中，在tomcat6以上版本会 出现冲突无法正常运行程序<strong>（版本不符的情况）。</strong> </p><p>3.runtime ：一般是运行和测试环境使用，编译时候不用加入classpath，<strong>打包时候会打包到目标包中</strong>。一般是通过动态加载或 接口反射加载的情况比较多。也就是说程序只使用了接口，具体的时候可能有多个，运行时通过配置文件或jar包扫 描动态加载的情况。典型的包括：JDBC驱动等。 </p><p>4.test ：测试范围，一般是单元测试场景使用，在编译环境加入classpath，但<strong>打包时不会加入</strong>，如junit等。 </p><p>5.system（一般不用，不同机器可能不兼容） ：系统范围，与provided类似，只是标记为该scope的依赖包需要明确指定基于文件系统的jar包路径。因为需要通过 systemPath指定本地jar文件路径，所以该scope是不推荐的。如果是基于组织的，一般会建立本地镜像，会把本 地的或组织的基础组件加入本地镜像管理，避过使用该scope的情况。</p><hr><h5 id="2-传递性"><a href="#2-传递性" class="headerlink" title="2.传递性"></a>2.传递性</h5><h6 id="1-直接依赖和间接依赖"><a href="#1-直接依赖和间接依赖" class="headerlink" title="1)直接依赖和间接依赖"></a>1)直接依赖和间接依赖</h6><p>如果B中使用A，C中使用B，则称B是C的<strong>直接依赖，</strong>而称A是C的<strong>间接依赖</strong>。 </p><ul><li>C-&gt;B  B-&gt;A </li><li>C直接依赖B </li><li>C间接依赖A </li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095550.png"></p><p><strong>依赖范围与依赖传递关系：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095551.png"></p><p>左边第一列表示第一直接依赖范围 </p><p>上面第一行表示第二直接依赖范围 </p><p>中间的交叉单元格表示传递性依赖范围。 </p><p>总结： </p><ul><li>(1) 当第二依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。 </li><li>(2) 当第二直接依赖的范围是test的时候，依赖不会得以传递。 </li><li>(3) 当第二依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为 provided； </li><li>(4) 当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递的依赖范围为runtime； </li></ul><hr><p><strong>依赖冲突_解决措施:</strong></p><ul><li>(1) 如果直接与间接依赖中包含有同一个坐标不同版本的资源依赖，以<strong>直接依赖的版本</strong>为准（就近原则） </li><li>(2) 如果直接依赖中包含有同一个坐标不同版本的资源依赖，以<strong>配置顺序下方的版本</strong>为准（就近原则） </li></ul><p><strong>可选依赖_设置方法:</strong></p><ul><li>true/false 用于设置是否可选，也可以理解为jar包是否向下传递。 </li><li>在依赖中添加optional选项决定此依赖是否向下传递，如果是true则不传递，如果是false就传递，<strong>默认为false</strong>。 </li></ul><p><strong>排除依赖_解决方法：</strong></p><p>在<code>直接依赖的配置</code>里面添加<code> exclusions→exclusion 元素</code>，指定要排除依赖的 groupId 和 artifactId 就行，如下面代码所示。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明:排除依赖包中所包含的依赖关系，<code>不需要添加版本号</code>。 </p><hr><h5 id="3-继承性"><a href="#3-继承性" class="headerlink" title="3.继承性"></a>3.继承性</h5><p>在一家开发公司里，很多项目中使用的jar包里80%是重复的，难道要每个项目都把这些pom.xml文件的依赖包复 制过来吗？如果后期出现统一的版本升级，那岂不是修改起来也很麻烦？如何解决呢？这里可以使用maven的继承特性来消除重复依赖，可以<strong>把很多相同的配置提取出来</strong>。例如：grouptId，version等 </p><p><strong>实现maven继承性的步骤:</strong> </p><h6 id="1、创建父工程："><a href="#1、创建父工程：" class="headerlink" title="1、创建父工程："></a>1、创建父工程：</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095552.png"></p><p>注意这类项目和原来项目的区别在于，打包方式是<code>pom</code>:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095553.jpg"></p><p>由于pom项目一般都是用来做父项目的，所以该项目的<code>src文件夹可以删除掉</code>。 </p><hr><h6 id="2、创建子工程"><a href="#2、创建子工程" class="headerlink" title="2、创建子工程:"></a>2、创建子工程:</h6><p>方式一：创建新工程为子工程，在创建时设置父工程的GAV。 </p><p>方式二：修改原有的工程为子工程，在子工程的pom.xml文件中手动添加父工程的GAV </p><p><strong>步骤：</strong>可以是java项目，也可以是java_web项目</p><p>先选中父项目的项目名，然后再按照图片步骤执行 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095554.png"></p><p>结果:在子项目的pom文件中，默认通过 parent 标签来继承父项目中的依赖包。这样避免了依赖包的重复依赖 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095555.png"></p><hr><h5 id="父工程统一管理版本号"><a href="#父工程统一管理版本号" class="headerlink" title="父工程统一管理版本号"></a>父工程统一管理版本号</h5><p>在开发中依赖的jar包众多，对应的版本也是很杂乱，那有没有一种方式可以统一管理这么jar包的版本值呢？当然 是有的，Maven使用<code>dependencyManagement</code>来管理依赖的版本号。 </p><p>注意：此处只是定义依赖jar包的版本号，并不实际依赖。如果子工程中需要依赖jar包还需要<code>添加dependency节点</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父工程：声明版本</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">子工程：不需要指定版本号(先继承父元素)</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>father<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--这里不需要指定版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="父工程中版本号提取"><a href="#父工程中版本号提取" class="headerlink" title="父工程中版本号提取"></a>父工程中版本号提取</h5><p>当父工程中定义的jar包越来越多，找起来越来越麻烦，所以可以<strong>把版本号提取成一个属性集中管理</strong>。 </p><p>定义版本：注意这里的 <code>log4j.version</code>的值是自定义的，但命名时不要使用中文或特殊字符等，标签对中间写版本值 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用:<code>$&#123;log4j.version&#125;</code>读取该变量值，代码如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子工程的jar包版本不受影响</p><hr><h4 id="maven-生命周期"><a href="#maven-生命周期" class="headerlink" title="maven_生命周期"></a>maven_生命周期</h4><blockquote><p> Maven生命周期就是为了对所有的构建过程进行抽象和统一。包括<strong>项目清理、初始化、编译、打包、测试、部署等几乎所有构建步骤</strong>。</p><p> 生命周期可以理解为构建工程的步骤。 </p></blockquote><p>三套相互独立的生命周期：</p><ul><li>(1) Clean Lifecycle： 在进行真正的构建之前进行一些<strong>清理工作</strong>。 Mvn clean </li><li>(2) Default Lifecycle： 构建的核心部分，编译，测试，打包，部署等等。 Mvn compile test package install deploy </li><li>(3) Site Lifecycle： <strong>生成项目报告</strong>，站点，发布站点。mvn site </li></ul><hr><h5 id="clean：清理项目"><a href="#clean：清理项目" class="headerlink" title="clean：清理项目"></a>clean：清理项目</h5><blockquote><p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean ，这个的clean是Clean生命周期的一个阶段。有Clean生命周期，也有clean阶段。</p></blockquote><p>Clean生命周期一共 包含了三个阶段： </p><ul><li>pre-clean:执行清理前需要完成的工作 </li><li>clean:清理上一次构建过程中生成的文件，比如编译后的class文件等。 </li><li>post-clean:执行清理后需要完成的工作 </li></ul><hr><h5 id="default：构建项目"><a href="#default：构建项目" class="headerlink" title="default：构建项目"></a>default：构建项目</h5><blockquote><p>Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些 </p></blockquote><p>比较重要和常用的阶段： </p><ul><li>validate 验证项目结构是否正常，必要的配置文件是否存在 </li><li>initialize 做构建前的初始化操作，比如初始化参数，创建必要的目录等 </li><li>generate-sources 产生在编译过程中需要的源代码 </li><li>process-sources 处理源代码，比如过滤值 </li><li><strong>generate-resources</strong> 产生主代码中的资源在classpath中的包 </li><li><strong>process-resources</strong> 复制并处理资源文件，至目标目录，准备打包。 </li><li><strong>compile</strong> 编译项目的源代码。 </li><li>process-classes 产生编译过程中生成的文件 </li><li>generate-test-sources 产生编译过程中测试相关的代码 </li><li>process-test-sources 处理测试代码 </li><li><strong>generate-test-resources</strong> 产生测试中资源在classpath中的包 </li><li><strong>process-test-resources</strong> 复制并处理资源文件，至目标测试目录</li><li><strong>test-compile</strong> 编译测试源代码。 </li><li>process-test-classes 产生编译测试代码过程的文件 </li><li><strong>test</strong> 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 </li><li>prepare-package 处理打包前需要初始化的准备工作 </li><li>package 接受编译好的代码，打包成可发布的格式，如 JAR 。 </li><li>pre-integration-test 做好集成测试前的准备工作，比如集成环境的参数设置 </li><li>integration-test 集成测试 </li><li>post-integration-test 完成集成测试前的准备工作，比如集成环境的参数设置 </li><li>verify 检测测试后的包是否完好 </li><li><strong>install</strong> 将包安装至本地仓库，以让其它项目依赖。 </li><li><strong>deploy</strong> 将最终的包复制到远程的仓库，以让其它开发人员与项目共享</li></ul><p><strong>运行任何一个阶段的时候，它前面的所有阶段都会被运行</strong>，这也就是为什么我们运行mvn install 的时候，代码会 被编译，测试，打包。此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要。 </p><hr><h5 id="site：生成项目站点"><a href="#site：生成项目站点" class="headerlink" title="site：生成项目站点"></a>site：生成项目站点</h5><p>Site生命周期 </p><ul><li>pre-site 执行一些需要在生成站点文档之前完成的工作 </li><li>site 生成项目的站点文档 </li><li>post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 </li><li>site-deploy 将生成的站点文档部署到特定的服务器上 </li></ul><p>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能， Manager比较喜欢，文档及统计数据自动生成，很好看。 </p><hr><h4 id="maven-插件"><a href="#maven-插件" class="headerlink" title="maven_插件"></a>maven_插件</h4><blockquote><p>Maven的核心仅仅定义了抽象的生命周期，<strong>具体的任务都是交由插件完成的</strong>。每个插件都能实现一个功能，每个功能就是一个插件目标。<strong>Maven的生命周期与插件目标相互绑定</strong>，以完成某个具体的构建任务。 </p></blockquote><p>compile就是插件<code>maven-compiler-plugin</code>的一个插件目标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接修改maven的<code>setting.xml</code>文件 在里面添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="Tomcat插件"><a href="#Tomcat插件" class="headerlink" title="Tomcat插件"></a>Tomcat插件</h5><blockquote><p>我们之前创建的web项目都需要额外配置tomcat以后才能运行项目，现在maven提供了tomcat插件，这样我们就无需再添加额外的tomcat了。</p></blockquote><p>1、创建maven类型的web工程</p><p>2、pom.xml文件中添加插件信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、点击“add confifiguration”,按照图片中的步骤添加tomcat命令，运行tomcat插件</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095556.jpg"></p><hr><p>运行方式1: </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 运行tomcat6（默认） </span></span><br><span class="line">tomcat:run </span><br></pre></td></tr></table></figure><p>运行方式2: </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 运行tomcat7（推荐，但是需要添加插件） </span></span><br><span class="line">tomcat7:run </span><br></pre></td></tr></table></figure><hr><h4 id="maven-私服"><a href="#maven-私服" class="headerlink" title="maven_私服"></a>maven_私服</h4><h5 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h5><p>仓库的分类 :</p><ul><li><p>本地仓库 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 每个用户只有一个本地仓库 </span></span><br><span class="line">~/.m2/repository </span><br></pre></td></tr></table></figure></li><li><p>远程仓库 </p><p>中央仓库：Maven默认的远程仓库，不包含版权资源 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2 </span><br></pre></td></tr></table></figure><p>私服：是一种特殊的远程仓库，它是架设<code>在局域网内的仓库 </code></p></li></ul><hr><h5 id="Nexus搭建与使用"><a href="#Nexus搭建与使用" class="headerlink" title="Nexus搭建与使用"></a>Nexus搭建与使用</h5><h6 id="1、安装Nexus"><a href="#1、安装Nexus" class="headerlink" title="1、安装Nexus"></a>1、安装Nexus</h6><p>下载网站：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 安装JDK1.8以上的版本 </span></span><br><span class="line">https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3 </span><br></pre></td></tr></table></figure><hr><h6 id="2、解压nexus压缩包"><a href="#2、解压nexus压缩包" class="headerlink" title="2、解压nexus压缩包"></a>2、解压nexus压缩包</h6><h6 id="3、注册服务"><a href="#3、注册服务" class="headerlink" title="3、注册服务"></a>3、注册服务</h6><p>打开window的命令窗口，切换到解压的文件夹中bin目录下，运行<code>nexus.exe /install nexus</code>命令，注册服务</p><h6 id="4、启动Nexus服务"><a href="#4、启动Nexus服务" class="headerlink" title="4、启动Nexus服务"></a>4、启动Nexus服务</h6><p>在bin文件夹下运行<code>nexus /run</code>命令 </p><p>注意:启动命令会因为版本不同，指令也不同 </p><h6 id="5、打开网站"><a href="#5、打开网站" class="headerlink" title="5、打开网站"></a>5、打开网站</h6><p><a href="http://localhost:8081/">http://localhost:8081</a> </p><p>使用默认的用户名和密码登陆（admin/admin123） </p><p>查看现有仓库: </p><ul><li><p>proxy 表示远程获取 </p></li><li><p>group 组 </p></li><li><p>hosted 本机，第三方jar，如数据库驱动等，需要手动添加   </p></li><li><p>maven-central：maven中央库，默认从<a href="https://repo1.maven.org/maven2/%E8%8E%B7%E5%8F%96jar">https://repo1.maven.org/maven2/获取jar</a> </p></li><li><p>maven-releases：私库发行版jar </p></li><li><p>maven-snapshots：私库快照（调试版本）jar </p></li><li><p>maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml中使用</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095557.jpg"></p><hr><h6 id="6、使用"><a href="#6、使用" class="headerlink" title="6、使用"></a>6、使用</h6><blockquote><p>配置所有构建均从私服下载 </p></blockquote><p>1）添加镜像配置,将所有访问外网仓库的请求指向私服； </p><p>settings.xml文件 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> <span class="comment">&lt;!--匹配所有的远程仓库--&gt;</span>              <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明:url配置，描述的便是 上一步中提到的那个<strong>Public Reposiories</strong>的信息，这个地址便是他的地址，这些写都可以在界面上看到 ,这里的是localhost是在本机搭建测试用的,如果是公司内部的仓库的话，可自行修改成公司内网ip 地址</p><hr><p>2）添加中央仓库配置 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>3）生效配置 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="配置阿里云镜像仓库"><a href="#配置阿里云镜像仓库" class="headerlink" title="配置阿里云镜像仓库"></a>配置阿里云镜像仓库</h3><blockquote><p>阿里云镜像仓库是国内服务器，下载速度更快。 </p></blockquote><p>修改setting文件: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="2021/02/17/%E5%B7%A5%E5%85%B7/Git/"/>
      <url>2021/02/17/%E5%B7%A5%E5%85%B7/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git版本控制"><a href="#Git版本控制" class="headerlink" title="Git版本控制"></a>Git版本控制</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li><p>多个开发人员共同负责同一个软件或文档的开发，每个人在各自的机器上有整个软件文档的备份，并对之实施编程开发，在分别完成各自任务之后，再通过文本比对工具将各自机器上的不同版本的程序整合到一台机器上。</p></li><li><p><strong>实现开发团队并行开发、提高开发效率的基础。</strong></p></li><li><p><strong>对软件开发进程中文件或目录的发展过程提供有效的追踪手段，</strong>保证在需要时可回到旧的版本，避免文件的丢失、修改的丢失和相互覆盖，通过对版本库的访问控制避免未经授权的访和修改，达到有效保护企业软件资产和知识产权的目的。</p></li><li><p><strong>版本控制的功能在于跟踪记录整个软件的开发过程</strong>，包括软件本身和相关文档，以便对不同阶段的软件及相关文档进行表示并进行差别分析，对软件代码进行可撤消的修改，便于汇总不同开发人员所做的修改，辅助协调和管理软件开发团队。</p></li></ul><hr><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>1)Visual Source Safe(简称VSS）</p><ul><li><p>VSS是美国微软公司的产品，目前常用的版本为6.0版。VSS是配置管理的一种很好的入门级的工具。</p></li><li><p>VSS只能在<strong>windows</strong>平台上运行，不能运行在其他操作系统上。</p></li><li><p>VSS提供share（共 享)、branch(分支）和合并（merge)的功能，对于团队的开发进行支持。VSS不提供对流程的管理功能，如对变更的流程进行控制。</p></li><li><p>VSS不能提供对异地团队开发的支持。</p></li><li><p>VSS的安全性不高，对于VSS的用户，可以在文件夹上设置不可读，可读，可读/写,可完全控制四级权限</p></li></ul><p>2)Concurrent Version System(简称CVS）</p><ul><li><p>CVS是源于<strong>unix</strong>的版本控制工具。</p></li><li><p>跨平台。</p></li><li><p>同样因为CVS是开发源码软件，没有生产厂家为其提供技术的支持。如发现问题，通常只能靠自己查找网上的资料进行解决。</p></li></ul><p>3)SVN *</p><p>全名Subversion，即版本控制系统。</p><ul><li><strong>跨平台</strong>的软件，支持大多数常见的操作系统。</li><li>作为一个<strong>开源的版本控制系统</strong>,Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。</li></ul><p>4)Git *</p><ul><li>开源的<strong>分布式版本控制</strong>系统。</li><li>以有效、高速的处理从很小到非常大的项目版本管理。</li></ul><hr><h3 id="Git与SVN的区别"><a href="#Git与SVN的区别" class="headerlink" title="Git与SVN的区别"></a>Git与SVN的区别</h3><ol><li><p>Git 是分布式的，SVN 不是：</p><p>这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</p></li><li><p>Git 把内容按元数据方式存储，而 SVN 是按文件：</p><p>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.git 等的文件夹里。</p></li><li><p>Git 分支和 SVN 的分支不同：</p><p>Git 有本地分支，SVN 无本地分支。在实际开发过程中，经常会遇到有些代码没写完，但是需紧急处理其他问题，若我们使用 Git，便可以创建本地分支存储没写完的代码，待问题处理完后，再回到本地分支继续完成代码。</p></li><li><p>Git 没有一个全局的版本号，而 SVN 有：</p><p>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</p></li><li><p>Git 的内容完整性要优于 SVN：</p><p>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094716.jpg"></p><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>百度云链接：<a href="https://pan.baidu.com/s/1jysewPgEJV1W0-_X2nhYJw">https://pan.baidu.com/s/1jysewPgEJV1W0-_X2nhYJw</a><br>提取码：s1qb</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094717.png"  /><p>检验是否安装成功,桌面上鼠标右击后:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094718.png"></p><hr><h3 id="Git的工作区域"><a href="#Git的工作区域" class="headerlink" title="Git的工作区域"></a>Git的工作区域</h3><p>一共三个区域</p><ul><li>(1)工作区:用来对代码进行修改</li><li>(2)暂存区</li><li>(3)git仓库区</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094719.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 初始化仓库</span></span><br><span class="line"></span><br><span class="line">(1)新建文件夹，进入到该目录,右键打开<span class="code">`git bash`</span></span><br><span class="line"></span><br><span class="line">(2)在文件夹内初始化git(创建git仓库):(会生成一个.git的隐藏文件)</span><br><span class="line"> git init </span><br></pre></td></tr></table></figure><p>显示隐藏文件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094720.png"></p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 工作区---&gt;暂存区：</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 添加单个文件到暂存区</span></span><br><span class="line">git add 文件名 </span><br><span class="line"></span><br><span class="line"><span class="section"># 添加多个文件到暂存区</span></span><br><span class="line">git add <span class="emphasis">*</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094721.png"></p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 暂存区---&gt;仓库</span></span><br><span class="line">git commit -m &#x27;描述信息&#x27;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094722.png"></p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 删除文件</span></span><br><span class="line">git rm  文件名  </span><br><span class="line">git commit -m &#x27;提交描述&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 删除文件夹</span></span><br><span class="line">git rm -r 文件夹名</span><br><span class="line">git commit -m &#x27;提交描述&#x27;</span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code"># 当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制</span></span><br><span class="line"><span class="code">git rm -r --cached 文件夹名称</span></span><br><span class="line"><span class="code">git commit -m &#x27;提交描述&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Git远程服务器"><a href="#Git远程服务器" class="headerlink" title="Git远程服务器"></a>Git远程服务器</h3><h5 id="1-GitHub"><a href="#1-GitHub" class="headerlink" title="1) GitHub"></a>1) GitHub</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问地址:https:&#x2F;&#x2F;github.com&#x2F;</span><br></pre></td></tr></table></figure><h5 id="2-GitLab"><a href="#2-GitLab" class="headerlink" title="2) GitLab"></a>2) GitLab</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问地址:https:&#x2F;&#x2F;git.lug.ustc.edu.cn&#x2F;users&#x2F;sign_in</span><br></pre></td></tr></table></figure><p>GitHub 作为开源代码库，拥有超过 900 万的开发者用户，目前仍然是最火的开源项目托管平台，GitHub 同时提供公共仓库和私有仓库，但如果使用私有仓库，是需要付费的。<strong>GitLab 解决了这个问题，你可以在上面创建私人的免费仓库。</strong></p><h5 id="3-gitee-码云"><a href="#3-gitee-码云" class="headerlink" title="3)gitee(码云)"></a>3)gitee(码云)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问地址:https:&#x2F;&#x2F;gitee.com&#x2F;</span><br></pre></td></tr></table></figure><p>使用 GitHub 时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况。如果</p><p>你希望体验 Git 飞一般的速度，可以使用国内的代码托管与开发协作平台 —— Gitee。除了<strong>访问速度更</strong></p><p><strong>快</strong>以外，Gitee 还提供了<strong>免费的私有仓库</strong>供个人开发者使用</p><hr><h3 id="gitee使用"><a href="#gitee使用" class="headerlink" title="gitee使用"></a>gitee使用</h3><p>注册地址:<a href="https://gitee.com/">https://gitee.com/</a></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094723.png" style="zoom: 67%;" /><hr><h5 id="1、创建仓库"><a href="#1、创建仓库" class="headerlink" title="1、创建仓库"></a>1、创建仓库</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094724.png"></p><hr><p>仓库管理：</p><ul><li>新建文件</li><li>编辑/删除文件</li><li>被删除的文件如何查看信息:</li><li>上传文件(可以同时选择多文件)：</li><li>下载项目:</li><li>Gitee issue(问题)</li><li>删除仓库</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094725.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094726.png"></p><hr><h5 id="2、管理远程仓库"><a href="#2、管理远程仓库" class="headerlink" title="2、管理远程仓库"></a>2、管理远程仓库</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># git克隆操作：将远程仓库的项目复制到本地</span></span><br><span class="line"> git clone 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="section"># 举例： </span></span><br><span class="line">git clone https://gitee.com/zhao<span class="emphasis">_guojiang6/my_</span>pic<span class="emphasis">_bed.git</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 将本地仓库提交到远程（注意先提交到缓存区，再提交到仓库，最后提交远程）--&gt;即更新本地到仓库</span></span><br><span class="line"><span class="emphasis">git push</span></span><br></pre></td></tr></table></figure><p>第一次进行提交时，会设置登录的账户信息，即你的gitee账户</p><p>注意:该设置在gitee仓库主页显示谁提交的文件,如果想要修改用户信息，则将该命令再执行一次。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 设置用户名: </span></span><br><span class="line">git config --global user.name ‘用户名’</span><br><span class="line"><span class="section"># 设置用户名邮箱:</span></span><br><span class="line">git config --global user.email ‘邮箱’</span><br><span class="line"></span><br><span class="line"><span class="section"># 举例:</span></span><br><span class="line">git config --global user.name ‘赵国江’</span><br><span class="line">git config --global user.email ‘1143575690@qq.com’</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看设置: </span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>也可以在：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094727.png" style="zoom: 80%;" /><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 更新你的本地仓库至最新改动--&gt;更新仓库到本地</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 方式1：默认url</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="section"># 方式2:指定url</span></span><br><span class="line">git pull 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="section"># 举例：</span></span><br><span class="line">git pull https://gitee.com/zhao<span class="emphasis">_guojiang6/my_</span>pic<span class="emphasis">_bed.git</span></span><br></pre></td></tr></table></figure><hr><h5 id="3-IDEA关联git"><a href="#3-IDEA关联git" class="headerlink" title="3)IDEA关联git"></a>3)IDEA关联git</h5><blockquote><p>Idea自身路径需要在英文目录</p></blockquote><h6 id="1、配置Git客户端"><a href="#1、配置Git客户端" class="headerlink" title="1、配置Git客户端"></a>1、配置Git客户端</h6><p>File — Settings—Version Control — Git关联Git安装目录下的<code>bin/git.exe</code>执行文件(这个就是git的客户端指令，类似svn.exe)</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094728.png" style="zoom:80%;" /><hr><h6 id="2、下载gitee插件"><a href="#2、下载gitee插件" class="headerlink" title="2、下载gitee插件"></a>2、下载gitee插件</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094729.jpg"></p><hr><h6 id="3、配置登录信息"><a href="#3、配置登录信息" class="headerlink" title="3、配置登录信息"></a>3、配置登录信息</h6><blockquote><p>登录时，使用邮箱登录</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094730.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094731.png"></p><hr><h6 id="4、本地项目上传到服务器"><a href="#4、本地项目上传到服务器" class="headerlink" title="4、本地项目上传到服务器"></a>4、本地项目上传到服务器</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094732.png"></p><hr><h6 id="5、服务器项目下载到本地"><a href="#5、服务器项目下载到本地" class="headerlink" title="5、服务器项目下载到本地"></a>5、服务器项目下载到本地</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094733.png"></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094734.png" style="zoom:80%;" /><hr><h6 id="6、本地项目更新到服务器与服务器更新到本地"><a href="#6、本地项目更新到服务器与服务器更新到本地" class="headerlink" title="6、本地项目更新到服务器与服务器更新到本地"></a>6、本地项目更新到服务器与服务器更新到本地</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094735.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debug调试</title>
      <link href="2021/02/14/IDEA/12_Debug%E8%B0%83%E8%AF%95/"/>
      <url>2021/02/14/IDEA/12_Debug%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h1><p><strong>调试步骤：</strong></p><h3 id="1、设置断点"><a href="#1、设置断点" class="headerlink" title="1、设置断点"></a>1、设置断点</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214130436.png"></p><hr><h3 id="2、选择Debug运行方式"><a href="#2、选择Debug运行方式" class="headerlink" title="2、选择Debug运行方式"></a>2、选择Debug运行方式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214130437.png"></p><hr><h3 id="3、选项键的说明"><a href="#3、选项键的说明" class="headerlink" title="3、选项键的说明"></a>3、选项键的说明</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214130438.png"></p><p><strong>依次说明：</strong></p><ul><li><p>Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。 </p></li><li><p>Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</p></li><li><p>Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法</p></li><li><p>Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</p></li><li><p>Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</p></li><li><p>Drop Frame (默认无)：回退断点</p></li><li><p>Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</p></li></ul><hr><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214130439.png"></p><p><strong>依次说明：</strong></p><ul><li><p>Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。</p></li><li><p>Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。</p></li><li><p>Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。</p></li><li><p>View Breakpoints (Ctrl + Shift + F8)：查看所有断点</p></li><li><p>Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="2021/02/14/IDEA/11_IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2021/02/14/IDEA/11_IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h1><ul><li><p>提示与代码生成部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + Enter  IDEA 根据光标所在问题，提供快速修复选择</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层(try，if等语句包裹)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + Insert 代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + O 选择可重写的方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + I 选择可实现的方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + &#x2F; 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</span><br></pre></td></tr></table></figure></li><li><p>选择/移动/复制代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + W 递进式选择代码块</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+Shift+w   递进式取消选择代码块</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+↑或↓ : 移动当前行或代码结构</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Y 删除光标所在行 或 删除选中的行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + X 剪切光标所在行 或 剪切选择内容</span><br></pre></td></tr></table></figure></li><li><p>代码优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用</span><br></pre></td></tr></table></figure></li><li><p>查找与替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + F 在当前文件进行文本查找</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + R 在当前文件进行文本替换</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</span><br></pre></td></tr></table></figure></li><li><p>阅读代码部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + F12 弹出当前文件结构层(类的方法属性等)，可以在弹出的层上直接输入，进行筛选</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Q 光标所在的变量 &#x2F; 类名 &#x2F; 方法名等上面（也可以在提示补充的时候按），显示文档内容</span><br></pre></td></tr></table></figure></li></ul><h2 id="快捷键大全"><a href="#快捷键大全" class="headerlink" title="快捷键大全"></a>快捷键大全</h2><h3 id="1、Ctrl相关"><a href="#1、Ctrl相关" class="headerlink" title="1、Ctrl相关"></a>1、Ctrl相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + F 在当前文件进行文本查找 （必备）</span><br><span class="line">Ctrl + R 在当前文件进行文本替换 （必备）</span><br><span class="line">Ctrl + Z 撤销 （必备）</span><br><span class="line">Ctrl + Y 删除光标所在行 或 删除选中的行 （必备）</span><br><span class="line">Ctrl + X 剪切光标所在行 或 剪切选择内容</span><br><span class="line">Ctrl + C 复制光标所在行 或 复制选择内容</span><br><span class="line">Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</span><br><span class="line">Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</span><br><span class="line">Ctrl + E 显示最近打开的文件记录列表</span><br><span class="line">Ctrl + N 根据输入的 类名 查找类文件</span><br><span class="line">Ctrl + G 在当前文件跳转到指定行处</span><br><span class="line">Ctrl + J 插入自定义动态代码模板</span><br><span class="line">Ctrl + P 方法参数提示显示</span><br><span class="line">Ctrl + Q 光标所在的变量 &#x2F; 类名 &#x2F; 方法名等上面（也可以在提示补充的时候按），显示文档内容</span><br><span class="line">Ctrl + U 前往当前光标所在的方法的父类的方法 &#x2F; 接口定义</span><br><span class="line">Ctrl + B 进入光标所在的方法&#x2F;变量的接口或是定义处，等效于 Ctrl + 左键单击</span><br><span class="line">Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用</span><br><span class="line">Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用</span><br><span class="line">Ctrl + H 显示当前类的层次结构</span><br><span class="line">Ctrl + O 选择可重写的方法</span><br><span class="line">Ctrl + I 选择可继承的方法</span><br><span class="line">Ctrl + + 展开代码</span><br><span class="line">Ctrl + - 折叠代码</span><br><span class="line">Ctrl + &#x2F; 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</span><br><span class="line">Ctrl + [ 移动光标到当前所在代码的花括号开始位置</span><br><span class="line">Ctrl + ] 移动光标到当前所在代码的花括号结束位置</span><br><span class="line">Ctrl + F1 在光标所在的错误代码处显示错误信息</span><br><span class="line">Ctrl + F3 调转到所选中的词的下一个引用位置</span><br><span class="line">Ctrl + F4 关闭当前编辑文件</span><br><span class="line">Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</span><br><span class="line">Ctrl + F9 执行 Make Project 操作</span><br><span class="line">Ctrl + F11 选中文件 &#x2F; 文件夹，使用助记符设定 &#x2F; 取消书签</span><br><span class="line">Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</span><br><span class="line">Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</span><br><span class="line">Ctrl + Enter 智能分隔行</span><br><span class="line">Ctrl + End 跳到文件尾</span><br><span class="line">Ctrl + Home 跳到文件头</span><br><span class="line">Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 ALT+&#x2F;（必备）</span><br><span class="line">Ctrl + Delete 删除光标后面的单词或是中文句</span><br><span class="line">Ctrl + BackSpace 删除光标前面的单词或是中文句</span><br><span class="line">Ctrl + 1,2,3...9 定位到对应数值的书签位置</span><br><span class="line">Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径</span><br><span class="line">Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要</span><br><span class="line">Ctrl + 左方向键 光标跳转到当前单词 &#x2F; 中文句的左侧开头位置</span><br><span class="line">Ctrl + 右方向键 光标跳转到当前单词 &#x2F; 中文句的右侧开头位置</span><br><span class="line">Ctrl + 前方向键 等效于鼠标滚轮向前效果</span><br><span class="line">Ctrl + 后方向键 等效于鼠标滚轮向后效果</span><br></pre></td></tr></table></figure><h3 id="2、Alt相关"><a href="#2、Alt相关" class="headerlink" title="2、Alt相关"></a>2、Alt相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Alt + &#96; 显示版本控制常用操作菜单弹出层</span><br><span class="line">Alt + Q 弹出一个提示，显示当前类的声明 &#x2F; 上下文信息</span><br><span class="line">Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</span><br><span class="line">Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层</span><br><span class="line">Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示</span><br><span class="line">Alt + F7 查找光标所在的方法 &#x2F; 变量 &#x2F; 类被调用的地方</span><br><span class="line">Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</span><br><span class="line">Alt + Home 定位 &#x2F; 显示到当前文件的 Navigation Bar</span><br><span class="line">Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</span><br><span class="line">Alt + Insert 代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等（必备）</span><br><span class="line">Alt + 左方向键 按左方向切换当前已打开的文件视图</span><br><span class="line">Alt + 右方向键 按右方向切换当前已打开的文件视图</span><br><span class="line">Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置</span><br><span class="line">Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置</span><br><span class="line">Alt + 1,2,3...9 显示对应数值的选项卡，其中 1 是 Project 用得最多</span><br></pre></td></tr></table></figure><h3 id="3、Shift相关"><a href="#3、Shift相关" class="headerlink" title="3、Shift相关"></a>3、Shift相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Shift + F1 如果有外部文档可以连接外部文档</span><br><span class="line">Shift + F2 跳转到上一个高亮错误 或 警告位置</span><br><span class="line">Shift + F3 在查找模式下，查找匹配上一个</span><br><span class="line">Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留</span><br><span class="line">Shift + F6 对文件 &#x2F; 文件夹 重命名</span><br><span class="line">Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</span><br><span class="line">Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</span><br><span class="line">Shift + F9 等效于点击工具栏的 Debug 按钮</span><br><span class="line">Shift + F10 等效于点击工具栏的 Run 按钮</span><br><span class="line">Shift + F11 弹出书签显示层</span><br><span class="line">Shift + Tab 取消缩进</span><br><span class="line">Shift + ESC 隐藏当前 或 最后一个激活的工具窗口</span><br><span class="line">Shift + End 选中光标到当前行尾位置</span><br><span class="line">Shift + Home 选中光标到当前行头位置</span><br><span class="line">Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置</span><br><span class="line">Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件</span><br><span class="line">Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动</span><br></pre></td></tr></table></figure><h3 id="4、Ctrl-Alt相关"><a href="#4、Ctrl-Alt相关" class="headerlink" title="4、Ctrl + Alt相关"></a>4、Ctrl + Alt相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备）</span><br><span class="line">Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备）</span><br><span class="line">Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</span><br><span class="line">Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层</span><br><span class="line">Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中</span><br><span class="line">Ctrl + Alt + H 调用层次</span><br><span class="line">Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</span><br><span class="line">Ctrl + Alt + V 快速引进变量</span><br><span class="line">Ctrl + Alt + Y 同步、刷新</span><br><span class="line">Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置</span><br><span class="line">Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</span><br><span class="line">Ctrl + Alt + F11 切换全屏模式</span><br><span class="line">Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行</span><br><span class="line">Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层</span><br><span class="line">Ctrl + Alt + Space 类名自动完成</span><br><span class="line">Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）</span><br><span class="line">Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）</span><br><span class="line">Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件</span><br><span class="line">Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件</span><br></pre></td></tr></table></figure><h3 id="5、Ctrl-Shift相关"><a href="#5、Ctrl-Shift相关" class="headerlink" title="5、Ctrl + Shift相关"></a>5、Ctrl + Shift相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备）</span><br><span class="line">Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</span><br><span class="line">Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备）</span><br><span class="line">Ctrl + Shift + Z 取消撤销 （必备）</span><br><span class="line">Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 </span><br><span class="line"></span><br><span class="line">（必备）</span><br><span class="line">Ctrl + Shift + N 通过文件名定位 &#x2F; 打开文件 &#x2F; 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</span><br><span class="line">Ctrl + Shift + U 对选中的代码进行大 &#x2F; 小写轮流转换 （必备）</span><br><span class="line">Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</span><br><span class="line">Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板</span><br><span class="line">Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层</span><br><span class="line">Ctrl + Shift + E 显示最近修改的文件列表的弹出层</span><br><span class="line">Ctrl + Shift + H 显示方法层次结构</span><br><span class="line">Ctrl + Shift + B 跳转到类型声明处</span><br><span class="line">Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义</span><br><span class="line">Ctrl + Shift + A 查找动作 &#x2F; 设置</span><br><span class="line">Ctrl + Shift + &#x2F; 代码块注释 （必备）</span><br><span class="line">Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置</span><br><span class="line">Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置</span><br><span class="line">Ctrl + Shift + + 展开所有代码</span><br><span class="line">Ctrl + Shift + - 折叠所有代码</span><br><span class="line">Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失</span><br><span class="line">Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件</span><br><span class="line">Ctrl + Shift + F9 编译选中的文件 &#x2F; 包 &#x2F; Module</span><br><span class="line">Ctrl + Shift + F12 编辑器最大化</span><br><span class="line">Ctrl + Shift + Space 智能代码提示</span><br><span class="line">Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备）</span><br><span class="line">Ctrl + Shift + Backspace 退回到上次修改的地方</span><br><span class="line">Ctrl + Shift + 1,2,3...9 快速添加指定数值的书签</span><br><span class="line">Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）</span><br><span class="line">Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 &#x2F; 中文句的左侧开头位置，同时选中该单词 &#x2F; 中文句</span><br><span class="line">Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 &#x2F; 中文句的右侧开头位置，同时选中该单词 &#x2F; 中文句</span><br><span class="line">Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域</span><br><span class="line">Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域</span><br><span class="line">Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</span><br><span class="line">Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</span><br></pre></td></tr></table></figure><h3 id="6、Alt-Shift相关"><a href="#6、Alt-Shift相关" class="headerlink" title="6、Alt + Shift相关"></a>6、Alt + Shift相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Alt + Shift + N 选择 &#x2F; 添加 task</span><br><span class="line">Alt + Shift + F 显示添加到收藏夹弹出层 &#x2F; 添加到收藏夹</span><br><span class="line">Alt + Shift + C 查看最近操作项目的变化情况列表</span><br><span class="line">Alt + Shift + I 查看项目当前文件</span><br><span class="line">Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环</span><br><span class="line"></span><br><span class="line">进入</span><br><span class="line">Alt + Shift + F9 弹出 Debug 的可选择菜单</span><br><span class="line">Alt + Shift + F10 弹出 Run 的可选择菜单</span><br><span class="line">Alt + Shift + 左键双击 选择被双击的单词 &#x2F; 中文句，按住不放，可以同时选择其他单词 &#x2F; 中文句</span><br><span class="line">Alt + Shift + 前方向键 移动光标所在行向上移动</span><br><span class="line">Alt + Shift + 后方向键 移动光标所在行向下移动</span><br></pre></td></tr></table></figure><h3 id="7、其他"><a href="#7、其他" class="headerlink" title="7、其他"></a>7、其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">F2 跳转到下一个高亮错误 或 警告位置 （必备）</span><br><span class="line">F3 在查找模式下，定位到下一个匹配处</span><br><span class="line">F4 编辑源</span><br><span class="line">F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该</span><br><span class="line"></span><br><span class="line">内嵌的方法中</span><br><span class="line">F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</span><br><span class="line">F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</span><br><span class="line">F11 添加书签</span><br><span class="line">F12 回到前一个工具窗口</span><br><span class="line">Tab 缩进</span><br><span class="line">ESC 从工具窗口进入代码文件窗口</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + Alt + V 无格式黏贴</span><br><span class="line">Ctrl + Shift + Alt + N 前往指定的变量 &#x2F; 方法</span><br><span class="line">Ctrl + Shift + Alt + S 打开当前项目设置</span><br><span class="line">Ctrl + Shift + Alt + C 复制参考信息</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 2019.3.4完美破解(亲测有效)</title>
      <link href="2021/02/14/IDEA/10_IDEA-2019-3-4%E5%AE%8C%E7%BE%8E%E7%A0%B4%E8%A7%A3-%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88/"/>
      <url>2021/02/14/IDEA/10_IDEA-2019-3-4%E5%AE%8C%E7%BE%8E%E7%A0%B4%E8%A7%A3-%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA-2019-3-4完美破解-亲测有效"><a href="#IDEA-2019-3-4完美破解-亲测有效" class="headerlink" title="IDEA 2019.3.4完美破解(亲测有效)"></a>IDEA 2019.3.4完美破解(亲测有效)</h1><blockquote><p>本项目只做学习研究之用，不得用于商业用途！</p><p>若资金允许，请点击 [<a href="https://www.jetbrains.com/idea/buy/]">https://www.jetbrains.com/idea/buy/]</a> 购买正版！！！</p></blockquote><hr><p><a href="https://www.jetbrains.com/">IDEA官网</a></p><p>所需要的插件：<font color='orange'>jetbrains-agent.jar</font></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 百度网盘</span></span><br><span class="line">链接：https://pan.baidu.com/s/1RHase0KlvJF-afS<span class="emphasis">_mPDTaw </span></span><br><span class="line"><span class="emphasis">提取码：rbjv </span></span><br></pre></td></tr></table></figure><hr><p>安装步骤：</p><p>首先，安装idea，然后使用免费30天进入，随便创建一个项目，进入主界面。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214120955.png"  /><hr><p>其次，把jetbrains-agent.jar 包拖进idea主界面，选择重启。restart now</p><p>再次，重启完，选择激活方式为 activation_code 方式，会在重启一次。</p><p>最后，idea主界面，选择Help - About,查看激活时间。我的激活时间为70年</p><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA单元测试</title>
      <link href="2021/02/14/IDEA/9_IDEA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>2021/02/14/IDEA/9_IDEA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA单元测试"><a href="#IDEA单元测试" class="headerlink" title="IDEA单元测试"></a>IDEA单元测试</h1><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="下载jar文件"><a href="#下载jar文件" class="headerlink" title="下载jar文件"></a>下载jar文件</h3><p>链接：<a href="https://pan.baidu.com/s/1ZZ7LB1TZK8qQM-hcPwYuaw">https://pan.baidu.com/s/1ZZ7LB1TZK8qQM-hcPwYuaw</a><br>提取码：uv62</p><h3 id="新建lib文件夹"><a href="#新建lib文件夹" class="headerlink" title="新建lib文件夹"></a>新建lib文件夹</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115847.png"></p><h3 id="将jar文件粘贴到lib文件夹中"><a href="#将jar文件粘贴到lib文件夹中" class="headerlink" title="将jar文件粘贴到lib文件夹中"></a>将jar文件粘贴到lib文件夹中</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115848.png"></p><h3 id="引入Jar文件"><a href="#引入Jar文件" class="headerlink" title="引入Jar文件"></a>引入Jar文件</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115849.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115850.png"></p><h3 id="新建test文件夹"><a href="#新建test文件夹" class="headerlink" title="新建test文件夹"></a>新建test文件夹</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115851.png"></p><h3 id="将test文件夹设置为测试文件夹"><a href="#将test文件夹设置为测试文件夹" class="headerlink" title="将test文件夹设置为测试文件夹"></a>将test文件夹设置为测试文件夹</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115852.png"></p><h3 id="在任意要测试的类里按下shift-ctrl-t-生成测试类"><a href="#在任意要测试的类里按下shift-ctrl-t-生成测试类" class="headerlink" title="在任意要测试的类里按下shift+ctrl+t 生成测试类"></a>在任意要测试的类里按下shift+ctrl+t 生成测试类</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115853.png"></p><p>此时可能出现使用<code>shift + ctrl + t</code>弹出 <code>Class类查找</code></p><p>解决方法：手动设置自动创建测试类的快捷键即可</p><p><strong>点击 file-&gt; setting -&gt; keymap 搜索：test</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115854.png"></p><p>鼠标右键：add keyBoard Shortcut 设置你想要的快捷键  Apply -&gt;OK即可</p><hr><h4 id="选择Create-new-Test…"><a href="#选择Create-new-Test…" class="headerlink" title="选择Create new Test…"></a>选择Create new Test…</h4><p>选择要测试的方法和版本:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115855.png"></p><h4 id="选择已创建过的测试类"><a href="#选择已创建过的测试类" class="headerlink" title="选择已创建过的测试类"></a>选择已创建过的测试类</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115856.png"></p><h4 id="测试类创建完毕-编写测试代码"><a href="#测试类创建完毕-编写测试代码" class="headerlink" title="测试类创建完毕, 编写测试代码"></a>测试类创建完毕, 编写测试代码</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115857.png"></p><h4 id="执行测试观察效果"><a href="#执行测试观察效果" class="headerlink" title="执行测试观察效果"></a>执行测试观察效果</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115858.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 类注释+方法注释的快捷设置</title>
      <link href="2021/02/14/IDEA/8_IDEA-%E7%B1%BB%E6%B3%A8%E9%87%8A-%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%AE%BE%E7%BD%AE/"/>
      <url>2021/02/14/IDEA/8_IDEA-%E7%B1%BB%E6%B3%A8%E9%87%8A-%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA：类注释-方法注释的快捷设置"><a href="#IDEA：类注释-方法注释的快捷设置" class="headerlink" title="IDEA：类注释/方法注释的快捷设置"></a>IDEA：类注释/方法注释的快捷设置</h1><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><h3 id="修改类头的文档注释信息"><a href="#修改类头的文档注释信息" class="headerlink" title="修改类头的文档注释信息"></a>修改类头的文档注释信息</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115421.png"></p><p>模板内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">@Author: xj0927</span><br><span class="line">@Description: </span><br><span class="line">@Date Created in $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125; </span><br><span class="line">@Modified By: </span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>直接在右边的文件框里编辑你说需要注释的东西，然后应用保存之后,<strong>当你创建类的时候就会自动生成注释。</strong> </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115422.png"></p><hr><h2 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h2><h3 id="要求效果："><a href="#要求效果：" class="headerlink" title="要求效果："></a>要求效果：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115423.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">* @Description: 添加你要描述的内容~~</span><br><span class="line">* @Param: [a,b,c,d]</span><br><span class="line">* @Return: </span><br><span class="line">* @Author: xj0927</span><br><span class="line">* @Date Created in 2020&#x2F;08&#x2F;19 11:37</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><h3 id="具体实现步骤："><a href="#具体实现步骤：" class="headerlink" title="具体实现步骤："></a>具体实现步骤：</h3><p>1、打开系统设置Setting（Ctrl+Alt+S快捷键）</p><p>2、Editor—&gt;Live Templates—&gt;点击+号。添加一个templates group来放置自己快捷键，效果图如下：</p><p>3、选中创建的MyGroup—&gt;再次点击+号，添加一个Live template</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115424.png"></p><p>4.还是在fifile-&gt;setting-&gt;Editor-&gt;LiveTemplates这个路径下点击一下刚刚你添加的那个名字MyGroup，然后点击右边 上面那个+号，选择LiveTemplate，填写下面设置自定义的快捷键模板：</p><blockquote><p> Abbreviation：快捷键，</p><p> Description：描述该快捷键</p><p> Template text：自定义的快捷键模板</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">* <span class="meta">@Description</span>: $description$ </span><br><span class="line">* <span class="meta">@Param</span>: $params$ </span><br><span class="line">* <span class="meta">@Return</span>: $<span class="keyword">return</span>$</span><br><span class="line">* <span class="meta">@Author</span>: xj0927</span><br><span class="line">* <span class="meta">@Date</span> Created in $data$ $time$</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115425.png"></p><p>5.设置注释的关联变量：先设置好Template text内容后—&gt;Edit variables，变量如效果图设置就好。效果图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115426.png"></p><p>注意：注意：注意：设置完应用一下Apply</p><p>应用的时候直接在方法前边写：/+快捷键名+Enter键。即可，比如我设置的快捷键方法名是a，效果图便是：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115427.png"></p><div class="note success simple"><p>设置完成</p></div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给 IDEA 换个养眼的主题</title>
      <link href="2021/02/14/IDEA/7_%E7%BB%99-IDEA-%E6%8D%A2%E4%B8%AA%E5%85%BB%E7%9C%BC%E7%9A%84%E4%B8%BB%E9%A2%98/"/>
      <url>2021/02/14/IDEA/7_%E7%BB%99-IDEA-%E6%8D%A2%E4%B8%AA%E5%85%BB%E7%9C%BC%E7%9A%84%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="以下推荐几款个人喜欢的-两款主题"><a href="#以下推荐几款个人喜欢的-两款主题" class="headerlink" title="以下推荐几款个人喜欢的 两款主题"></a>以下推荐几款个人喜欢的 两款主题</h3><h4 id="第一款：Xcode-Dark-Theme"><a href="#第一款：Xcode-Dark-Theme" class="headerlink" title="第一款：Xcode-Dark Theme"></a>第一款：Xcode-Dark Theme</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114858.png"></p><h4 id="第二款：One-Dark-theme"><a href="#第二款：One-Dark-theme" class="headerlink" title="第二款：One Dark theme"></a>第二款：One Dark theme</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114859.png"></p><hr><h3 id="如何下载主题"><a href="#如何下载主题" class="headerlink" title="如何下载主题"></a>如何下载主题</h3><p>在 IDEA 中下载：搜索这 2 个插件下载即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114900.png"></p><hr><h3 id="如何更换主题"><a href="#如何更换主题" class="headerlink" title="如何更换主题"></a>如何更换主题</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114901.png"></p><p>Apply 即可！！！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora + PicGo + Gitee实现图片上传</title>
      <link href="2021/02/14/Hexo%E5%8D%9A%E5%AE%A2/6_Typora-PicGo-Gitee%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
      <url>2021/02/14/Hexo%E5%8D%9A%E5%AE%A2/6_Typora-PicGo-Gitee%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-PicGo-Gitee实现图片上传"><a href="#Typora-PicGo-Gitee实现图片上传" class="headerlink" title="Typora + PicGo + Gitee实现图片上传"></a>Typora + PicGo + Gitee实现图片上传</h1><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><h3 id="下载typora"><a href="#下载typora" class="headerlink" title="下载typora"></a>下载typora</h3><blockquote><p>此软件用于撰写markdown文档，新版本支持图片粘贴图片功能</p></blockquote><p><a href="https://www.typora.io/#windows">官网下载</a></p><h3 id="下载图床工具picgo"><a href="#下载图床工具picgo" class="headerlink" title="下载图床工具picgo"></a>下载图床工具picgo</h3><blockquote><p>所谓图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 Electron-vue 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用</p></blockquote><p><a href="https://github.com/Molunerfinn/PicGo/releases">github下载地址</a><br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114644.png" alt="image-20210214111008639"></p><hr><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="在gitee上创建仓库（公开的！）"><a href="#在gitee上创建仓库（公开的！）" class="headerlink" title="在gitee上创建仓库（公开的！）"></a>在gitee上创建仓库（公开的！）</h3><blockquote><p>没有账号可以申请一个</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114645.png" alt="image-20210214111212552"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114646.png" alt="image-20210214112956581"></p><blockquote><p>去设置里面找到私人令牌添加一个新的</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114647.png" alt="image-20210214113141098"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114648.png" alt="image-20210214113153874"></p><hr><h3 id="配置picgo图床工具"><a href="#配置picgo图床工具" class="headerlink" title="配置picgo图床工具"></a>配置picgo图床工具</h3><p>下载<code>gitee-uploader</code>插件，这里需要你电脑有<code>node环境</code>（具体安装可以百度，比较简单）<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114649.png" alt="image-20210214113409680"></p><p>下载完插件后<code>图床设置</code>里面多个gitee，然后进行设置：<code>owner</code>：用户名，<code>repo仓库</code>：仓库名 ,<code>token私人令牌</code> ：你刚设置的令牌 ，然后点击确定</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114650.png" alt="image-20210214113526607"></p><hr><h3 id="配置typora"><a href="#配置typora" class="headerlink" title="配置typora"></a>配置typora</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114651.png" alt="image-20210214113701562"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114652.png" alt="image-20210214113713876"></p><blockquote><p>你也可以验证一下是否成功</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114653.png" alt="image-20210214113726898"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114654.png" alt="image-20210214113738895"></p><blockquote><p>回到你gitee仓库，这时候已经多了两个图片，说明已经图床已经搭建完毕</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114655.png" alt="image-20210214113903651"></p><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>1、随便截一张图，粘贴到typora：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114656.png"></p><hr><p>2、一键上传所有图片<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114657.png" alt="image-20210214114218080"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114658.png" alt="image-20210214114315519"></p><hr><p>当你需要的时候，就可以在任何地方引入该链接，使用图片！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo终极部署Github + Vercel</title>
      <link href="2021/02/11/Hexo%E5%8D%9A%E5%AE%A2/5_Hexo%E7%BB%88%E6%9E%81%E9%83%A8%E7%BD%B2Github-Vercel/"/>
      <url>2021/02/11/Hexo%E5%8D%9A%E5%AE%A2/5_Hexo%E7%BB%88%E6%9E%81%E9%83%A8%E7%BD%B2Github-Vercel/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo终极部署：Github-Vercel"><a href="#Hexo终极部署：Github-Vercel" class="headerlink" title="Hexo终极部署：Github + Vercel"></a>Hexo终极部署：Github + Vercel</h1><h2 id="各大服务器特点"><a href="#各大服务器特点" class="headerlink" title="各大服务器特点"></a>各大服务器特点</h2><p>近些日子，静态网站的热度又渐渐高了起来。相比于动态网站，静态网站具有轻量、无需服务器、利于 SEO、速度快等特点，非常适合个人博客。再加上 Hexo、Hugo 等静态博客渲染框架的日渐成熟，已能与 Wordpress、Typecho 等老牌动态博客框架分庭抗礼。 </p><p>与此同时，很多静态托管网站也应运而生。各种托管网站看似鱼龙混杂，其实由于各种原因，在国内能用的也就那么几家；如果你像我一样，没有服务器、没有备案，还想白嫖（），那么仅有的选择就更少了。综合各种因素，目前最适合托管静态博客的服务有：</p><p><strong>GitHub Pages</strong> </p><p>微软旗下，闻名遐迩的全球第一大开源仓库网站。服务器设在荷兰、美国等地。部分地区部分运营商的用户可能遭到<code> DNS 污染</code>，无法正常访问。</p><p><strong>Gitee Pages</strong> </p><p>OSCHINA 旗下，服务器在上海腾讯云，速度较快，较稳定，提供 <code>xxx.gitee.io </code>域名，不支持免费自定义域名。</p><p><strong>旧 Coding Pages</strong> </p><p>腾讯旗下，服务器在香港 / 新加坡腾讯云，速度较快，但稳定性差。部分地区速度极慢或不能访问。支持免费自定义域名。</p><p><strong>新 Coding Pages</strong></p><p>与腾讯云绑定食用，功能较齐全，但按量计费。</p><hr><h2 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h2><p>原名 Zeit，服务器在美国，在港台有 CDN 节点。速度略慢于 Coding，但大部分地区均可正常访问。</p><p><code>提供自定义 xxx.now.sh 和 xxx.vercel.app 域名，且支持免费绑定个人域名。</code></p><p>大部分网站采用的一般都是 GitHub + Coding 双部署的形式。这种方法比较麻烦，需要 DNSPod 解析，因此需要实名认证，而且还真未必快到那里去。</p><p>Colsrch 大佬出过一篇三部署教程，使用了 Coding（联通线路），Vercel（默认线路），Cloudflare 回源 GitHub Page（移动线路），速度略有提升，但是门槛较高，对小白并不友好。而且近期 Coding 似乎越来越不稳定了，所以也不太推荐此方法。 </p><p>和 99 块钱相比，慢点就慢点吧（  还是由于某种原因，市面上的 Vercel 部署教程并不多。而且由于 Vercel 里的一些操作还是挺不常规的，所以就写了这么一篇文章，说一下将网站部署在 Vercel 的详细过程。）</p><hr><h3 id="导入-GitHub-仓库"><a href="#导入-GitHub-仓库" class="headerlink" title="导入 GitHub 仓库"></a>导入 GitHub 仓库</h3><p>Vercel 是一个静态网页部署网站，并不托管代码。因此，我们通过 GitHub 来托管 hexo deploy 生成的网页文件，并设置自动导入。当你的源代码仓库有变动后，Vercel 会第一时间检测到并重新部署网站，部署完成后会通过邮件提醒。</p><blockquote><p>在开始之前，请准备一个 GitHub 账号（注意不能是绑有 QQ 邮箱的）、一个 Git 仓库（存储 Hexo 生成的页面）。</p></blockquote><p>进入  <a href="https://vercel.com/signup">Vercel 官网</a>，点击 <code>Continue with GitHub</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax2.sinaimg.cn/large/007rpHi4gy1gnio31f65aj30u90famzb.jpg"></p><p>出现授权页面，点击<code>Authorize Vercel</code>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax1.sinaimg.cn/large/007rpHi4gy1gnio31re80j30m30tvq46.jpg"></p><p>填写你要导入的Github仓库地址：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnio31krrgj30ly0co0t7.jpg"></p><p>选择个人使用：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax1.sinaimg.cn/large/007rpHi4gy1gnio328zq8j30ys0n8q40.jpg"></p><p>选择Github：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax1.sinaimg.cn/large/007rpHi4gy1gnio3223obj30ys0n8my8.jpg"></p><p>导入项目中会弹出一些自定义选项，不知道会出什么锅的话就不要改，顺着一直点，遵照默认选项就可以了。</p><p>完成后，便可以访问我们的博客了，以我的为例：<a href="https://xj-0927-git-github-io.vercel.app/">https://xj-0927-git-github-io.vercel.app/</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnio32imtij30xi0oo426.jpg"></p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>进入 dashboard，点击 [项目卡片] -&gt; View Domains</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnio32imtij30xi0oo426.jpg"></p><p>如果你想使用 Vercel 提供的二级域名，直接添加 <code>xxx.now.sh </code>（或<code> xxx.vercel.app</code> ，看你想要哪个），如果无人占用，会自动验证成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax2.sinaimg.cn/large/007rpHi4gy1gnio30d9l0j30xk0ewgmt.jpg"></p><hr><p>如果你想绑定自己的域名，也是在输入框中输入你想要绑定的网址，点击右侧 Add 即可。下方会提示 Invalid Config，并给出绑定方式，请按照下面的方式：</p><p>验证方式 ：</p><ul><li>如果是根域名，请在你的 DNS 解析处添加 A 记录，指向 <code>76.76.21.21</code></li><li>如果是子域名，请在你的 DNS 解析处添加 CNAME 记录，指向 <code>cname.vercel-dns.com</code></li></ul><p>以我的为例：(阿里云购买的域名)</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax1.sinaimg.cn/large/007rpHi4gy1gnio30ja8fj30lh0h3q36.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax3.sinaimg.cn/large/007rpHi4gy1gnio30q28jj30lo0ioglv.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://tva4.sinaimg.cn/large/007rpHi4gy1gnio30zh6zj30vm0bq756.jpg"></p><p>添加记录后等待片刻再刷新，下面显示两个对号即表明验证成功：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva2.sinaimg.cn/large/007rpHi4gy1gnio315p5lj30ks0b0aam.jpg"></p><p>完成后，便可以使用你的域名进行访问了！！！</p><hr><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向 ：如果你绑定了多个域名，可以点击域名卡片右上角的 Edit，将某个域名重定向至你的其他域名。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 部署到Gitee 码云</title>
      <link href="2020/01/02/Hexo%E5%8D%9A%E5%AE%A2/3_%E9%83%A8%E7%BD%B2%E5%88%B0Gitee/"/>
      <url>2020/01/02/Hexo%E5%8D%9A%E5%AE%A2/3_%E9%83%A8%E7%BD%B2%E5%88%B0Gitee/</url>
      
        <content type="html"><![CDATA[<h1 id="部署到Gitee"><a href="#部署到Gitee" class="headerlink" title="部署到Gitee"></a>部署到Gitee</h1><div class="note info simple"><p>本次记录的是将Hexo博客部署在码云上面，其<a href="https://gitee.com/education">官方网站</a>，相比于部署到Github上，其访问速度更快，但是后面我发现Gitee现在不能进行自定义域名了，如果你想要自定义域名的话，需要去进行购买。但是如果你不需要自定义域名的话，该方案还是比较可行。</p></div><h2 id="配置码云"><a href="#配置码云" class="headerlink" title="配置码云"></a>配置码云</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>先去<a href="https://gitee.com/">登陆</a>或注册码云，然后创建仓库，路径一定要跟你的用户名一样，这样就可以使用<code>https://用户名.gitee.io/</code>来访问你的博客首页。</p><p>用户名在这里看着先：</p><p><a href="https://caiyantao.gitee.io/2019/04/14/Hexo-%E4%B8%89/df2393c58959860e67ba135a46c0538.png"><img src= "/img/loading.gif" data-lazy-src="https://tvax2.sinaimg.cn/large/007rpHi4gy1gnim3913qgj30xr0izq4w.jpg" alt="df2393c58959860e67ba135a46c0538"></a><br>首先还是得新建一个仓库：填入个人消息</p><p><a href="https://caiyantao.gitee.io/2019/04/14/Hexo-%E4%B8%89/3b8bc27bd4c3b52deaf324d31672feb.png"><img src= "/img/loading.gif" data-lazy-src="https://tva3.sinaimg.cn/large/007rpHi4gy1gnim385elzj311y0k9q4w.jpg" alt="3b8bc27bd4c3b52deaf324d31672feb"></a></p><p>需要<strong>注意</strong>的是<code>路径</code>这个地方可不是想写啥就写啥，一定要写成你的<code>用户名</code></p><p>要写自己的用户名，要写自己的用户名，要写自己的用户名，！！！</p><hr><h3 id="部署密钥"><a href="#部署密钥" class="headerlink" title="部署密钥"></a>部署密钥</h3><h4 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h4><p>配置码云的SSH公钥，首先本地git生成公钥（码云中配置SSH公钥画面有介绍怎么<a href="https://gitee.com/help/articles/4181#article-header0">生成公钥</a>）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnim0cngqfj30xe0go0uh.jpg" alt="img"></p><h4 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h4><p>然后在码云中配置生成的SSH公钥。生成后查看代码将其复制到上面图中的公钥处</p><p>这样的话，<code>Hexo d</code>上传博客到服务器就会自动认证。</p><h3 id="修改Hexo配置文件"><a href="#修改Hexo配置文件" class="headerlink" title="修改Hexo配置文件"></a>修改Hexo配置文件</h3><p>然后写上自己仓库链接，具体看链接如下图：</p><p><a href=""><img src= "/img/loading.gif" data-lazy-src="https://tva2.sinaimg.cn/large/007rpHi4gy1gnim38gyh3j30zz0i2mzt.jpg" alt="73aaa7dc9f71685e0fb6251f2bae520"></a><br>修改hexo的配置文件<code>_config.yml</code>，填上仓库地址。比如我的代码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意名字和值之间要空一格</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@gitee.com:zhao_guojiang6&#x2F;zhao_guojiang6.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><a href="https://wudong-tech.oss-cn-beijing.aliyuncs.com/Hexo%E5%92%8C%E7%A0%81%E4%BA%91%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E9%85%8D%E7%BD%AE%E7%A0%81%E4%BA%91.png"><img src= "/img/loading.gif" data-lazy-src="https://tva3.sinaimg.cn/large/007rpHi4gy1gnim4d08tuj30qs0cqwfm.jpg" alt="img"></a></p><p>然后进行命令三连杀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean&amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><hr><h3 id="我们点Page服务"><a href="#我们点Page服务" class="headerlink" title="我们点Page服务"></a>我们点Page服务</h3><p>点击生成，可以看到我们的域名啦：</p><p><a href="https://caiyantao.gitee.io/2019/04/14/Hexo-%E4%B8%89/928f341ba6e91116ecd2ebb2cbd0540.png"><img src= "/img/loading.gif" data-lazy-src="https://tva4.sinaimg.cn/large/007rpHi4gy1gnim16suvtj30jl05gjrs.jpg" alt="928f341ba6e91116ecd2ebb2cbd0540"></a></p><p>然后结果就是：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva3.sinaimg.cn/large/007rpHi4gy1gnim38tnx0j30zn0nr0w4.jpg"></p><p>访问<a href="https://zhao_guojiang6.gitee.io/">https://zhao_guojiang6.gitee.io</a>即可！</p><p>至此，Hexo部署到Gitee就完成了！</p><p>别的小伙伴拿到地址便可以访问你的博客了！</p><hr><div class="note default simple"><p>参考博客：<a href="https://caiyantao.gitee.io/">Hexo部署到码云</a></p></div><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署到Github</title>
      <link href="2020/01/02/Hexo%E5%8D%9A%E5%AE%A2/4_Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/"/>
      <url>2020/01/02/Hexo%E5%8D%9A%E5%AE%A2/4_Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo部署到Github"><a href="#Hexo部署到Github" class="headerlink" title="Hexo部署到Github"></a>Hexo部署到Github</h1><h3 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h3><h4 id="生成github-io仓库"><a href="#生成github-io仓库" class="headerlink" title="生成github.io仓库"></a>生成github.io仓库</h4><p>首先注册并登录<a href="https://github.com/">GitHub</a>，创建新public仓库，仓库名称<strong>一定要是</strong>：<br><code>YourGitHubName.github.io</code>（YourGitHubName是<strong>你的</strong>GitHub昵称，<strong>大小写敏感！</strong>）</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gninicam0rj30wz0ffdh2.jpg"></p><h4 id="安装git部署插件"><a href="#安装git部署插件" class="headerlink" title="安装git部署插件"></a>安装git部署插件</h4><p>在Hexo的目录下，输入<code>npm install --save hexo-deployer-git</code>，会报一个peerDependencies WARNING，可以忽略。</p><h4 id="修改Hexo配置文件"><a href="#修改Hexo配置文件" class="headerlink" title="修改Hexo配置文件"></a>修改Hexo配置文件</h4><p>在Hexo目录下，找到<code>_config.yml</code>文件，添加Github仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:XJ0927Git&#x2F;XJ0927Git.github.io.git       #你的github.io的网址</span><br><span class="line">  branch: master                                                           </span><br></pre></td></tr></table></figure><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp; hexo g &amp; hexo d</span><br></pre></td></tr></table></figure><p>部署成功后，浏览器输入<code>YourGitHubName.github.io</code>即可访问，其中YourGitHubName是<strong>你的</strong>GitHub昵称，且<strong>大小写敏感</strong></p><p>以我的为例：<a href="https://xj0927git.github.io/">https://xj0927git.github.io/</a></p><h4 id="写文章-amp-发布"><a href="#写文章-amp-发布" class="headerlink" title="写文章 &amp; 发布"></a>写文章 &amp; 发布</h4><p>和本地一致，都是<code>hexo new &quot;yourArticle&quot;</code>后，发布到本地就用<code>hexo clean &amp; hexo g &amp; hexo s</code></p><p>，部署到服务器就用<code>hexo clean &amp; hexo g &amp; hexo d </code>，不再赘述。</p><hr><div class="note default simple"><p>参考视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty">CodeSheep🐏</a></p><p>参考文章：<a href="http://www.dragonbaby308.com/hexo/">Hexo博客部署到Github</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 本地部署</title>
      <link href="2020/01/01/Hexo%E5%8D%9A%E5%AE%A2/2-Hexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/"/>
      <url>2020/01/01/Hexo%E5%8D%9A%E5%AE%A2/2-Hexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo本地部署"><a href="#Hexo本地部署" class="headerlink" title="Hexo本地部署"></a>Hexo本地部署</h1><p>首先需要说明的是：我本地使用的是Win10（64位）操作系统。</p><p>更权威的安装过程可以参照<a href="https://hexo.io/zh-cn/">Hexo官方主页</a>。</p><h2 id="部署安装环境"><a href="#部署安装环境" class="headerlink" title="部署安装环境"></a>部署安装环境</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>去<a href="https://nodejs.org/en/">Node.js官网</a>下载Windows (x64)长期支持版 Long Term Support (LTS) schedule。</p><p>按提示逐步安装即可，安装完成后打开cmd查看版本号验证是否安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\tangcl&gt; node -v</span><br><span class="line">v12.13.1</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>Node.js中自带了npm包管理工具，在cmd中查看npm版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\tangcl&gt; npm -v</span><br><span class="line">6.12.1</span><br><span class="line">12</span><br></pre></td></tr></table></figure><hr><div class="note info simple"><p>由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过npm安装cnpm：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装成功后，可以通过以下命令查看cnpm版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>如果提示cnpm没找到，那就是你没有配置环境变量（比较简单，把错误提示复制到百度有解决方案）</p><p>通过cnpm来操作下载速度会得到很大提升。</p></div><hr><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>git是一个版本控制工具，国外镜像下载巨慢，建议前往<a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a>下载 git 安装包。</p><p>按提示逐步安装即可（<a href="https://blog.csdn.net/XJ0927/article/details/113374829">Git安装</a>），安装完成后右键菜单中出现Git Bash和Git GUI菜单表明安装成功，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva1.sinaimg.cn/large/007rpHi4gy1gnhjshrz26j307i0b1dfw.jpg" alt="1"></p><p>注：git和github是两个东西。github是基于git二次开发的，git是github的核心，git负责与github相关的所有本地工作。</p><hr><h2 id="开始安装Hexo"><a href="#开始安装Hexo" class="headerlink" title="开始安装Hexo"></a>开始安装Hexo</h2><h4 id="安装Hexo框架"><a href="#安装Hexo框架" class="headerlink" title="安装Hexo框架"></a>安装Hexo框架</h4><p>右键打开Git Bash，使用 cnpm 安装 Hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnhjv22x15j313c04142a.jpg" alt="image"></p><p>查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><hr><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>Hexo安装完成后，新建myblogs项目，Hexo的所有文章都是以文件的形式存储在目录下的，所以首先需要新建一个目录</p><div class="note success simple"><p>这个目录存放的东西就是你以后操作博客的东西</p></div><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><p>对其进行初始化：（<font color='red'>这个命令只用一次，后面不会再用到了</font>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myblogs</span><br><span class="line">hexo init </span><br></pre></td></tr></table></figure><p>此时，会在myblogs文件夹下生成相应的项目文件</p><p>如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva1.sinaimg.cn/large/007rpHi4gy1gnhjzvn0o0j30qt08tq76.jpg" alt="image"></p><hr><p>这里我们经常用到的有三个命令：（<code>请记住！</code>）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean # 用来清理缓存文件</span><br><span class="line">hexo g      #生成文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d   # 上传到服务器</span><br></pre></td></tr></table></figure><hr><p>在myblogs文件夹下启动hexo服务：（s代表server，默认端口号是<strong>4000</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时在本地打开浏览器，通过 <a href="http://localhost:4000/">http://localhost:4000/</a> 便可访问基于Hexo的个人博客主页了</p><p>如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva2.sinaimg.cn/large/007rpHi4gy1gnhk173egvj316y0nlgzm.jpg" alt="image"></p><p>说明本地环境搭建完成！</p><p>下面我们发布一篇博客进行测试</p><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>在博客主目录下，Git Bash here</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># FirstPost是你的文章名称</span></span><br><span class="line">hexo new FirstPost</span><br></pre></td></tr></table></figure><p>会在<code>source/_posts</code>目录下生成 FirstPost.md文件：这个文件就是你本篇博客，可以使用Markdown编辑器进行修改</p><h4 id="生成博客静态文件"><a href="#生成博客静态文件" class="headerlink" title="生成博客静态文件"></a>生成博客静态文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h4 id="启动博客"><a href="#启动博客" class="headerlink" title="启动博客"></a>启动博客</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>每次修改文章后，都需要通过<code>hexo clean</code>清理一下，然后通过<code>hexo g</code>重新生成，最后也不要忘了通过<code>hexo s</code>重新启动Hexo。</p><p>打开浏览器，输入<code>localhost:4000：</code> 便可以看见博客内容</p><hr><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>将需要更换的主题下载并解压缩到<code>theme/yourThemeName</code>目录下，yourThemeName是你给主题取的名字，</p><p>可以去官网下载主题：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p>解压完成后，修改_config.yaml文件中的<code>theme</code>属性，默认是<code>landscape</code>，修改为<code>yourThemeName</code>：</p><p>比如我下载的next主题</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span>                          <span class="comment">#注意：“theme:”后要带一个空格</span></span><br></pre></td></tr></table></figure><p>最后，进行部署到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp; hexo g &amp; hexo s </span><br></pre></td></tr></table></figure><p>访问即可！</p><p>至此，Hexo部署到本地我们就完成了！</p><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客写作配置栏</title>
      <link href="2020/01/01/%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/"/>
      <url>2020/01/01/%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>博客配置，可以直接复制使用，参数根据需要进行添加，详细事宜可参考：<a href="https://butterfly.js.org/posts/dc584b87/">Butterfly官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">updated: </span><br><span class="line">type: </span><br><span class="line"> - </span><br><span class="line"> - </span><br><span class="line">categories:</span><br><span class="line"> - </span><br><span class="line"> - </span><br><span class="line">tags: </span><br><span class="line"> - </span><br><span class="line"> -</span><br><span class="line">sticky: </span><br><span class="line">copyright: </span><br><span class="line">comments: </span><br><span class="line">description: </span><br><span class="line">keywords: </span><br><span class="line">top_img: </span><br><span class="line">toc_number: true</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">cover: </span><br></pre></td></tr></table></figure><hr><p>参数含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: 发表时间</span><br><span class="line">updated: 更新时间</span><br><span class="line">type: 文章类型</span><br><span class="line"> - </span><br><span class="line"> - </span><br><span class="line">categories: 文章分类</span><br><span class="line"> - </span><br><span class="line"> - </span><br><span class="line">tags: 文章标签</span><br><span class="line"> - </span><br><span class="line">toc_number: 是否显示文章标题顺序</span><br><span class="line">sticky: 置顶度，1开始，越大越往前</span><br><span class="line">comments: 是否显示评论</span><br><span class="line">description: 文章描述</span><br><span class="line">keywords: 关键字</span><br><span class="line">top_img: 文章顶部图片</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">copyright: 是否开启文章版权</span><br><span class="line">aside: 侧边栏</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">cover: 文章封面图</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tags: </span><br><span class="line"> - </span><br><span class="line">categories:</span><br><span class="line"> - </span><br><span class="line">cover: </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客选择</title>
      <link href="2020/01/01/Hexo%E5%8D%9A%E5%AE%A2/1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Hexo/"/>
      <url>2020/01/01/Hexo%E5%8D%9A%E5%AE%A2/1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么选择Hexo"><a href="#为什么选择Hexo" class="headerlink" title="为什么选择Hexo"></a>为什么选择Hexo</h1><p>目前，主流的博客主要分<code>静态博客</code>和<code>动态博客</code>两类：</p><ul><li>所谓动态，就是指有前端有后端，可以登录到后台进行管理</li><li>静态博客是纯前端的展示，没有后端</li></ul><hr><h3 id="动态博客搭建"><a href="#动态博客搭建" class="headerlink" title="动态博客搭建"></a>动态博客搭建</h3><p>a. 直接在简书、CSDN（最近吐槽的比较多）、知乎、博客园等动态博客公共平台上写</p><ul><li>优点：简单</li><li>缺点：别人家的东西限制多</li></ul><p>b. 使用 WordPress 等成熟框架搭建动态博客 + 服务器部署</p><ul><li>优点：相对简单</li><li>缺点：笨重</li></ul><p>c. 使用JavaPHP、Python等语言开发属于自己的动态博客 + 服务器部署</p><ul><li>优点：功能强大</li><li>缺点：<font color='red'>麻烦、不易上手</font></li></ul><hr><h3 id="静态博客搭建"><a href="#静态博客搭建" class="headerlink" title="静态博客搭建"></a>静态博客搭建</h3><p>a. 使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 托管在GitHub、码云等公共平台</p><ul><li>优点：轻量级、易上手、不花钱</li><li>缺点：<font color='red'>访问速度慢</font></li></ul><p>b. 使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 云端服务器部署</p><ul><li>优点：有独立的域名、访问速度快、自主可控</li><li>缺点：<font color='red'>要花钱买域名和云服务器</font></li></ul><hr><h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><p>Hexo可以理解为是基于node.js制作的一个博客工具。</p><p>它是一个<code>静态页面生成和上传的工具</code>。</p><p>Hexo在本地安装，不需要部署到我们的服务器上，我们只需要在本地通过markdown编写文章，然后让Hexo帮我们生成静态的html页面，并通过Hexo将生成的html文件上传到我们的服务器。</p><hr><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>使用Hexo搭建个人博客并自动部署到阿里云ECS服务器的原理如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva4.sinaimg.cn/large/007rpHi4gy1gnhknjrtzhj33341qiqar.jpg" alt="image"></p><p>简单来说就是在本地计算机搭建Hexo环境，Hexo通过generate命令将*.md文件渲染成静态的html页面，然后Hexo通过deploy命令触发git用户通过公钥免密登陆服务器，进而将静态页面推送到服务器的git仓库（repository）中。然后，服务器再通过钩子（git-hooks） 将静态页面checkout到网站的根目录下，进而实现博客的自动部署。具体过程如图中实线箭头所示。</p><p>而我们搭建在github上与此类似，利用 Vercel  解决访问速度慢的问题（代替了使用阿里云服务器）。具体后面再说</p><hr><div class="note default simple"><p>参考文章：<a href="https://blog.csdn.net/A_TangNotes/article/details/104940098">Hexo选择</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
