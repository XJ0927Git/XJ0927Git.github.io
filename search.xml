<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>9_RabbitMQ高级特性</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/9-RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/9-RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="9-RabbitMQ高级特性"><a href="#9-RabbitMQ高级特性" class="headerlink" title="9_RabbitMQ高级特性"></a>9_RabbitMQ高级特性</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>生产端向rabbitmq发送消息时，由于网络等原因可能导致消息发送失败。所以，rabbitmq必须有机制确保消息能准确到达mq，如果不能到达，必须反馈给生产端进行重发。</p><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>RabbitMQ消息的可靠性投递主要两种实现：<br>1、通过实现消费的重试机制，通过@Retryable来实现重试，可以设置重试次数和重试频率；<br>2、生产端实现消息可靠性投递。</p><p>两种方法消费端都可能收到重复消息，要求消费端必须实现幂等性消费。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121939.png"></p><hr><h2 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h2><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式</p><ul><li>confirm 确认模式 </li><li>return 退回模式</li></ul><hr><h4 id="消息投递到exchange的确认模式"><a href="#消息投递到exchange的确认模式" class="headerlink" title="消息投递到exchange的确认模式"></a>消息投递到exchange的确认模式</h4><p>rabbitmq的消息投递的过程为：</p><p>producer ——&gt; rabbitmq broker cluster ——&gt; exchange ——&gt; queue ——&gt; consumer</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121940.png"></p><ul><li>生产端发送消息到rabbitmq broker cluster后，异步接受从rabbitmq返回的ack确认信息</li><li>生产端收到返回的ack确认消息后，根据ack是true还是false，调用confirmCallback接口进行处理</li></ul><h5 id="1、改yml"><a href="#1、改yml" class="headerlink" title="1、改yml"></a>1、改yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># rabbitmq 连接配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启confirm确认模式</span></span><br></pre></td></tr></table></figure><h5 id="2、实现confirm方法"><a href="#2、实现confirm方法" class="headerlink" title="2、实现confirm方法"></a>2、实现confirm方法</h5><p>实现ConfirmCallback接口中的confirm方法，消息只要被 rabbitmq broker接收到就会触ConfirmCallback 回调，ack为true表示消息发送成功，ack为false表示消息发送失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 实现ConfirmCallback接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-13 12:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmCallbackService</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 相关配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack exchange交换机 是否成功收到了消息。true 成功，false代表失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            <span class="comment">//接收成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成功发送到交换机&lt;===&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//接收失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;失败原因:===&gt;&quot;</span> + cause);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//TODO 做一些处理:消息再次发送等等</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h5><h6 id="定义-Exchange-和-Queue"><a href="#定义-Exchange-和-Queue" class="headerlink" title="定义 Exchange 和 Queue"></a>定义 Exchange 和 Queue</h6><p>定义交换机 <code>confirmTestExchange</code> 和队列 <code>confirm_test_queue</code> ，并将队列绑定在交换机上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  队列与交换机绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-13 12:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;confirmTestQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmTestQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;confirm_test_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;confirmTestExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">confirmTestExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;confirmTestExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">confirmTestFanoutExchangeAndQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Qualifier(&quot;confirmTestExchange&quot;)</span> FanoutExchange confirmTestExchange,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Qualifier(&quot;confirmTestQueue&quot;)</span> Queue confirmTestQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmTestQueue).to(confirmTestExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = RabbitmqApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfirmCallbackService confirmCallbackService; <span class="comment">//注入ConfirmCallback对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallbackService);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;confirmTestExchange1&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;hello,ConfirmCallback你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确情况，ack返回true，表示投递成功。</p><p>现在我们改变交换机名字，发送到一个不存在的交换机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送消息</span><br><span class="line"> rabbitTemplate.convertAndSend(&quot;confirmTestExchange1&quot;, &quot;&quot;, &quot;hello,ConfirmCallback你好&quot;);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121941.png"></p><hr><h4 id="消息未投递到queue的退回模式"><a href="#消息未投递到queue的退回模式" class="headerlink" title="消息未投递到queue的退回模式"></a>消息未投递到queue的退回模式</h4><p>消息从 exchange–&gt;queue 投递失败则会返回一个 returnCallback</p><p>生产端通过实现ReturnCallback接口，启动消息失败返回，消息路由不到队列时会触发该回调接口</p><h5 id="1、改yml-1"><a href="#1、改yml-1" class="headerlink" title="1、改yml"></a>1、改yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># rabbitmq 连接配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启退回模式</span></span><br></pre></td></tr></table></figure><h5 id="2、设置投递失败的模式"><a href="#2、设置投递失败的模式" class="headerlink" title="2、设置投递失败的模式"></a>2、设置投递失败的模式</h5><p> 如果消息没有路由到Queue，则丢弃消息（默认） </p><p>如果消息没有路由到Queue，返回给消息发送方ReturnCallBack（开启后）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setMandatory(true);</span><br></pre></td></tr></table></figure><h5 id="2、实现returnedMessage方法"><a href="#2、实现returnedMessage方法" class="headerlink" title="2、实现returnedMessage方法"></a>2、实现returnedMessage方法</h5><p>启动消息失败返回，消息路由不到队列时会触发该回调接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-13 12:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnCallbackService</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyCode  错误码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyText  错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange   交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息对象===&gt;:&quot;</span> + message);</span><br><span class="line">        System.out.println(<span class="string">&quot;错误码===&gt;:&quot;</span> + replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;错误信息===&gt;:&quot;</span> + replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的交换器===&gt;:&quot;</span> + exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的路由key===&gt;:&quot;</span> + routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO ===&gt;做业务处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3、测试-1"><a href="#3、测试-1" class="headerlink" title="3、测试"></a>3、测试</h5><h6 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = RabbitmqApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfirmCallbackService confirmCallbackService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ReturnCallbackService returnCallbackService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确保消息发送失败后可以重新返回到队列中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息投递到队列失败回调处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(returnCallbackService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息投递确认模式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallbackService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;confirmTestExchange&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;hello,ConfirmCallback你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不存在路由key”dire”，会调用ReturnCallback接口</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121942.png"></p><hr><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><h4 id="消息确认机制ack"><a href="#消息确认机制ack" class="headerlink" title="消息确认机制ack"></a>消息确认机制ack</h4><p>ack指Acknowledge确认。 表示消费端收到消息后的确认方式</p><p>消费端消息的确认分为：自动确认（默认）、手动确认、不确认</p><ul><li>AcknowledgeMode.NONE：不确认</li><li>AcknowledgeMode.AUTO：自动确认</li><li>AcknowledgeMode.MANUAL：手动确认</li></ul><p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息 缓存中移除。</p><p>但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了 手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用 channel.basicNack()方法，让其自动重新发送消息。</p><hr><h6 id="1、改yml-2"><a href="#1、改yml-2" class="headerlink" title="1、改yml"></a>1、改yml</h6><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment"># 手动确认</span></span><br></pre></td></tr></table></figure><h6 id="2、确认配置"><a href="#2、确认配置" class="headerlink" title="2、确认配置"></a>2、确认配置</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;confirm_test_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processHandler</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息内容===&gt;&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//TODO 具体业务逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//手动签收[参数1:消息投递序号,参数2:批量签收]</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//拒绝签收[参数1:消息投递序号,参数2:批量拒绝,参数3:是否重新加入队列]</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel.basicNack 方法与 channel.basicReject 方法区别在于basicNack可以批量拒绝多条消息，而basicReject一次只能拒绝一条消息。</p><h6 id="3、测试-2"><a href="#3、测试-2" class="headerlink" title="3、测试"></a>3、测试</h6><p>正常情况</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121943.png"></p><p>异常情况</p><p>在业务处理模块增加异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;TODO 具体业务逻辑</span><br><span class="line">System.out.println(&quot;开始处理业务逻辑代码:&#x3D;&#x3D;&gt;&quot;);</span><br><span class="line">int i &#x3D; 3&#x2F;0;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121944.png"></p><p>发生异常，拒绝确认，重新加入队列，一直循环，知道确认消息。</p><hr><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>假设一个场景，首先，我们 Rabbitmq 服务器积压了有上万条未处理的消息，我们随便打开一个消费者客户端，会出现这样情况: 巨量的消息瞬间全部推送过来，但是我们单个客户端无法同时处理这么多数据!</p><p>当数据量特别大的时候，我们对生产端限流肯定是不科学的，因为有时候并发量就是特别大，有时候并发量又特别少，我们无法约束生产端，这是用户的行为。所以我们应该对消费端限流，用于保持消费端的稳定，当消息数量激增的时候很有可能造成资源耗尽，以及影响服务的性能，导致系统的卡顿甚至直接崩溃。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121945.png"></p><hr><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>Time To Live，消息过期时间设置</p><p>声明队列时，指定即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121946.png"></p><p>TTL:过期时间 </p><ol><li>队列统一过期 </li><li>消息单独过期</li></ol><p>如果设置了消息的过期时间，也设置了队列的过期时间，它以时间短的为准。 </p><p>​    * 队列过期后，会将队列所有消息全部移除</p><p>​    * 消息过期后，只有消息在队列顶端，才会判断其是否过期(移除掉)</p><hr><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以 </p><p>被重新发送到另一个交换机，这个交换机就是DLX</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121947.png"></p><p><strong>消息成为死信的三种情况：</strong> </p><ol><li><p>队列消息长度到达限制； </p></li><li><p>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false； </p></li><li><p>原队列存在消息过期设置，消息到达超时时间未被消费；</p></li></ol><p><strong>队列绑定死信交换机：</strong> </p><p>给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key</p><p>也就是说此时Queue作为”生产者”</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121948.png"></p><hr><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费</p><p><strong>需求：</strong></p><ol><li><p>下单后，30分钟未支付，取消订单，回滚库存。 </p></li><li><p>新用户注册成功7天后，发送短信问候。 </p></li></ol><p><strong>实现方式：</strong> </p><ol><li><p>定时器 （×）</p></li><li><p>延迟队列 （√）</p></li></ol><hr><p><strong>实现步骤：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121949.png"></p><p>在RabbitMQ中并未提供延迟队列功能</p><p><strong>替代实现：</strong> TTL+死信队列 组合实现延迟队列的效果</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121950.png"></p><p>设置队列过期时间30分钟，当30分钟过后，消息未被消费，进入死信队列，路由到指定队列，调用库存系统，判断订单状态。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8_RabbitMQ 集群</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/8-RabbitMQ-%E9%9B%86%E7%BE%A4/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/8-RabbitMQ-%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="8-RabbitMQ-集群"><a href="#8-RabbitMQ-集群" class="headerlink" title="8_RabbitMQ 集群"></a>8_RabbitMQ 集群</h1><h2 id="普通集群-副本集群"><a href="#普通集群-副本集群" class="headerlink" title="普通集群(副本集群)"></a>普通集群(副本集群)</h2><p>默认情况下: RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121824.png"></p><p><strong>核心解决问题:</strong>  <font color='orange'>当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份</font></p><hr><h4 id="1、克隆三台主机"><a href="#1、克隆三台主机" class="headerlink" title="1、克隆三台主机"></a>1、克隆三台主机</h4><p>这里为了方便，我已经在克隆的主机上安装过rabbitmq，所以克隆的三台主机都已安装好rabbitmq</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 0.集群规划</span></span><br><span class="line">node1: 192.168.77.139 mq1  master 主节点</span><br><span class="line">node2: 192.168.77.140 mq2  repl1  副本节点</span><br><span class="line">node3: 192.168.77.131 mq3  repl2  副本节点</span><br></pre></td></tr></table></figure><h4 id="2、修改ip地址"><a href="#2、修改ip地址" class="headerlink" title="2、修改ip地址"></a>2、修改ip地址</h4><p>3台均是如此操作，分别修改为对应的ip</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看网络配置文件</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="section"># 修改配置文件</span></span><br><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line"><span class="section"># 修改ip如下：</span></span><br><span class="line">IPADDR=192.168.77.139</span><br><span class="line"></span><br><span class="line"><span class="section"># 重启网络</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><hr><h4 id="3、修改主机名和ip映射"><a href="#3、修改主机名和ip映射" class="headerlink" title="3、修改主机名和ip映射"></a>3、修改主机名和ip映射</h4><h5 id="修改ip映射"><a href="#修改ip映射" class="headerlink" title="修改ip映射"></a>修改ip映射</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.77.139 mq1 </span><br><span class="line">192.168.77.140 mq2 </span><br><span class="line">192.168.77.131 mq3</span><br></pre></td></tr></table></figure><p>三台都要如此操作</p><hr><h5 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># node1:</span></span><br><span class="line">vim /etc/hostname</span><br><span class="line">加入:  mq1</span><br><span class="line"><span class="section"># node2: </span></span><br><span class="line">vim /etc/hostname </span><br><span class="line">加入:  mq2</span><br><span class="line"><span class="section"># node3: </span></span><br><span class="line">vim /etc/hostname </span><br><span class="line">加入:  mq3</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 重启机器生效</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><hr><h4 id="4、同步cookie文件"><a href="#4、同步cookie文件" class="headerlink" title="4、同步cookie文件"></a>4、同步cookie文件</h4><p>因为rabbitmq是基于erlang语言开发的，集群开发要求cookie必须一致</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看cookie是否一致:</span></span><br><span class="line">node1: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line">node2: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line">node3: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line"></span><br><span class="line"><span class="section"># 如果不一致,在node1上执行:[同步cookie]</span></span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/</span><br></pre></td></tr></table></figure><hr><h4 id="5、测试各节点rabbitmq是否搭建成功"><a href="#5、测试各节点rabbitmq是否搭建成功" class="headerlink" title="5、测试各节点rabbitmq是否搭建成功"></a>5、测试各节点rabbitmq是否搭建成功</h4><h6 id="启动rabbitmq"><a href="#启动rabbitmq" class="headerlink" title="启动rabbitmq"></a>启动rabbitmq</h6><p>三台机器分别执行如下命令：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 启动插件管理</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq<span class="emphasis">_management</span></span><br><span class="line"><span class="emphasis"># 启动rabbitmq</span></span><br><span class="line"><span class="emphasis">systemctl start rabbitmq-server</span></span><br></pre></td></tr></table></figure><p>注意：关闭防火墙</p><hr><h6 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 分别访问</span></span><br><span class="line">http://192.168.77.139:15672/</span><br><span class="line">http://192.168.77.140:15672/</span><br><span class="line">http://192.168.77.141:15672/</span><br></pre></td></tr></table></figure><p>至此，rabbitmq各个节点环境搭建成功</p><hr><h4 id="6、后台启动rabbitmq所有节点"><a href="#6、后台启动rabbitmq所有节点" class="headerlink" title="6、后台启动rabbitmq所有节点"></a>6、后台启动rabbitmq所有节点</h4><p>如果你有使用管理插件方式启动rabbitmq，一定要先关掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure><p>再以后台方式启动<strong>rabbitmq</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached </span><br></pre></td></tr></table></figure><p>注意：这种方式启动没有使用插件管理，所以还不能访问web界面</p><hr><h4 id="7、备节点加入集群"><a href="#7、备节点加入集群" class="headerlink" title="7、备节点加入集群"></a>7、备节点加入集群</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在node2和node3执行加入集群命令:</span></span><br><span class="line"></span><br><span class="line"><span class="code">1.关闭       rabbitmqctl stop_app</span></span><br><span class="line"><span class="code">2.加入集群    rabbitmqctl join_cluster rabbit@mq1</span></span><br><span class="line"><span class="code">3.启动服务    rabbitmqctl start_app</span></span><br></pre></td></tr></table></figure><p>往哪个节点加，那个被加入的节点就是主节点</p><hr><h4 id="8、查看集群状态"><a href="#8、查看集群状态" class="headerlink" title="8、查看集群状态,"></a>8、查看集群状态,</h4><p>任意节点执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 如果出现如下显示,集群搭建成功:</span></span><br><span class="line">Cluster status of node rabbit@mq3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;]&#125;,</span><br><span class="line">&#123;running<span class="emphasis">_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;,</span></span><br><span class="line"><span class="emphasis">&#123;cluster_</span>name,&lt;&lt;&quot;rabbit@mq1&quot;&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions,[]&#125;,</span><br><span class="line">&#123;alarms,[&#123;rabbit@mq1,[]&#125;,&#123;rabbit@mq2,[]&#125;,&#123;rabbit@mq3,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure><hr><h4 id="9、登录管理界面"><a href="#9、登录管理界面" class="headerlink" title="9、登录管理界面"></a>9、登录管理界面</h4><p>访问任意一台主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.139:15672</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121825.png"></p><hr><h4 id="10、测试"><a href="#10、测试" class="headerlink" title="10、测试"></a>10、测试</h4><p>在node1上,创建队列，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121826.png"></p><p>查看node2和node3节点，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121827.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121828.png"></p><p>可以发现：主节点上创建队列，备节点node2和node3也可以看到相应队列</p><hr><p>给主节点node1发送消息，查看node2和node3，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121829.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121830.png"></p><p>从node2或者node3上消费消息，</p><p>可以发现：可以消费消息，它最终也是从主节点node1上获取消息，它本身不提供消息</p><hr><p>关闭node1节点,执行如下命令,查看node2和node3，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121831.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121832.png"></p><p>可以发现：主节点宕掉后，备节点可以看见队列，但不能提供服务，也即不能代替主节点做故障转移！</p><hr><h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a><font color='orange'>镜像集群</font></h2><p>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。</p><p>注意：实际生产中使用还要配合LVS和负载均衡使用</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121833.png"></p><hr><p><strong>注意：</strong> 镜像集群是在普通集群的基础上添加策略形成的，所以以下操作是在前面搭建好的普通集群上进行的</p><hr><p><strong>策略说明：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 命令格式</span></span><br><span class="line">rabbitmqctl set<span class="emphasis">_policy [-p <span class="xml"><span class="tag">&lt;<span class="name">vhost</span>&gt;</span></span>] [--priority <span class="xml"><span class="tag">&lt;<span class="name">priority</span>&gt;</span></span>] [--apply-to <span class="xml"><span class="tag">&lt;<span class="name">apply-to</span>&gt;</span></span>] <span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span>  <span class="xml"><span class="tag">&lt;<span class="name">definition</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 参数说明</span></span><br><span class="line"><span class="emphasis">-p Vhost： 可选参数，针对指定vhost下的queue进行设置</span></span><br><span class="line"><span class="emphasis">Name:     policy的名称</span></span><br><span class="line"><span class="emphasis">Pattern: queue的匹配模式(正则表达式)</span></span><br><span class="line"><span class="emphasis">Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span></span><br><span class="line"><span class="emphasis">            ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span></span><br><span class="line"><span class="emphasis">                        all：表示在集群中所有的节点上进行镜像</span></span><br><span class="line"><span class="emphasis">                        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span></span><br><span class="line"><span class="emphasis">                        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span></span><br><span class="line"><span class="emphasis">             ha-params：ha-mode模式需要用到的参数</span></span><br><span class="line"><span class="emphasis">                ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</span></span><br><span class="line"><span class="emphasis">                priority：可选参数，policy的优先级</span></span><br></pre></td></tr></table></figure><hr><h4 id="1、查看当前策略"><a href="#1、查看当前策略" class="headerlink" title="1、查看当前策略"></a>1、查看当前策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_policies</span><br></pre></td></tr></table></figure><h4 id="2、添加策略"><a href="#2、添加策略" class="headerlink" title="2、添加策略"></a>2、添加策略</h4><p>说明: 策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列</p><p>这里我的队列hello与/ems虚拟主机进行了一个绑定，所以我在设置策略时，就针对该虚拟主机下的队列进行设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all -p  &#39;&#x2F;ems&#39;  &#39;^hello&#39; &#39;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#39; </span><br></pre></td></tr></table></figure><hr><h4 id="3、查看界面"><a href="#3、查看界面" class="headerlink" title="3、查看界面"></a>3、查看界面</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121834.png"></p><hr><h4 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h4><p>向主节点发送消息，其他节点也可以进行同步。</p><p>现关闭主节点，查看另外两个节点node2和node3，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121835.png">可以发现：备节点node2代替成为主节点。</p><p>消费节点node2或者node3的消息，可以正常消费消息</p><hr><p>再次启动节点node1，发现主节点还是node2节点，node1成为备用节点</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121836.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7_MQ的应用场景</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/7-MQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/7-MQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="7-MQ的应用场景"><a href="#7-MQ的应用场景" class="headerlink" title="7_MQ的应用场景"></a>7_MQ的应用场景</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p><strong>场景说明：</strong> 用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式</p><p><font color='orange'>串行方式：</font>将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121737.png"></p><p><font color='orange'>并行方式：</font> 将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121738.png"></p><hr><p><font color='orange'>消息队列：</font>[可以使用广播模式]</p><p>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回. </p><p> 消息队列: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121739.png"></p><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍</p><hr><h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><p><strong>场景：</strong> 双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121740.png"></p><p>这种做法有一个缺点:</p><p>当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  </p><p><font color='orange'>引入消息队列： </font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121741.jpg"></p><ul><li><p><strong>订单系统:</strong> 用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</p></li><li><p><strong>库存系统:</strong> 订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.</p></li></ul><hr><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p><strong>场景:</strong>  秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  </p><p> <strong>作用:</strong></p><p>​            1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) </p><p>​            2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121742.png"></p><p><strong>流程：</strong></p><p>用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  </p><p>秒杀业务根据消息队列中的请求信息，再做后续处理.</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6_SpringBoot 实现RabbitMQ</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/6-SpringBoot-%E5%AE%9E%E7%8E%B0RabbitMQ/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/6-SpringBoot-%E5%AE%9E%E7%8E%B0RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="6-SpringBoot-实现RabbitMQ"><a href="#6-SpringBoot-实现RabbitMQ" class="headerlink" title="6_SpringBoot 实现RabbitMQ"></a>6_SpringBoot 实现RabbitMQ</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="1、建项目"><a href="#1、建项目" class="headerlink" title="1、建项目"></a>1、建项目</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121620.png"></p><h3 id="2、改pom"><a href="#2、改pom" class="headerlink" title="2、改pom"></a>2、改pom</h3><p>如果你没有使用springboot快速构建的方式启动项目，而是使用maven的方式进行构建，需要引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、建yml"><a href="#3、建yml" class="headerlink" title="3、建yml"></a>3、建yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 应用名称[非必须]</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springboot_rabbitmq</span></span><br><span class="line">  <span class="comment"># rabbitmq 连接配置</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.77</span><span class="number">.138</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># tcp端口</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ems</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 用户密码</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/ems</span> <span class="comment"># 虚拟主机</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>springboot提供的操作rabbitmq的对象为：<font color='orange'>RabbitTemplate</font></p><p>使用时候直接在项目中注入即可使用</p><hr><h2 id="第一种hello-world模型"><a href="#第一种hello-world模型" class="headerlink" title="第一种hello world模型"></a>第一种hello world模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121621.png"></p><p>直接发送给队列，不使用交换机</p><h4 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//helloworld 直连模式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发送消息[注意此时并不会立即创建队列，因为没有消费者存在]</span></span><br><span class="line">    <span class="comment">//参数1:队列名字</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello 模型&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//注入容器</span></span><br><span class="line"><span class="comment">//监听rabbitmq,参数1:队列名称,参数2:是否持久化,参数3:是否独占,参数4:是否自动删除</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;hello&quot;, durable = &quot;true&quot;, exclusive = &quot;false&quot;, autoDelete = &quot;false&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span> <span class="comment">//加上此注解后，会自动回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二种work模型"><a href="#第二种work模型" class="headerlink" title="第二种work模型"></a>第二种work模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121622.png"></p><h4 id="1-开发生产者-1"><a href="#1-开发生产者-1" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//work 任务模型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;work&quot;</span>, <span class="string">&quot;work 模型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者-1"><a href="#2-开发消费者-1" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//注入容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者1号</span></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span> <span class="comment">//@RabbitListener 也可以直接写在方法上进行回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者2号</span></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span>  <span class="comment">//@RabbitListener 也可以直接写在方法上进行回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置</p><hr><h2 id="第三种Fanout-广播模型"><a href="#第三种Fanout-广播模型" class="headerlink" title="第三种Fanout 广播模型"></a>第三种Fanout 广播模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121623.png"></p><p>只要临时队列绑定到了交换机，一发送消息，所有消费者都可以接收</p><h4 id="1-开发生产者-2"><a href="#1-开发生产者-2" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fanout 广播模型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不指定队列</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;logs&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;fanout模型&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者-2"><a href="#2-开发消费者-2" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">![<span class="number">5</span>](images/<span class="number">5.</span>png)<span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定临时队列与交换机</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;logs&quot;, type = &quot;fanout&quot;)//交换机名字与类型</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定临时队列与交换机</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;logs&quot;, type = &quot;fanout&quot;)//交换机名字与类型</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第四种Route-路由模型"><a href="#第四种Route-路由模型" class="headerlink" title="第四种Route 路由模型"></a>第四种Route 路由模型</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121624.png"></p><p>指定路由key，只有拥有相匹配路由的队列才能接收到消息</p><h4 id="1-开发生产者-3"><a href="#1-开发生产者-3" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//route 路由模型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需指定路由key</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;directs&quot;</span>, <span class="string">&quot;error&quot;</span>, <span class="string">&quot;direct模型&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者-3"><a href="#2-开发消费者-3" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;directs&quot;, type = &quot;direct&quot;),//交换机名字和类型</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;info&quot;, &quot;error&quot;&#125;//路由key</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;directs&quot;, type = &quot;direct&quot;),//交换机名字和类型</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;error&quot;&#125;//路由key</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="第五种Topic-订阅模型-动态路由模型"><a href="#第五种Topic-订阅模型-动态路由模型" class="headerlink" title="第五种Topic 订阅模型(动态路由模型)"></a>第五种Topic 订阅模型(动态路由模型)</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121625.png"></p><p>与route类型，只是需要指定动态的路由key</p><h4 id="1-开发生产者-4"><a href="#1-开发生产者-4" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;  <span class="comment">//注入rabbitmq对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//topic 订阅模型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需指定路由key</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;topics&quot;</span>, <span class="string">&quot;order.add&quot;</span>, <span class="string">&quot;指定的路由key为:user.add[topic模型]&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者-4"><a href="#2-开发消费者-4" class="headerlink" title="2.开发消费者"></a>2.开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;topics&quot;,type = &quot;topic&quot;),//交换机名称和类型</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;user.*&quot;&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">        @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(),//临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;topics&quot;,type = &quot;topic&quot;),//交换机名称和类型</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;user.*&quot;,&quot;produce.#&quot;,&quot;order.*&quot;&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_RabbitMQ连接工具类封装</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/5-RabbitMQ%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/5-RabbitMQ%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="5-RabbitMQ连接工具类封装"><a href="#5-RabbitMQ连接工具类封装" class="headerlink" title="5_RabbitMQ连接工具类封装"></a>5_RabbitMQ连接工具类封装</h1><h3 id="定义工具类"><a href="#定义工具类" class="headerlink" title="定义工具类"></a>定义工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> Created in 2021-01-08 15:54</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块：类加载时执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.77.138&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭通道连接和连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">(Channel channel, Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="使用工具类"><a href="#使用工具类" class="headerlink" title="使用工具类"></a>使用工具类</h3><h4 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象===&gt;使用工具类</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接中通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定对应消息队列</span></span><br><span class="line">        <span class="comment">//参数1:  队列名称 如果队列不存在自动创建</span></span><br><span class="line">        <span class="comment">//参数2:  用来定义队列特性是否要持久化 true 持久化队列   false 不持久化</span></span><br><span class="line">        <span class="comment">//参数3:  exclusive 是否独占队列  true 独占队列   false  不独占</span></span><br><span class="line">        <span class="comment">//参数4:  autoDelete: 是否在消费完成后自动删除队列  true 自动删除  false 不自动删除</span></span><br><span class="line">        <span class="comment">//参数5:  额外附加参数</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        <span class="comment">//参数1: 交换机名称 参数2:队列名称  参数3:传递息额外设置  参数4:消息的具体内容</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接===&gt;使用工具类</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2. 开发消费者"></a>2. 开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象===&gt;使用工具类</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定队列：与生产端一致</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取消息</span></span><br><span class="line">        <span class="comment">//参数1: 消费那个队列的消息 队列名称</span></span><br><span class="line">        <span class="comment">//参数2: 开始消息的自动确认机制</span></span><br><span class="line">        <span class="comment">//参数3: 消费时的回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;取出消息:===&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_Java 实现RabbitMQ</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/4-Java-%E5%AE%9E%E7%8E%B0RabbitMQ/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/4-Java-%E5%AE%9E%E7%8E%B0RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Java-实现RabbitMQ"><a href="#4-Java-实现RabbitMQ" class="headerlink" title="4_Java 实现RabbitMQ"></a>4_Java 实现RabbitMQ</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h4 id="1、新建-java-web-项目"><a href="#1、新建-java-web-项目" class="headerlink" title="1、新建 java web 项目"></a>1、新建 java web 项目</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121421.png"></p><h4 id="2、改pom"><a href="#2、改pom" class="headerlink" title="2、改pom"></a>2、改pom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.7.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>同时去掉测试依赖的<code>&lt;scope&gt;test&lt;/scope&gt;</code>，不然一会不能进行单元测试</p><hr><h2 id="第一种模型-直连"><a href="#第一种模型-直连" class="headerlink" title="第一种模型(直连)"></a>第一种模型(直连)</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121422.png"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息</li></ul><hr><p><strong>前提：</strong></p><ul><li>创建好虚拟主机</li><li>创建好用户</li><li>虚拟主机与用户进行绑定</li></ul><h3 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        <span class="comment">//创建连接mq的连接工厂对象</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置连接rabbitmq主机</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.77.138&quot;</span>);</span><br><span class="line">        <span class="comment">//设置端口号</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置访问虚拟主机的用户名和密码</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="comment">//设置连接那个虚拟主机</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取连接中通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定对应消息队列</span></span><br><span class="line">        <span class="comment">//参数1:  队列名称 如果队列不存在自动创建</span></span><br><span class="line">        <span class="comment">//参数2:  用来定义队列特性是否要持久化 true 持久化队列   false 不持久化</span></span><br><span class="line">        <span class="comment">//参数3:  exclusive 是否独占队列  true 独占队列   false  不独占</span></span><br><span class="line">        <span class="comment">//参数4:  autoDelete: 是否在消费完成后自动删除队列  true 自动删除  false 不自动删除</span></span><br><span class="line">        <span class="comment">//参数5:  额外附加参数</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        <span class="comment">//参数1: 交换机名称 参数2:队列名称  参数3:传递息额外设置  参数4:消息的具体内容</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产消息到队列：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121423.png"></p><hr><h3 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2. 开发消费者"></a>2. 开发消费者</h3><p>消费者端不能使用单元测试，需要一直监听</p><p>同时不关闭连接消息通道与连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.77.138&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定队列：与生产端一致</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取消息</span></span><br><span class="line">        <span class="comment">//参数1: 消费那个队列的消息 队列名称</span></span><br><span class="line">        <span class="comment">//参数2: 开始消息的自动确认机制[只要消费就从队列删除消息]</span></span><br><span class="line">        <span class="comment">//参数3: 消费时的回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;取出消息:===&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-API参数的说明"><a href="#3-API参数的说明" class="headerlink" title="3. API参数的说明"></a>3. API参数的说明</h3><p>注意：生产方队列的声明与消费方队列的声明要一致</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(&quot;hello&quot;,true,false,false,null);</span><br><span class="line"></span><br><span class="line"><span class="section"># &#x27;参数1&#x27;: 用来声明通道对应的队列 [ 如果不存在队列,会自动创建]</span></span><br><span class="line"><span class="section"># &#x27;参数2&#x27;: 用来指定是否持久化队列 [D: 指定后 rabbitmq 重启后不会消失 ]</span></span><br><span class="line"><span class="section"># &#x27;参数3&#x27;: 用来指定是否独占队列 [ 只允许当特定的连接]</span></span><br><span class="line"><span class="section"># &#x27;参数4&#x27;: 用来指定是否自动删除队列 [A：消息方消费完成后,队列自动删除]</span></span><br><span class="line"><span class="section"># &#x27;参数5&#x27;: 对队列的额外配置</span></span><br></pre></td></tr></table></figure><hr><h2 id="第二种模型-work-queue"><a href="#第二种模型-work-queue" class="headerlink" title="第二种模型(work queue)"></a>第二种模型(work queue)</h2><p>Work queues，也被称为（Task queues），<strong>任务模型</strong>。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用 work 模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121424.png"></p><p>角色：</p><ul><li>P：生产者：任务的发布者</li><li>C1：消费者-1，领取任务并且完成任务，假设完成速度较慢</li><li>C2：消费者-2：领取任务并完成任务，假设完成速度快</li></ul><hr><h3 id="1-开发生产者-1"><a href="#1-开发生产者-1" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;work&quot;</span>, <span class="keyword">null</span>, (i + <span class="string">&quot;号消息&quot;</span>).getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-开发消费者-1"><a href="#2-开发消费者-1" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//绑定队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理消息比较慢 2秒处理一个消息</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1号:==&gt;消费&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-开发消费者-2"><a href="#3-开发消费者-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//绑定队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2号:==&gt;消费&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4.测试结果"></a>4.测试结果</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121425.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121426.png"></p><p><strong>总结:</strong> 默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为<font color='orange'>循环。</font></p><hr><h3 id="5-消息自动确认机制"><a href="#5-消息自动确认机制" class="headerlink" title="5.消息自动确认机制"></a>5.消息自动确认机制</h3><p>如果想要实现消费快的多消费，消费慢的少消费，就需要对rabbitmq的消息确认机制进行配置</p><p>同时避免消息丢失</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121427.png"></p><p>两点：</p><ul><li><p>设置通道一次只能消费一个消息</p></li><li><p>关闭消息的自动确认,开启手动确认消息</p></li></ul><p><strong>消费方：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤一:一次只接受一条未确认的消息</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤二：[参数2:关闭自动确认消费]</span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;work&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2号:==&gt;消费&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        <span class="comment">//消费完成后,手动确认消息 [ 参数1:确认标识,参数2:是否一次确认多条消息]</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：消费方都需要进行手动确认，否则队列中不会确认删除</p><p><strong>生产方：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次只发送一条消息</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><p>消费者1号消费一条消息，2s后确认消息，消费者2号消费一条消息，手动确认，消息从队列删除，继续从队列取得一条进行消费，直到队列不存在消息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121428.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121429.png"></p><hr><h2 id="第三种模型-fanout"><a href="#第三种模型-fanout" class="headerlink" title="第三种模型(fanout)"></a>第三种模型(fanout)</h2><p>中文翻译：fanout 扇出 ，也称为<font color='orange'>广播</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121430.png"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li> 可以有多个消费者</li><li> 每个<strong>消费者有自己的queue</strong>（队列）</li><li> 每个<strong>队列都要绑定到Exchange</strong>（交换机）</li><li> <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li><li> 交换机把消息发送给绑定过的所有队列</li><li> 队列的消费者都能拿到消息。<strong>实现一条消息被多个消费者消费</strong></li></ul><hr><h3 id="1-开发生产者-2"><a href="#1-开发生产者-2" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h3><p>广播 ：一条消息多个消费者同时消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机 [ 参数一:交换机名字,参数2:交换机类型:fanout(广播模式) 固定]</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息[参数1:交换机名字,参数2:路由,参数3:消息持久化,参数4:消息内容]</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;fanout...&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开发消费者-1-1"><a href="#2-开发消费者-1-1" class="headerlink" title="2. 开发消费者-1"></a>2. 开发消费者-1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[绑定]=&gt;临时队列和交换机 [参数1:临时队列,参数2:交换机,参数3:路由]</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;register&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-开发消费者-2-1"><a href="#3-开发消费者-2-1" class="headerlink" title="3. 开发消费者-2"></a>3. 开发消费者-2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列和交换机 [参数1:临时队列,参数2:交换机,参数3:路由]</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;register&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-开发消费者-3"><a href="#4-开发消费者-3" class="headerlink" title="4.开发消费者-3"></a>4.开发消费者-3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列和交换机 [参数1:临时队列,参数2:交换机,参数3:路由]</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;register&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者3号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5. 测试结果"></a>5. 测试结果</h3><p>启动消费者，再启动生产者往交换机发送消息，三个消费者同时接收到消息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121431.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121432.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121433.png"></p><hr><h2 id="第四种模型-Routing"><a href="#第四种模型-Routing" class="headerlink" title="第四种模型(Routing)"></a>第四种模型(Routing)</h2><p>Routing 之订阅模型-Direct(直连)</p><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121434.png"></p><p> 在Direct模型中，流程如下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 <font color='orange'>RoutingKey</font>（路由key）</li><li>消息的发送方在向 Exchange发送消息时，也必须指定消息的 <font color='orange'>RoutingKey</font></li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的 <font color='orange'>RoutingKey</font> 进行判断，只有队列的Routingkey与消息的 Routing key 完全一致，才会接收到消息</li></ul><p><strong>图解：</strong></p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与 routing key 完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要 routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息</li></ul><hr><h3 id="1-开发生产者-3"><a href="#1-开发生产者-3" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机[参数1：交换机名字, 参数2:交换机类型,direct路由模式]=&gt;基于指令的 Routing key 转发</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布的路由名称==&gt;根据路由key的不同发送到不同的绑定队列中</span></span><br><span class="line">        String key = <span class="string">&quot;error&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息[参数1:交换机名字,参数2:路由名字,参数3:消息内容]</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;logs_direct&quot;</span>, key, <span class="keyword">null</span>, (<span class="string">&quot;发送给指定路由&quot;</span> + key + <span class="string">&quot;的消息&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开发消费者-1-2"><a href="#2-开发消费者-1-2" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机[参数1：交换机名字, 参数2:交换机类型,direct路由模式]</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列与交换机并设置指定路由名称</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;warn&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-开发消费者-2-2"><a href="#3-开发消费者-2-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机[参数1：交换机名字, 参数2:交换机类型,direct路由模式]</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列与交换机并设置指定路由名称</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2号:==&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><h4 id="测试生产者发送Route-key为error的消息时"><a href="#测试生产者发送Route-key为error的消息时" class="headerlink" title="测试生产者发送Route key为error的消息时"></a>测试生产者发送Route key为error的消息时</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121435.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121436.png"></p><hr><h4 id="测试生产者发送Route-key为info的消息时"><a href="#测试生产者发送Route-key为info的消息时" class="headerlink" title="测试生产者发送Route key为info的消息时"></a>测试生产者发送Route key为info的消息时</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121437.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121436.png"></p><hr><h2 id="第五种模型-Topic"><a href="#第五种模型-Topic" class="headerlink" title="第五种模型(Topic)"></a>第五种模型(Topic)</h2><p>Routing 之订阅模型-Topic</p><p>Topic 类型的 Exchange 与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列</p><p>只不过<code>Topic</code>类型 Exchange 可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p>这种模型 Routingkey 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121438.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 统配符</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*(star) can substitute for exactly one word.    匹配不多不少恰好1个词</span></span><br><span class="line"><span class="emphasis">#(hash) can substitute for zero or more words.  匹配一个或多个词</span></span><br><span class="line"><span class="emphasis"> </span></span><br><span class="line"><span class="emphasis"># 如:</span></span><br><span class="line"><span class="emphasis">audit.#    匹配audit.irs.corporate或者 audit.irs 等</span></span><br><span class="line"><span class="emphasis">audit.*</span>   只能匹配 audit.irs</span><br></pre></td></tr></table></figure><hr><h3 id="1-开发生产者-4"><a href="#1-开发生产者-4" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pro</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机[交换机名字+交换机类型]</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息==&gt;使用动态路由(通配符方式)</span></span><br><span class="line">        String key = <span class="string">&quot;user.update&quot;</span>; <span class="comment">//指定发布的路由key</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;topics&quot;</span>, key, <span class="keyword">null</span>, (<span class="string">&quot;发送消息给指定的路由key&quot;</span> + key).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        RabbitMQUtils.closeConnection(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开发消费者-1-3"><a href="#2-开发消费者-1-3" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h3><p>Routing Key中使用*通配符方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列与交换机并设置获取交换机中动态路由</span></span><br><span class="line">        String key = <span class="string">&quot;user.*&quot;</span>;<span class="comment">//使用通配符指定路由key</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;topics&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1号:===&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-开发消费者-2-3"><a href="#3-开发消费者-2-3" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h3><p>Routing Key中使用*通配符方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = RabbitMQUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明临时队列</span></span><br><span class="line">        String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定临时队列与交换机</span></span><br><span class="line">        String key = <span class="string">&quot;user.#&quot;</span>;<span class="comment">//使用通配符指定路由key</span></span><br><span class="line">        channel.queueBind(queue, <span class="string">&quot;topics&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        channel.basicConsume(queue, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2号:===&gt;&quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试结果-1"><a href="#4-测试结果-1" class="headerlink" title="4.测试结果"></a>4.测试结果</h3><h5 id="生产者发送user-update时"><a href="#生产者发送user-update时" class="headerlink" title="生产者发送user.update时"></a>生产者发送user.update时</h5><p>两个消费者都可以消费消息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121439.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121440.png"></p><h5 id="生产者发送user-update-to时"><a href="#生产者发送user-update-to时" class="headerlink" title="生产者发送user.update.to时"></a>生产者发送user.update.to时</h5><p>仅消费者2号可以消费消息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121439.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121441.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_RabbitMQ协议与消息模型</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/3-RabbitMQ%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/3-RabbitMQ%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="3-RabbitMQ协议与消息模型"><a href="#3-RabbitMQ协议与消息模型" class="headerlink" title="3_RabbitMQ协议与消息模型"></a>3_RabbitMQ协议与消息模型</h1><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>RabbitMQ是基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</p><p>AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。</p><p>顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121320.png"></p><hr><h3 id="RabbitMQ支持的消息模型"><a href="#RabbitMQ支持的消息模型" class="headerlink" title="RabbitMQ支持的消息模型"></a>RabbitMQ支持的消息模型</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121321.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121322.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_web管理界面介绍</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/2-web%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/2-web%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="2-web管理界面介绍"><a href="#2-web管理界面介绍" class="headerlink" title="2_web管理界面介绍"></a>2_web管理界面介绍</h1><h3 id="overview概览"><a href="#overview概览" class="headerlink" title="overview概览"></a>overview概览</h3><p>web界面连接rabbitmq的端口是15672</p><p>Java连接rabbitmq使用的是http端口5672</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121213.png"></p><ul><li><p><strong>connections：</strong> 无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况</p></li><li><p><strong>channels：</strong> 通道，建立连接后，会形成通道，消息的投递获取依赖通道</p></li><li><p><strong>Exchanges：</strong> 交换机，用来实现消息的路由</p></li><li><p><strong>Queues：</strong> 队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列</p></li></ul><hr><h3 id="Admin用户和虚拟主机管理"><a href="#Admin用户和虚拟主机管理" class="headerlink" title="Admin用户和虚拟主机管理"></a>Admin用户和虚拟主机管理</h3><h4 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1.添加用户"></a>1.添加用户</h4><p>Tags选项，其实是指定用户的角色，可选的有以下几个：</p><ul><li><strong>超级管理员(administrator)：</strong>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作</li><li><strong>监控者(monitoring)：</strong>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</li><li><strong>策略制定者(policymaker)：</strong>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)</li><li><strong>普通管理者(management)：</strong>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理</li><li><strong>其他：</strong>无法登陆管理控制台，通常就是普通的生产者和消费者</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121214.png"></p><hr><h4 id="2-创建虚拟主机"><a href="#2-创建虚拟主机" class="headerlink" title="2. 创建虚拟主机"></a>2. 创建虚拟主机</h4><p>为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121215.png"></p><hr><h4 id="3-绑定虚拟主机和用户"><a href="#3-绑定虚拟主机和用户" class="headerlink" title="3. 绑定虚拟主机和用户"></a>3. 绑定虚拟主机和用户</h4><p>创建好虚拟主机，我们还要给用户添加访问权限</p><p>点击添加好的虚拟主机：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121216.png"></p><p>进入虚拟机设置界面:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121217.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_RabbitMQ的安装</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/1-RabbitMQ-%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/1-RabbitMQ-%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-RabbitMQ-的安装"><a href="#1-RabbitMQ-的安装" class="headerlink" title="1_RabbitMQ 的安装"></a>1_RabbitMQ 的安装</h1><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>官网下载地址: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;download.html</span><br></pre></td></tr></table></figure><p>百度网盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1cngvGgR_EMlBLxFhSAM72w </span><br><span class="line">提取码：0n6a </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121053.png"></p><p>需要的安装包如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121054.png"></p><p><strong>注意:</strong> 这里的安装包是centos7安装的包</p><hr><h4 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.将rabbitmq安装包上传到linux系统中</span></span><br><span class="line">erlang-22.0.7-1.el7.x86<span class="emphasis">_64.rpm</span></span><br><span class="line"><span class="emphasis">rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.安装Erlang依赖包</span></span><br><span class="line">rpm -ivh erlang-22.0.7-1.el7.x86<span class="emphasis">_64.rpm</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 安装erlang开发环境包</span></span><br><span class="line"><span class="emphasis">rpm -ivh socat-1.7.3.2-2.el7.x86_</span>64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.安装RabbitMQ安装包(在线安装方式：需要联网)</span></span><br><span class="line">yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.本地安装</span></span><br><span class="line">rpm -ivh rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><hr><h4 id="3、复制配置文件"><a href="#3、复制配置文件" class="headerlink" title="3、复制配置文件"></a>3、复制配置文件</h4><p><strong>注意:</strong> </p><p>默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,</p><p>需要将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 4.复制配置文件</span></span><br><span class="line">cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br><span class="line"></span><br><span class="line"><span class="section"># 5.查看配置文件位置</span></span><br><span class="line">ls /etc/rabbitmq/rabbitmq.config</span><br></pre></td></tr></table></figure><h4 id="4、修改配置文件"><a href="#4、修改配置文件" class="headerlink" title="4、修改配置文件"></a>4、修改配置文件</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 6.修改配置文件(参见下图:)</span></span><br><span class="line">vim /etc/rabbitmq/rabbitmq.config </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121055.png"></p><p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121056.png"></p><hr><h4 id="5、启动管理插件"><a href="#5、启动管理插件" class="headerlink" title="5、启动管理插件"></a>5、启动管理插件</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 执行如下命令,启动rabbitmq中的插件管理</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq<span class="emphasis">_management</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">    出现如下说明:</span></span><br><span class="line"><span class="emphasis">    Enabling plugins on node rabbit@localhost:</span></span><br><span class="line"><span class="emphasis">    rabbitmq_</span>management</span><br><span class="line"><span class="code">    The following plugins have been configured:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    rabbitmq_management_agent</span></span><br><span class="line"><span class="code">    rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code">    Applying plugin configuration to rabbit@localhost...</span></span><br><span class="line"><span class="code">    The following plugins have been enabled:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    rabbitmq_management_agent</span></span><br><span class="line"><span class="code">    rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">set 3 plugins.</span></span><br><span class="line"><span class="code">Offline change; changes will take effect at broker restart.</span></span><br></pre></td></tr></table></figure><hr><h4 id="6、启动RabbitMQ的服务"><a href="#6、启动RabbitMQ的服务" class="headerlink" title="6、启动RabbitMQ的服务"></a>6、启动RabbitMQ的服务</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 8.启动RabbitMQ的服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="section"># 重启RabbitMQ的服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br><span class="line"><span class="section"># 停止RabbitMQ的服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"><span class="section"># 查看服务状态(见下图:)</span></span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121057.png"></p><h4 id="7、关闭防火墙"><a href="#7、关闭防火墙" class="headerlink" title="7、关闭防火墙"></a>7、关闭防火墙</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 关闭防火墙服务</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld   </span><br></pre></td></tr></table></figure><hr><h4 id="8、访问web管理界面"><a href="#8、访问web管理界面" class="headerlink" title="8、访问web管理界面"></a>8、访问web管理界面</h4><p>访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:15672</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121058.png"></p><hr><h4 id="9、登录管理界面"><a href="#9、登录管理界面" class="headerlink" title="9、登录管理界面"></a>9、登录管理界面</h4><p>默认账户密码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 登录管理界面</span></span><br><span class="line">username:  guest</span><br><span class="line">password:  guest</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219121059.png"></p><p>至此，RabbitMQ的安装到此完成！</p><hr><h4 id="10、RabiitMQ-配置"><a href="#10、RabiitMQ-配置" class="headerlink" title="10、RabiitMQ 配置"></a>10、RabiitMQ 配置</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.服务启动相关 [启动|重启|停止]</span></span><br><span class="line">systemctl start|restart|stop|status rabbitmq-server</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ</span></span><br><span class="line">rabbitmqctl  help  可以查看更多命令</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.插件管理命令行</span></span><br><span class="line">rabbitmq-plugins enable|list|disable </span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0_RabbitMQ简介</title>
      <link href="2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/0-RabbitMQ%E7%AE%80%E4%BB%8B/"/>
      <url>2021/02/19/%E4%B8%AD%E9%97%B4%E4%BB%B6/0-RabbitMQ%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="0-RabbitMQ简介"><a href="#0-RabbitMQ简介" class="headerlink" title="0_RabbitMQ简介"></a>0_RabbitMQ简介</h1><p>👉：来源于哔哩哔哩”编程不良人”视频：<a href="https://www.bilibili.com/video/BV1dE411K7MG?p=1">MQ消息中间件之RabbitMQ以及整合SpringBoot2.x实战教程,已完结!</a></p><hr><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>MQ(Message Quene) :  翻译为 <code>消息队列</code>,通过典型的 <code>生产者</code>和<code>消费者</code>模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 <code>消息中间件</code>    通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p><hr><h2 id="MQ种类"><a href="#MQ种类" class="headerlink" title="MQ种类"></a>MQ种类</h2><p>当今市面上有很多主流的消息中间件，如老牌的 ActiveMQ、RabbitMQ，炙手可热的 Kafka，阿里巴巴自主开发RocketMQ等。</p><p>不同MQ特点：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.ActiveMQ</span></span><br><span class="line"><span class="code">ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.Kafka</span></span><br><span class="line"><span class="code">Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，</span></span><br><span class="line"><span class="code">追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，</span></span><br><span class="line"><span class="code">适合产生大量数据的互联网服务的数据收集业务。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 3.RocketMQ</span></span><br><span class="line"><span class="code">RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起</span></span><br><span class="line"><span class="code">源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消</span></span><br><span class="line"><span class="code">息推送、日志流式处理、binglog分发等场景。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 4.RabbitMQ</span></span><br><span class="line"><span class="code">RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在</span></span><br></pre></td></tr></table></figure><p><font color='orange'>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</font></p><hr><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一</p><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;</span><br></pre></td></tr></table></figure><p>官方教程: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;#getstarted</span><br></pre></td></tr></table></figure><p> AMQP 协议：AMQP（advanced message queuing protocol）在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219120945.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9_ GC 四大算法详解</title>
      <link href="2021/02/19/JVM/9-GC-%E5%9B%9B%E5%A4%A7%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/02/19/JVM/9-GC-%E5%9B%9B%E5%A4%A7%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="9-GC-四大算法详解"><a href="#9-GC-四大算法详解" class="headerlink" title="9_ GC 四大算法详解"></a>9_ GC 四大算法详解</h1><h2 id="GC垃圾收集机制"><a href="#GC垃圾收集机制" class="headerlink" title="GC垃圾收集机制"></a>GC垃圾收集机制</h2><p>对于GC垃圾收集机制，我们需要记住以下几点：</p><ol><li>次数上频繁收集Young区。</li><li>次数上较少收集Old区。</li><li>基本不动元空间。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115842.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115843.png"></p><p><font color='red'>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。</font></p><p>因此GC按照回收的区域又分了两种类型：</p><ul><li><strong>普通GC（minor GC）：</strong> 只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。</li><li><strong>全局GC（major GC or Full GC）：</strong> 指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上</li></ul><hr><h2 id="GC日志信息详解"><a href="#GC日志信息详解" class="headerlink" title="GC日志信息详解"></a>GC日志信息详解</h2><h3 id="YGC相关参数"><a href="#YGC相关参数" class="headerlink" title="YGC相关参数"></a>YGC相关参数</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115844.png"></p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1580K-&gt;504K(2560K)] 1580K-&gt;764K(9728K), 0.0167268 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.02 secs] </span><br></pre></td></tr></table></figure><hr><h3 id="FGC相关参数"><a href="#FGC相关参数" class="headerlink" title="FGC相关参数"></a>FGC相关参数</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115845.png"></p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 592K-&gt;574K(7168K)] 592K-&gt;574K(9728K), [Metaspace: 3158K-&gt;3158K(1056768K)], 0.0040996 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br></pre></td></tr></table></figure><hr><p>使用规律：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115846.png"></p><hr><h2 id="判断-Java-对象存活算法"><a href="#判断-Java-对象存活算法" class="headerlink" title="判断 Java 对象存活算法"></a>判断 Java 对象存活算法</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a><del>1. 引用计数算法</del></h3><blockquote><p>引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器 +1，当引用失效的时候，计数器 -1，当计数器为 0 的时候，JVM 就认为对象不再被使用，即判定为“垃圾”了。</p></blockquote><p>优点：</p><ul><li>引用计数器实现简单，效率高</li></ul><p>缺点：</p><ul><li>不能解决循环引用问问题 （A对象引用B对象，B对象又引用A对象，但是 A,B 对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在 JDK 1.1 之后，这个算法已经不再使用了。</li></ul><hr><h3 id="2-根搜索方法"><a href="#2-根搜索方法" class="headerlink" title="2. 根搜索方法"></a>2. 根搜索方法</h3><blockquote><p>也叫可达性分析算法 。</p></blockquote><p><font color='red'>根搜索方法是通过一些 “GCRoots” 对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain），当一个对象没有被 GCRoots 的引用链连接的时候，说明这个对象是不可用的 。</font></p><p><strong>GCRoots对象包括：</strong></p><ol><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法栈中JNI（<code>Native</code>方法）的引用的对象。</li><li>方法区域中的类静态属性引用的对象。</li><li>方法区域中常量引用的对象。</li></ol><hr><p>实例：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115847.png"> </p><hr><h2 id="四大算法"><a href="#四大算法" class="headerlink" title="四大算法"></a>四大算法</h2><h3 id="1-复制算法-Copying"><a href="#1-复制算法-Copying" class="headerlink" title="1. 复制算法(Copying)"></a>1. 复制算法(Copying)</h3><blockquote><p>适用于<code>新生代</code></p></blockquote><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>年轻代中的 GC,主要是复制算法（Copying）。 HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫 from 和 to）。默认比例为 8:1:1,一般情况下，新创建的对象都会被分配到 Eden 区(一些大对象特殊处理),这些对象经过第一次 Minor GC 后，如果仍然存活，将会被移到 Survivor 区。对象在 Survivor 区中每熬过一次 Minor GC，年龄就会增加 1 岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，<strong>所以在年轻代的垃圾回收算法使用的是复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块(from)，当这一块内存用完，就将还活着的对象复制到另外一块上面。</p><hr><p>在 GC 开始的时候，对象只会存在于 Eden 区和名为“ From ”的 Survivor 区，Survivor区“ To ”是空的。紧接着进行 GC，Eden 区中所有存活的对象都会被复制到 “ To ”，而在“ From ”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到 “ To ”区域。<strong>经过这次GC后，Eden 区和 From 区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“ To ”就是上次 GC 前的“From”，新的“From”就是上次GC前的“To”</strong>。不管怎样，都会保证名为 To 的Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“ To ”区被填满，“ To ”区被填满之后，会将所有对象移动到年老代中。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115848.png"></p><p>因为 Eden 区对象一般存活率较低，一般的，使用两块 10% 的内存作为空闲和活动区间，而另外 80% 的内存，则是用来给新建对象分配内存的。一旦发生 GC，将 10% 的 from 活动区间与另外80%中存活的 eden 对象转移到 10% 的 to 空闲区间，接下来，将之前 90% 的内存全部释放，以此类推。</p><blockquote><p><code>-XX:MaxTenuringThreshold </code>：— 设置对象在新生代中存活的次数</p></blockquote><hr><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong> ：不会产生内存碎片，效率高。<br><strong>缺点</strong> ：耗费内存空间。</p><p>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。</p><p>所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p><hr><h3 id="2-标记清除-Mark-Sweep"><a href="#2-标记清除-Mark-Sweep" class="headerlink" title="2 .标记清除(Mark-Sweep)"></a>2 .标记清除(Mark-Sweep)</h3><blockquote><p>适用于<code>老年代</code></p></blockquote><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>标记清除算法，主要分成标记和清除两个阶段，<font color='red'>先标记出要回收的对象，然后统一回收这些对象</font>，如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115849.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115850.gif"></p><p>用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC 线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。</p><p>主要进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li>标记：从引用根节点开始标记遍历所有的GC Roots， 先标记出要回收的对象。</li><li>清除：遍历整个堆，把标记的对象清除。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115851.png"></p><hr><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong> ：不需要额外的内存空间。<br><strong>缺点</strong> ：需要暂停整个应用，会产生内存碎片；两次扫描，耗时严重。</p><p>简单来说，它的缺点就是<strong>效率比较低</strong>（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲。</p><p>而且这种方式<strong>清理出来的空闲内存是不连续</strong>的，这点不难理解，我们的死亡对象都是随机分布在内存当中，现在把它们清除之后，内存的布局自然会零碎不连续。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。并且在分配数组对象的时候，需要去内存寻找连续的内存空间，但此时的内存空间太过零碎分散，因此资源耗费加大。</p><hr><h3 id="3-标记压缩-Mark-Compact"><a href="#3-标记压缩-Mark-Compact" class="headerlink" title="3. 标记压缩(Mark-Compact)"></a>3. 标记压缩(Mark-Compact)</h3><blockquote><p>适用于<code>老年代</code></p><p>标记压缩(Mark-Compact)又叫标记清除压缩(Mark-Sweep-Compact)，或者标记清除整理算法</p></blockquote><h4 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h4><p>简单来说，就是<strong>先标记，后整理</strong>，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115852.gif"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115853.png"></p><hr><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong> ：没有内存碎片。<br><strong>缺点</strong> ：需要移动对象的成本，效率也不高（不仅要标记所有存活对象，还要整理所有存活对象的引用地址）。</p><p>标记清除压缩（Mark-Sweep-Compact）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115854.png"></p><hr><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.  分代收集算法"></a>4.  分代收集算法</h3><blockquote><p>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，<font color='red'>一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。</font></p><p>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用<code>复制算法</code>，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用<code>“标记清理”或者“标记整理”算法</code>来进行回收。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115855.png"></p><p>图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="年轻代（Young-Gen）"><a href="#年轻代（Young-Gen）" class="headerlink" title="年轻代（Young Gen）"></a>年轻代（Young Gen）</h4><blockquote><p><strong>年轻代特点是内存空间相对老年代较小，对象存活率低。</strong></p></blockquote><p>复制算法的效率只和当前存活对象大小有关，因而很适用于年轻代的回收。而复制算法的内存利用率不高的问题，可以通过虚拟机中的两个<code>Survivor</code>区设计得到缓解。</p><hr><h4 id="老年代（Tenure-Gen）"><a href="#老年代（Tenure-Gen）" class="headerlink" title="老年代（Tenure Gen）"></a>老年代（Tenure Gen）</h4><blockquote><p><strong>老年代的特点是内存空间较大，对象存活率高。</strong></p></blockquote><p>这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</p><p>（1）<strong>标记阶段（Mark）</strong> 的开销与存活对象的数量成正比。这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。<br>（2）<strong>清除阶段（Sweep）</strong> 的开销与所管理内存空间大小形正相关。但Sweep“就地处决”的特点，回收的过程没有对象的移动。使其相对其他有对象移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。<br>（3）<strong>整理阶段（Compact）</strong> 的开销与存活对象的数据成开比。如上一条所描述，对于大量对象的移动是很大开销的，做为老年代的第一选择并不合适。</p><p>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以虚拟机中的CMS回收器为例，CMS是基于<code>Mark-Sweep</code>实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于<code>Mark-Compact</code>算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的<code>Concurrent Mode Failure</code>时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p><hr><p>常见面试问题：</p><blockquote><p>问题1：GC四种算法哪个好？</p></blockquote><p>没有哪个算法是能一次性解决所有问题的，因为JVM垃圾回收使用的是分代收集算法，没有最好的算法，只有根据每一代他的垃圾回收的特性用对应的算法。例如新生代使用复制算法，老年代使用标记清除和标记整理算法。<br>所以说，没有最好的垃圾回收机制，只有最合适的。</p><blockquote><p>问题2：请说出各个垃圾回收算法的优缺点</p></blockquote><p><strong>（1）内存效率：</strong> 复制算法 &gt; 标记清除算法 &gt; 标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。<br><strong>（2）内存整齐度：</strong> 复制算法 = 标记整理算法 &gt; 标记清除算法。<br><strong>（3）内存利用率：</strong> 标记整理算法 = 标记清除算法 &gt; 复制算法。</p><p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记清除多了一个整理内存的过程。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8_Java堆</title>
      <link href="2021/02/19/JVM/8-Java%E5%A0%86/"/>
      <url>2021/02/19/JVM/8-Java%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="8-Java堆"><a href="#8-Java堆" class="headerlink" title="8_Java堆"></a>8_Java堆</h1><blockquote><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。</p></blockquote><h2 id="堆体系结构"><a href="#堆体系结构" class="headerlink" title="堆体系结构"></a>堆体系结构</h2><p><strong>JDK 1.7：</strong>  <font color='red'>永久代使用的是堆空间内存</font></p><p>类加载器读取了类文件之后，需要把类、方法、常量变量放到堆内存中，保持所以引用类型的真实信息，方便执行器执行。</p><p>其中，堆内存分为3个部分：</p><ul><li>Young Generation Space，新生区、新生代</li><li>Tenure Generation Space，老年区、老年代</li><li>Permanent Space，永久区、元空间</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115747.jpg"></p><hr><p><strong>JDK 1.8：</strong>  <font color='red'>将永久区变成了元空间，使用的是物理内存</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115748.jpg"></p><hr><h2 id="对象在堆中的生命周期"><a href="#对象在堆中的生命周期" class="headerlink" title="对象在堆中的生命周期"></a>对象在堆中的生命周期</h2><p>那么如何直观的了解对象在堆中的生命周期呢？</p><ul><li><p>首先，新生区是类的诞生、成长、消亡的区域。一个类在这里被创建并使用，最后被垃圾回收器收集，结束生命。</p></li><li><p>其次，所有的类都是 <font color='green'>在Eden Space被new出来的</font>。而当Eden Space的空间用完时，程序又需要创建对象，JVM的垃圾回收器则会将Eden Space中不再被其他对象所引用的对象进行销毁，也就是垃圾回收（Minor GC）。此时的GC可以认为是<font color='red'>轻量级GC</font>。</p></li><li><p>然后将Eden Space中剩余的未被回收的对象，移动到 <strong>Survivor 0 Space</strong>，以此往复，直到Survivor 0 Space也满了的时候，再对Survivor 0 Space进行垃圾回收，剩余的未被回收的对象，则再移动到 <strong>Survivor 1 Space</strong>。Survivor 1 Space也满了的话，再移动至 <strong>Tenure Generation Space</strong>。</p></li><li><p>最后，如果Tenure Generation Space也满了的话，那么这个时候就会被垃圾回收（Major GC or Full GC）并将该区的内存清理。此时的GC可以认为是<font color='red'><strong>重量级GC</strong></font>。如果Tenure Generation Space被GC垃圾回收之后，依旧处于占满状态的话，就会产生我们场景的OOM异常，即 <code>OutOfMemoryError</code>。</p></li></ul><hr><h3 id="Minor-GC的过程"><a href="#Minor-GC的过程" class="headerlink" title="Minor GC的过程"></a>Minor GC的过程</h3><p>前提：</p><ul><li>Survivor 0 Space，幸存者0区，也叫from区</li><li>Survivor 1 Space，幸存者1区，也叫to区</li><li>新生区：养老区=1：2</li><li>Eden：s0：s1=8：1：1</li><li><strong>每次从伊甸园区经过GC幸存的对象，年龄(代数)会+1</strong></li></ul><p>其中，from区和to区的区分不是固定的，是互相交换的，意思是说，在每次GC之后，两者会进行交换，谁空谁就是to区。</p><hr><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115749.png"></p><ol><li><strong>Eden Space、from复制到to，年龄+1。</strong><br>首先，当Eden Space满时，会触发第一次GC，把还活着的对象拷贝到from区。而当Eden Space再次触发GC时，会扫描Eden Space和from，对这两个区进行垃圾回收，经过此次回收后依旧存活的对象，则直接复制到to区（如果对象的年龄已经达到老年的标准，则移动至老年代区），同时把这些对象的年龄+1。</li><li><strong>清空Eden Space、from</strong><br>然后，清空Eden Space和from中的对象，此时的from是空的。</li><li><strong>from和to互换</strong><br>最后，from和to进行互换，原from成为下一次GC时的to，原to成为下一次GC时的from。部分对象会在from和to中来回进行交换复制，如果交换15次（由JVM参数MaxTenuringThreshold决定，默认15），最终依旧存活的对象就会移动至老年代。</li></ol><blockquote><p>总结一句话：<font color='red'>GC之后有交换，谁空谁是to</font></p><p>这样也是为了保证内存中没有碎片，所以Survivor 0 Space和Survivor 1 Space有一个要是空的</p></blockquote><hr><h2 id="HotSpot虚拟机的内存管理"><a href="#HotSpot虚拟机的内存管理" class="headerlink" title="HotSpot虚拟机的内存管理"></a>HotSpot虚拟机的内存管理</h2><blockquote><p>不同对象的生命周期不同，其中98%的对象都是临时对象，即这些对象的生命周期大多只存在于Eden区。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115750.png"></p><p>实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等。</p><p><strong>虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做<code>Non-Heap</code>（非堆内存），目的就是要和堆区分开。</strong></p><p>对于HotSpot虚拟机而言，很多开发者习惯将方法区称为 “永久代（Permanent Gen）” 。但严格来说两者是不同的，或者说只是使用永久代来实现方法区而已，永久代是方法区（可以理解为一个接口<code>interface</code>）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。（字符串常量池，JDK1.6在方法区，JDK1.7在堆，JDK1.8在元空间。）<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115751.png" alt="在这里插入图片描述"></p><p>如果没有明确指明，Java虚拟机的名字就叫做<code>HotSpot</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115752.png" alt="在这里插入图片描述"></p><hr><h2 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h2><blockquote><p>永久区是一个常驻内存区域，用于存放JDK自身所携带的<code>Class</code>，<code>Interface</code>的元数据（也就是上面文章提到的<code>rt.jar</code>等），也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。</p></blockquote><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115753.png" alt="在这里插入图片描述"></p><hr><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115754.png" alt="在这里插入图片描述"></p><p>在JDK1.8中，永久代已经被移除，被一个称为<strong>元空间</strong>的区域所取代。元空间的本质和永久代类似。</p><hr><p><font color='red'>元空间与永久代之间最大的区别在于： 永久带使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存。</font></p><p>因此，默认情况下，元空间的大小仅受本地内存限制。</p><hr><h2 id="堆参数调优"><a href="#堆参数调优" class="headerlink" title="堆参数调优"></a>堆参数调优</h2><blockquote><p>注意：尽量配置初始内存和最大内存一样大，<font color='red'>避免GC和应用程序争抢内存，进而导致内存忽高忽低产生停顿</font></p></blockquote><p>获取虚拟机的相关内存信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMMemory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回 Java 虚拟机试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX_MEMORY = &quot;</span> + maxMemory + <span class="string">&quot;（字节）、&quot;</span> + (maxMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 Java 虚拟机中的内存总量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line">        System.out.println(<span class="string">&quot;TOTAL_MEMORY = &quot;</span> + totalMemory + <span class="string">&quot;（字节）、&quot;</span> + (totalMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：虚拟机最大内存为物理内存的1/4，而初始分配的内存为物理内存的1/64</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115755.png"></p><hr><p>配置JVM内存参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115756.png"></p><p>运行结果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115757.png"></p><hr><h2 id="堆溢出-OutOfMemoryError"><a href="#堆溢出-OutOfMemoryError" class="headerlink" title="堆溢出 OutOfMemoryError"></a>堆溢出 OutOfMemoryError</h2><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;Atlantis&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 每执行下面语句，会在堆里创建新的对象</span></span><br><span class="line">            str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把堆内存调成10M后，再一直new对象，导致Full GC也无法处理，直至撑爆堆内存，进而导致<code>OOM</code>堆溢出错误</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115758.png"></p><p>出现<code>java.lang.OutOfMemoryError: Java heap space</code>异常，说明Java虚拟机的堆内存不够，造成堆内存溢出。原因有两点：</p><ul><li>①Java虚拟机的堆内存设置太小，可以通过参数<code>-Xms</code>和<code>-Xmx</code>来调整。</li><li>②代码中创建了大量对象，并且长时间不能被GC回收（存在被引用）。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7_方法区</title>
      <link href="2021/02/19/JVM/7-%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>2021/02/19/JVM/7-%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="7-方法区"><a href="#7-方法区" class="headerlink" title="7_方法区"></a>7_方法区</h1><p>所在位置：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115641.png"></p><p>从线程共享与否的角度来看：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115642.png"></p><hr><p>栈、堆、方法区的交互关系：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115643.png"></p><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><hr><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区<strong>在逻辑上</strong>是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做<strong>Non-Heap（非堆）</strong>【物理上】，目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于 Java 堆的内存空间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115644.png"></p><ul><li><p>黄色部分：线程共享</p></li><li><p>灰色部分：线程私有</p></li></ul><hr><p>方法区主要存放的是 <strong>Class</strong>，而堆中主要存放的是 <strong>实例化的对象</strong></p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在 jdk7 及以前，习惯上把方法区，称为<strong>永久代</strong>。jdk8开始，使用 <strong>元空间</strong> 取代了永久代。</p><ul><li>JDK 1.7 ，永久代使用的是堆的内存。</li><li>JDK 1.8后，元空间存放在堆外内存中。【使用的是本机物理内存】</li></ul><p>本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。</p><blockquote><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115645.png"></p><p>而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115646.png"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong> 。</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了，根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</p><hr><h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p>方法区的大小不必是固定的，JVM 可以根据应用的需要动态调整。</p><h4 id="JDK-7-及以前"><a href="#JDK-7-及以前" class="headerlink" title="JDK 7 及以前"></a>JDK 7 及以前</h4><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当 JVM 加载的类信息容量超过了这个值，会报异常<code>OutofMemoryError:PermGen space</code> 。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115647.png"></p><hr><h4 id="JDK-8-以后"><a href="#JDK-8-以后" class="headerlink" title="JDK 8 以后"></a>JDK 8 以后</h4><p>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和 <code>-XX:MaxMetaspaceSize</code>指定 。</p><blockquote><p>默认值依赖于平台。windows下：</p><p>-XX:MetaspaceSize是21M，</p><p>-XX:MaxMetaspaceSize的值是-1，即没有限制。</p></blockquote><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code> 。</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值 。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6_Java 虚拟机栈</title>
      <link href="2021/02/19/JVM/6-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
      <url>2021/02/19/JVM/6-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="6-Java-虚拟机栈"><a href="#6-Java-虚拟机栈" class="headerlink" title="6_Java 虚拟机栈"></a>6_Java 虚拟机栈</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>有不少 Java 开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p><p>首先栈是运行时的单位，而堆是存储的单位。</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115545.png"></p><h3 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a>Java虚拟机栈是什么</h3><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p><blockquote><p>栈帧：每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p></blockquote><p>同时，Java 栈是线程私有的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115546.png"></p><p>再比如，在 Java 中，test() 和 main() 都是方法，而在栈中，称为栈帧。在栈中，<code>main()</code>都是第一个入栈的。</p><blockquote><p>栈的顺序为：<code>main()</code>入栈 –&gt; <code>test()</code>入栈 –&gt; <code>test()</code>出栈 –&gt; <code>main()</code>出栈。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115547.png"></p><p>再来，接着观察下图，在图中一个栈中有两个栈帧，分别是<code>Stack Frame1</code>和<code>Stack Frame2</code>，对应方法1和方法2。其中<code>Stack Frame2</code>是最先被调用的方法2，所以它先入栈。然后方法2又调用了方法1，所以<code>Stack Frame1</code>处于栈顶位置。执行完毕后，依次弹出<code>Stack Frame1</code>和<code>Stack Frame2</code>，然后线程结束，栈释放。<br>所以，每执行一个方法都会产生一个栈帧，并保存到栈的顶部，顶部的栈帧就是当前所执行的方法，该方法执行完毕后会自动出栈。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115548.png"></p><p>总结如下，栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，方法A中又调用了方法B，于是产生栈帧F2也被压入栈中，方法B又调用方法C，于是产生栈帧F3也被压入栈中······执行完毕后，<strong>遵循“先进后出，后进先出”的原则</strong>，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了 。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><blockquote><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p></blockquote><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>同时，对于栈来说不存在垃圾回收问题（栈存在溢出的情况）。</p><blockquote><p>你这样想，加入有存在垃圾等着被回收的话，那岂不是栈就被堵住了。</p></blockquote><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115549.png"  /><h3 id="开发中遇到哪些异常？"><a href="#开发中遇到哪些异常？" class="headerlink" title="开发中遇到哪些异常？"></a>开发中遇到哪些异常？</h3><p>栈中可能出现的异常</p><p>Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackoverflowError </code>异常。</p><blockquote><p>此时是固定的 Java 栈没有内存可分配了，报 Error，和我们平时说的异常不一样。</p></blockquote><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <code>outofMemoryError </code>异常。</p><blockquote><p>Java 栈分配了 JVM 虚拟机的内存，但此时 Java 栈想要扩展，没有可分配的内存了，报 Error。【和堆内存溢出报的错一样】</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115550.png"></p><p>当栈深度达到 9656 的时候，就出现栈内存空间不足，就是因为不断调用方法，不断入栈创建栈帧，导致栈内存不足。</p><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;-Xss1m</span><br><span class="line">&gt;-Xss1k</span><br></pre></td></tr></table></figure><p>这里我们将栈内存设置为 2m，</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115551.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115552.png"></p><p>相比默认的 栈内存1m，此时栈深度达到了 19737 才报栈内存空间不足。</p><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>JVM直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115553.png"></p><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115554.png"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115555.png"></p><blockquote><p>关于栈帧的内部结构的具体探讨，这里没有放上来。</p></blockquote><h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul><li>举例栈溢出的情况？（<code>StackOverflowError</code>）<ul><li>通过 -Xss设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p></blockquote><p>运行时数据区，是否存在Error和GC？</p><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td></td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_本地方法栈</title>
      <link href="2021/02/19/JVM/5-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
      <url>2021/02/19/JVM/5-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5_本地方法栈"></a>5_本地方法栈</h1><p>Java 栈是属于线程私有，它的声明周期与线程同步，Java 方法被在调用时，入Java 栈成为一个一个栈帧，即 Java 虚拟机栈用于管理 Java 方法的调用，类似，<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个<code>stackoverflowError </code>异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个<code>outofMemoryError</code>异常。</li></ul><p>本地方法是使用 C 语言实现的。</p><p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115447.png"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><blockquote><p>都不归 JVM 管了，调用的是底层的操作系统资源 。</p></blockquote><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_ 本地方法接口</title>
      <link href="2021/02/19/JVM/4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
      <url>2021/02/19/JVM/4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="4-本地方法接口"><a href="#4-本地方法接口" class="headerlink" title="4_ 本地方法接口"></a>4_ 本地方法接口</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>简单地讲，一个 Native Method 是一个 Java 调用非 Java 代码的接囗，其作用就是融合不同的编程语言为 Java 所用，它的初衷是用来融合 C/C++ 程序的，Java 诞生的时候是 C/C++ 流行时期，要想立足，就得调用 C/C++ 程序。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115353.png"></p><p>接下来，我们通过下图的多线程部分源码来理解什么是 native 方法。首先我们观察 start() 的源码，发现它其实并没有做什么复杂的操作，只是单纯的调用了 start0() 这个方法，然后我们去观察 start0() 的源码，发现它只是一个使用了 native 关键字修饰的一个方法<code>（private native void start0();）</code>，但只有声明却没有具体的实现！。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115354.png"></p><p>为什么？我们都知道 Thread 是<code>Class</code>关键字修饰的类（<code>class Thread implements Runnable</code>），而不是接口。一般来说，类中的方法都要有定义和实现，接口里面才有方法的定义声明。这就是 native 方法的独特之处，说白了，被<code>native</code>关键字修饰的方法，基本上和我们，甚至和 Java 都没啥关系了，因为它要去调用底层操作系统或者第三方语言的库函数，所以我们不需要去考虑它具体是如何实现的。</p><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><h3 id="与-Java-环境的交互"><a href="#与-Java-环境的交互" class="headerlink" title="与  Java 环境的交互"></a>与  Java 环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s  Java"></a>Sun’s  Java</h3><p>Sun的解释器是用 C 实现的，这使得它能像一些普通的C一样与外部交互。jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法 setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在 Windows 95 的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_程序计数器</title>
      <link href="2021/02/19/JVM/3-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>2021/02/19/JVM/3-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3_程序计数器"></a>3_程序计数器</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>JVM 中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 <strong>PC计数器</strong>（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM 中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115246.png"></p><p>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎<code>Execution Engine</code>读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p><p>它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>PC寄存器一般用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出<code>（OutOfMemory，OOM）</code>错误。</p><blockquote><p>如果执行的是一个<code>native</code>方法，那这个计数器是空的。</p></blockquote><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><blockquote><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p></blockquote><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115247.png"  /><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-11-01 14:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115248.png"></p><p>通过 PC 寄存器，我们就可以知道当前程序执行到哪一步了</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115249.png"></p><hr><h3 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h3><blockquote><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p></blockquote><p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115250.png"></p><hr><h3 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h3><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115251.png"  /><hr><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><p>CPU 时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115252.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_运行时数据区概述及线程</title>
      <link href="2021/02/19/JVM/2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/02/19/JVM/2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115144.png"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品 。</p><h2 id="JVM内存布局"><a href="#JVM内存布局" class="headerlink" title="JVM内存布局"></a>JVM内存布局</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM 内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。</p><p>不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p><p>运行时数据区的完整图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115145.png"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁；另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><hr><p>左边淡黄色部分为多个线程共享：<strong>堆、方法区（具体实现：永久代 / 元空间）</strong></p><p>右边灰色部分为线程私有：<strong>Java 栈、本地方法栈、程序计数器</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115146.png"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。</p><p>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用Java线程中的 run（）方法。</p><h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。| 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_JVM体系结构与类加载系统</title>
      <link href="2021/02/19/JVM/1-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/02/19/JVM/1-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>👉来源Bilibili尚硅谷周阳老师JVM教程：<a href="https://www.bilibili.com/video/BV1vE411D7KE?from=search&seid=4040031347313595254">JVM_周阳老师教程</a></p></blockquote><h1 id="JVM体系结构与类加载系统"><a href="#JVM体系结构与类加载系统" class="headerlink" title="JVM体系结构与类加载系统"></a>JVM体系结构与类加载系统</h1><h2 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h2><p> JVM 的位置，JVM 是运行在操作系统之上的，它与硬件没有直接交互。</p><blockquote><p>补充：</p><ul><li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115001.png"></p><p>JVM 的整个体系结构图：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115002.png"  /><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="类装载器-ClassLoader"><a href="#类装载器-ClassLoader" class="headerlink" title="类装载器 ClassLoader"></a>类装载器 ClassLoader</h3><p>完整细节图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115003.png"></p><p>类装载器 ClassLoader 的作用：负责加载 class 文件的，将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。ClassLoader 只负责文件的加载，至于它是否可运行，则由 Execution Engine 决定。</p><blockquote><p>扩展一下：</p><ul><li><p>方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。</p></li><li><p>字节码文件存在于本地硬盘上。</p></li><li><p>class 与 Class：小写的 class，是指编译 Java 代码后所生成的以 .class 为后缀名的<strong>字节码文件</strong>。而大写的 Class，是 JDK 提供的 java.lang.Class，可以理解为封装<strong>类的模板</strong>。【模板实例化之后就得到n个相同的对象】</p></li><li><p>在 .class 文件-&gt; JVM &gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</p></li><li><p>JVM并不是通过检查文件后缀是不是 .class 来判断是否需要加载的，而是通过<strong>文件开头的特定文件标志</strong></p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115004.png"></p></blockquote><p>Car.class 字节码文件被 ClassLoader 类装载器加载并初始化，在方法区中生成了一个 Car Class 的类模板，而我们平时所用到的实例化，就是在这个类模板的基础上，形成了一个个实例，即car1，car2。反过来讲，我们可以对某个具体的实例进行 getClass() 操作，就可以得到该实例的类模板，即 Car Class。再接着，我们对这个类模板进行 getClassLoader() 操作，就可以得到这个类模板是由哪个类装载器进行加载的。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115005.png"  /><h3 id="类加载详细过程"><a href="#类加载详细过程" class="headerlink" title="类加载详细过程"></a>类加载详细过程</h3><blockquote><p>周阳老师这部分没有具体讲解，下面作补充，来源Bilibili尚硅谷宋红康老师JVM教程：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">硅谷2020最新版宋红康JVM教程</a></p></blockquote><p>完整的流程图如下所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115006.png"></p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</p><blockquote><h5 id="加载-class-文件的方式"><a href="#加载-class-文件的方式" class="headerlink" title="加载  .class 文件的方式"></a>加载  .class 文件的方式</h5><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul></blockquote><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><h5 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h5><p>目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><blockquote><p>工具：Binary Viewer查看</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115007.png"></p><p>如果出现不合法的字节码文件，那么将会验证不通过</p><p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115008.png"></p><p>安装完成后，我们编译完一个class文件后，点击 view 即可显示我们安装的插件来查看字节码方法了</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115009.png"></p><h5 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h5><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-10-31 20:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;  <span class="comment">//注意这里只是静态的在这个阶段设置默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的变量 a 在准备阶段会赋初始值，但不是 1，而是 0。</p><p>这里不包含用 final 修饰的static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</p><h5 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h5><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>初始化阶段就是执行类构造器方法<clinit>( ) 的过程。</p><ol><li>此方法不需定义，是 javac 编译器自动收集类中的所有 类变量的赋值动作 和 静态代码块中的语句 合并而来。</li></ol><blockquote><p>也就是说，当我们代码中包含 static 变量的时候，就会有 <clinit>( ) 方法。</p></blockquote><ol start="2"><li><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p></li><li><p><clinit> ( ) 不同于类的构造器【构造器是虚拟机视角下的<init>( )】，若该类具有父类，JVM 会保证子类的<clinit> ( ) 执行前，父类的<clinit> ( ) 已经执行完毕。</p></li></ol><blockquote><p>类构造器：任何一个类在声明后，都有生成一个构造器，默认是空参构造器 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         A = <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = A;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Son.b);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回。</p></blockquote><ol start="4"><li>虚拟机必须保证一个类的<clinit>( )方法在多线程下被同步加锁。</li></ol><blockquote><p>Class 对象 是被加载到元空间，在 jdk 8之后，元空间是使用的本地物理内存，使用同步加锁这样可以避免被多次加载。</p></blockquote><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p><strong>（1）虚拟机自带的加载器</strong></p><ul><li>启动类加载器（Bootstrap），也叫根加载器，加载<code>%JAVAHOME%/jre/lib/rt.jar</code>。</li><li>扩展类加载器（Extension），加载<code>%JAVAHOME%/jre/lib/ext/*.jar</code>，例如<code>javax.swing</code>包。</li><li>应用程序类加载器（AppClassLoader），也叫系统类加载器，加载<code>%CLASSPATH%</code>的所有类。</li></ul><p><strong>（2）用户自定义的加载器</strong> ：</p><ul><li>用户可以自定义类的加载方式，但必须是<code>Java.lang.ClassLoader</code>的子类。</li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115010.png" style="zoom:67%;" /><p>接下来自定义的 MyObject，首先通过 getClassLoader() 获取到的是 AppClassLoader，然后 getParent() 得到ExtClassLoader，再 getParent() 竟然是null？可能大家会有疑惑，不应该是 Bootstrap 加载器么？这是因为，BootstrapClassLoader 是使用C++语言编写的，Java 在加载的时候就成了 null。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115011.png"></p><p>我们再来看 Java 自带的 Object，通过 getClassLoader() 获取到的加载器直接就是 BootstrapClassLoader，如果要想getParent() 的话，因为是 null 值，所以就会报 <code>java.lang.NullPointerException</code>空指针异常。</p><blockquote><p>sun.misc.Launcher 它是一个 java 虚拟机的入口应用</p></blockquote><hr><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219115012.png"></p><blockquote><p>采用双亲委派的一个好处是，比如加载位于<code>rt.jar</code>包中的类<code>java.lang.Object</code>，不管是哪个加载器加载这个类，最终都是委派给顶层的启动类加载器进行加载，确保哪怕使用了不同的类加载器，最终得到的都是同样一个<code>Object</code>对象。</p></blockquote><hr><p>Tip：<code>rt.jar</code>是什么？为什么可以在idea这些开发工具中可以直接去使用String、ArrayList、甚至一些JDK提供的类和方法？观察下面动图就可以知道，原来这些都在<code>rt.jar</code>中定义好了，且直接被启动类加载器进行加载了。</p><hr><h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar包中java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是rt.jar包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><h4 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h4><p>双亲机制可以：</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务/分布式</title>
      <link href="2021/02/19/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>2021/02/19/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务-分布式"><a href="#微服务-分布式" class="headerlink" title="微服务/分布式"></a>微服务/分布式</h2><p>今天分享一下微服务/分布式常见的面试问题，不过这些问题都是针对应届生的，对于比较senior的求职者应该会深入很多。题目都是来自2020大厂真实面经！</p><p>没有了解过分布式/微服务的老哥们也不要担心看不懂这篇文章，内容我都是大白话讲出来的，非常易懂，带你速览分布式/微服务。</p><p>概览（看看自己能回答几题）：</p><ol><li>为什么要网关？</li><li>你知道有哪些常见的网关系统？</li><li>限流的算法有哪些？</li><li>为什么要分布式 id ？</li><li>分布式 id 生成策略有哪些？</li><li>了解RPC吗？</li><li>有哪些常见的 RPC 框架？</li><li>如果让你自己设计 RPC 框架你会如何设计？</li><li>Dubbo 了解吗？</li><li>Dubbo 提供了哪些负载均衡策略？</li><li>谈谈你对微服务领域的了解和认识！</li></ol><h3 id="为什么要网关？"><a href="#为什么要网关？" class="headerlink" title="为什么要网关？"></a>为什么要网关？</h3><p>微服务下一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。</p><p>综上：<strong>一般情况下，网关一般都会提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控这些功能。</strong></p><p>上面介绍了这么多功能实际上网关主要做了一件事情：<strong>请求过滤</strong> 。权限校验、流量控制这些都可以通过过滤器实现，请求转也是通过过滤器实现的。</p><h3 id="你知道有哪些常见的网关系统？"><a href="#你知道有哪些常见的网关系统？" class="headerlink" title="你知道有哪些常见的网关系统？"></a>你知道有哪些常见的网关系统？</h3><p>我所了解的目前经常用到的开源 API 网关系统有：</p><ol><li>Kong</li><li>Netflix zuul</li></ol><p>下图来源：<a href="https://www.stackshare.io/stackups/kong-vs-zuul">https://www.stackshare.io/stackups/kong-vs-zuul</a> 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/kong-vs-zuul.jpg" alt="Kong vs Netflix zuul">Kong vs Netflix zuul</p><p>可以看出不论是社区活跃度还是 Star数， Kong 都是略胜一筹。总的来说，Kong 相比于 Zuul 更加强大并且简单易用。Kong 基于 Openresty ，Zuul 基于 Java。</p><blockquote><p>OpenResty（也称为 ngx_openresty）是一个全功能的 Web 应用服务器。它打包了标准的 Nginx 核心，很多的常用的第三方模块，以及它们的大多数依赖项。</p><p>通过揉和众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用。——OpenResty</p></blockquote><p>另外， Kong 还提供了插件机制来扩展其功能。</p><p>比如、在服务上启用 Zipkin 插件</p><ul><li>ounter(line</li><li>ounter(line</li><li>ounter(line</li><li>ounter(line</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST http:&#x2F;&#x2F;kong:8001&#x2F;services&#x2F;&#123;service&#125;&#x2F;plugins \ --data &quot;name&#x3D;zipkin&quot; \ --data &quot;config.http_endpoint&#x3D;http:&#x2F;&#x2F;your.zipkin.collector:9411&#x2F;api&#x2F;v2&#x2F;spans&quot; \ --data &quot;config.sample_ratio&#x3D;0.001&quot;</span><br></pre></td></tr></table></figure><p>ps:这里没有太深入去探讨，需要深入了解的话可以自行查阅相关资料。</p><h3 id="限流的算法有哪些？"><a href="#限流的算法有哪些？" class="headerlink" title="限流的算法有哪些？"></a>限流的算法有哪些？</h3><p>简单介绍 4 种非常好理解并且容易实现的限流算法！</p><p>下图的图片不是 Guide 哥自己画的哦！图片来源于 InfoQ 的一篇文章<a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673">《分布式服务限流实战，已经为你排好坑了》</a>。</p><h4 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h4><p>规定我们单位时间处理的请求数量。比如我们规定我们的一个接口一分钟只能访问10次的话。使用固定窗口计数器算法的话可以这样实现：给定一个变量counter来记录处理的请求数量，当1分钟之内处理一个请求之后counter+1，1分钟之内的如果counter=100的话，后续的请求就会被全部拒绝。等到 1分钟结束后，将counter回归成0，重新开始计数（ps：只要过了一个周期就讲counter回归成0）。</p><p>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。比如我们限制一个接口一分钟只能访问10次的话，前半分钟一个请求没有接收，后半分钟接收了10个请求。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png" alt="固定窗口计数器算法">固定窗口计数器算法</p><h4 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h4><p>算的上是固定窗口计数器算法的升级版。滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：它把时间以一定比例分片。例如我们的借口限流每分钟处理60个请求，我们可以把 1 分钟分为60个窗口。每隔1秒移动一次，每个窗口一秒只能处理 不大于 60(请求数)/60（窗口数） 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p><p>很显然：当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png" alt="滑动窗口计数器算法">滑动窗口计数器算法</p><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png" alt="漏桶算法">漏桶算法</p><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png" alt="令牌桶算法">令牌桶算法</p><h3 id="为什么要分布式-id-？"><a href="#为什么要分布式-id-？" class="headerlink" title="为什么要分布式 id ？"></a>为什么要分布式 id ？</h3><blockquote><p>这部分内容来自：**<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93.md">分布式id生成方案总结</a>**</p></blockquote><p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。</p><h3 id="分布式-id-生成策略有哪些？"><a href="#分布式-id-生成策略有哪些？" class="headerlink" title="分布式 id 生成策略有哪些？"></a>分布式 id 生成策略有哪些？</h3><p>详细解读请查看：**<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93.md">分布式id生成方案总结</a>**</p><p><img src= "/img/loading.gif" data-lazy-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" alt="常用分布式id方案">常用分布式id方案</p><h3 id="了解RPC吗？"><a href="#了解RPC吗？" class="headerlink" title="了解RPC吗？"></a>了解RPC吗？</h3><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p><p><strong>RPC原理是什么？</strong></p><p>我这里这是简单的提一下。详细内容可以查看下面这篇文章：</p><p><a href="http://www.importnew.com/22003.html">http://www.importnew.com/22003.html</a></p><p><img src= "/img/loading.gif" data-lazy-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg" alt="RPC原理图">RPC原理图</p><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>下面再贴一个网上的时序图：</p><p><img src= "/img/loading.gif" data-lazy-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/32527396.jpg" alt="RPC原理时序图">RPC原理时序图</p><h3 id="有哪些常见的-RPC-框架？"><a href="#有哪些常见的-RPC-框架？" class="headerlink" title="有哪些常见的 RPC 框架？"></a>有哪些常见的 RPC 框架？</h3><ul><li><strong>RMI（JDK自带）：</strong> JDK自带的RPC。详细内容可以参考：<a href="https://blog.csdn.net/lmy86263/article/details/72594760">从懵逼到恍然大悟之Java中RMI的使用</a></li><li><strong>Dubbo:</strong> Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。详细内容可以参考：<a href="https://blog.csdn.net/qq_34337272/article/details/79862899">高性能优秀的服务框架-dubbo介绍</a></li><li><strong>gRPC</strong>： Google 公布的开源软件，基 HTTP 2.0 协议，并支持常见的众多编程语言。</li><li><strong>Thrift：</strong> Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。详细内容可以参考： <a href="https://www.cnblogs.com/zeze/p/8628585.html">【Java】分布式RPC通信框架Apache Thrift 使用总结</a></li><li><strong>Hessian：</strong> Hessian是一个轻量级的remotingonhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。详细内容可以参考： <a href="https://blog.csdn.net/sunwei_pyw/article/details/74002351">Hessian的使用以及理解</a></li></ul><h3 id="如果让你自己设计-RPC-框架你会如何设计？"><a href="#如果让你自己设计-RPC-框架你会如何设计？" class="headerlink" title="如果让你自己设计 RPC 框架你会如何设计？"></a>如果让你自己设计 RPC 框架你会如何设计？</h3><p>一个典型的使用 RPC 的场景如下，一般情况下 RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这个的 RPC 框架才算真正合格。</p><p><img src= "/img/loading.gif" data-lazy-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84rpc%E6%A1%86%E6%9E%B6.jpg" alt="一个完整的RPC框架使用示意图">一个完整的RPC框架使用示意图</p><p>简单说一下思路：</p><ol><li>注册中心首先是要有的，推荐使用  Zookeeper。注册中心主要用来保存相关的信息比如远程方法的地址。</li><li>既然要要互相调用方法就要发请求，推荐nio 的 netty框架。</li><li>发请求发送什么数据呢？我们就要考虑序列化协议了。</li><li>另外，动态代理也是需要的。因为 RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，使用动态代理屏蔽远程接口调用的细节比如网络传输。推荐一篇我觉得非常不错的动态代理的文章：<a href="https://juejin.im/post/5a99048a6fb9a028d5668e62">《10分钟看懂动态代理设计模式》</a></li><li>负载均衡也是需要的。为啥？举个例子我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。。</li></ol><h3 id="了解Dubbo吗-？"><a href="#了解Dubbo吗-？" class="headerlink" title="了解Dubbo吗 ？"></a>了解Dubbo吗 ？</h3><p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p><p>Dubbo 目前已经有接近 31.2k 的 Star ，Dubbo的Github 地址：<a href="https://github.com/apache/incubator-dubbo">https://github.com/apache/incubator-dubbo</a> 。</p><p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得国内越来越多的公司开始使用以及接受分布式架构。</p><h3 id="Dubbo-提供了哪些负载均衡策略？"><a href="#Dubbo-提供了哪些负载均衡策略？" class="headerlink" title="Dubbo 提供了哪些负载均衡策略？"></a>Dubbo 提供了哪些负载均衡策略？</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 <code>random</code> 随机调用。可以自行扩展负载均衡策略，参见：<a href="https://dubbo.gitbooks.io/dubbo-dev-book/content/impls/load-balance.html">负载均衡扩展</a>。</p><p>备注:下面的图片来自于：尚硅谷2018Dubbo 视频。</p><h4 id="Random-LoadBalance-默认，基于权重的随机负载均衡机制"><a href="#Random-LoadBalance-默认，基于权重的随机负载均衡机制" class="headerlink" title="Random LoadBalance(默认，基于权重的随机负载均衡机制)"></a>Random LoadBalance(默认，基于权重的随机负载均衡机制)</h4><ul><li><strong>随机，按权重设置随机概率。</strong></li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/77722327.jpg" alt="基于权重的随机负载均衡机制">基于权重的随机负载均衡机制</p><h4 id="RoundRobin-LoadBalance-不推荐，基于权重的轮询负载均衡机制"><a href="#RoundRobin-LoadBalance-不推荐，基于权重的轮询负载均衡机制" class="headerlink" title="RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)"></a>RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制)</h4><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-7/97933247.jpg" alt="基于权重的轮询负载均衡机制">基于权重的轮询负载均衡机制</p><h4 id="LeastActive-LoadBalance-最少活跃调用负载均衡机制"><a href="#LeastActive-LoadBalance-最少活跃调用负载均衡机制" class="headerlink" title="LeastActive LoadBalance(最少活跃调用负载均衡机制)"></a>LeastActive LoadBalance(最少活跃调用负载均衡机制)</h4><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul><h4 id="ConsistentHash-LoadBalance-一致性-Hash负载均衡机制"><a href="#ConsistentHash-LoadBalance-一致性-Hash负载均衡机制" class="headerlink" title="ConsistentHash LoadBalance(一致性 Hash负载均衡机制)"></a>ConsistentHash LoadBalance(一致性 Hash负载均衡机制)</h4><ul><li><strong>一致性 Hash，相同参数的请求总是发到同一提供者。(如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。)</strong></li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li></ul><h3 id="谈谈你对微服务领域的了解和认识"><a href="#谈谈你对微服务领域的了解和认识" class="headerlink" title="谈谈你对微服务领域的了解和认识"></a>谈谈你对微服务领域的了解和认识</h3><p>现在大公司都在用并且未来的趋势都是 Spring Cloud，而阿里开源的 Spring Cloud Alibaba 也是 Spring Cloud 规范的实现 。</p><p>我们通常把 Spring Cloud 理解为一系列开源组件的集合，但是 Spring Cloud并不是等同于 Spring Cloud Netflix 的 Ribbon（负载均衡）、Feign（远程调用）、Eureka（服务注册与发现，已经停止更新）、Hystrix（熔断）、Zuul （网关）； 这一套组件，而是抽象了一套通用的开发模式。它的目的是通过抽象出这套通用的模式，让开发者更快更好地开发业务。但是这套开发模式运行时的实际载体，还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。</p><blockquote><p>更多关于 Spring Cloud Netflix 的内容参见： <strong><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/system-design/micro-service/spring-cloud.md">大白话入门 Spring Cloud</a></strong></p></blockquote><p>Spring Cloud Alibaba 是官方认证的新一套 Spring Cloud 规范的实现,Spring Cloud Alibaba 是一套国产开源产品集合，后这对于国内的开发者是非常棒的一件事。阿里的这一举动势必会推动国内微服务技术的发展，因为在没有 Spring Cloud Alibaba 之前，我们的第一选择是 Spring Cloud Netflix，但是它们的文档都是英文的，出问题后排查也比较困难， 在国内并不是有特别多的人精通。Spring Cloud Alibaba 由阿里开源组件和阿里云产品组件两部分组成，其致力于提供微服务一站式解决方案，方便开发者通过 Spring Cloud 编程模型轻松开发微服务应用。</p><p>Spring Cloud Alibaba也是很值得学习的，其组成包括：</p><ol><li>Sentinel：轻量级的流量控制、熔断降级 Java 库</li><li>2.dubbo：Apache Dubbo 是一个基于 Java 的高性能开源 RPC 框架。</li><li>nacos：Nacos 致力于帮助您发现、配置和管理微服务。</li><li>seata：Seata 是一种易于使用，高性能，基于 Java 的开源分布式事务解决方案。</li><li>RocketMQ:阿里巴巴开源的一款高性能、高吞吐量的分布式消息中间件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目介绍</title>
      <link href="2021/02/18/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
      <url>2021/02/18/%E9%9D%A2%E8%AF%95/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><blockquote><p>⾯试官： 你刚刚说参考⽹上的教程做了⼀个电商系统？你能画画这个电商系统的架构图吗？</p></blockquote><p>我： 内⼼ os: “这可难不倒我！早知道写在简历上的项⽬要重视了，提前都把这个系统的架构图<br>画了好多遍了呢！”</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210218212454.png"></p><blockquote><p>⾯试官： 简单介绍⼀下你做的这个系统吧！</p></blockquote><p>我： 我⼀本正经的对着我刚刚画的商城架构图开始了满嘴造⽕箭的讲起来：</p><blockquote><p>本系统主要分为展示层、服务层和持久层这三层。<code>表现层</code>顾名思义主要就是为了⽤来展示，⽐如我们的后台管理系统的⻚⾯、商城⾸⻚的⻚⾯、搜索系统的⻚⾯等等，这⼀层都只是作为展示，并没有提供任何服务。</p><p><code>展示层和服务层</code>⼀般是部署在不同的机器上来提⾼并发量和扩展性，那么展示层和服务层怎样才能交互呢？在本系统中我们使⽤ SpringCloud 来进⾏服务治理。服务提供者将服务注册进Eureka注册中心，服务消费者去注册中心获取服务的地址来消费服务，如果需要引用某个服务，我们只需要在配置⽂件中配置相关信息就可以在代码中直接使⽤了，就像调⽤本地⽅法⼀样。假如说某个服务的使⽤量增加时，我们只⽤为这单个服务增加服务器，⽽不需要为整个系统添加服务。</p><p>另外，本系统的数据库使⽤的是常⽤的<code> MySQL</code>。另外，本系统还⽤到 redis 内存数据库来作为缓存来提⾼系统的反应速度。假如⽤户第⼀次访问数据库中的某些数据，这个过程会⽐᫾慢，因为是从硬盘上读取的。将该⽤户访问的数据存在数缓存中，这样下⼀次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p>系统还⽤到了 <code>Elasticsearch </code>来提供搜索功能。使⽤ Elasticsearch 我们可以⾮常⽅便的为我们的商城系统添加必备的搜索功能，并且使⽤ Elasticsearch 还能提供其它⾮常实⽤的功能，并且很容易扩展。</p></blockquote><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><blockquote><p>⾯试官： 我看你的系统⾥⾯还⽤到了消息队列，能说说为什么要⽤它吗？</p></blockquote><p>我：</p><p>使⽤消息队列主要是为了：</p><ol><li><p>减少响应所需时间和削峰。</p></li><li><p>降低系统耦合性（解耦/提升系统可扩展性）。</p></li></ol><blockquote><p>⾯试官： 你这说的太简单了！能不能稍微详细⼀点，最好能画图给我解释⼀下。</p></blockquote><p>我： 内⼼ os:”都 2019 年了，⼤部分⾯试者都能对消息队列的为系统带来的这两个好处倒背如流了，如果你想⾛的更远就要别别⼈懂的更深⼀点！”</p><blockquote><p>当我们不使⽤消息队列的时候，所有的⽤户的请求会直接落到服务器，然后通过数据库或者缓存响应。假如在⾼并发的场景下，如果没有缓存或者数据库承受不了这么⼤的压⼒的话，就会造成响应速度缓慢，甚⾄造成数据库宕机。但是，在使⽤消息队列之后，⽤户的请求数据发送给了消息队列之后就可以⽴即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写⼊数据库，不过要确保消息不被重复消费还要考虑到消息丢失问题。由于消息队列服务器处理速度快于数据库，因此响应速度得到⼤幅改善。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219100755.png" alt="image-20210219094917078"></p><p>通过以上分析我们可以得出消息队列具有很好的<code>削峰作⽤的功能</code>——即通过异步处理，将短时间⾼并发产⽣的事务消息存储在消息队列中，从⽽削平⾼峰期的并发事务。 举例：在电⼦商务⼀些秒杀、促销活动中，合理使⽤消息队列可以有效抵御促销活动刚开始⼤量订单涌⼊对系统的冲击。如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219100756.png" alt="image-20210219095146989"></p><p>使⽤消息队列还可以<code>降低系统耦合性</code>。我们知道如果模块之间不存在直接调⽤，那么新增模块或者修改模块就对其他模块影响较⼩，这样系统的可扩展性⽆疑更好⼀些。还是直接上图吧：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219100757.png" alt="image-20210219095249185"></p><p>⽣产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进⾏消费即可⽽不需要和其他系统有耦合， 这显然也提⾼了系统的扩展性。</p></blockquote><blockquote><p>⾯试官： 你觉得它有什么缺点吗？或者说怎么考虑⽤不⽤消息队列？</p></blockquote><p>我： 内⼼ os: “⾯试官真鸡贼！这不是勾引我上钩么？还好我准备充分。”</p><blockquote><p>我觉得可以从下⾯⼏个⽅⾯来说：</p><ol><li><p><strong>系统可⽤性降低：</strong> 系统可⽤性在某种程度上降低，为什么这样说呢？在加⼊ MQ 之前，你不⽤考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引⼊ MQ 之后你就需要去考虑了！</p></li><li><p><strong>系统复杂性提⾼：</strong> 加⼊ MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</p></li><li><p><strong>⼀致性问题：</strong> 我上⾯讲了消息队列可以实现异步，消息队列带来的异步确实可以提⾼系统响应速度。但是，万⼀消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不⼀致的情况了!</p></li></ol></blockquote><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote><p>⾯试官：做项⽬的过程中遇到了什么问题吗？解决了吗？如果解决的话是如何解决的呢？</p></blockquote><p>我 ： 内⼼ os: “做的过程中好像也没有遇到什么问题啊！怎么办？怎么办？突然想到可以说我在使⽤ Redis 过程中遇到的问题，毕竟我对 Redis 还算熟悉嘛，把⾯试官往这个⽅向吸引，准没错。”</p><blockquote><p>我在使⽤ Redis 对常⽤数据进⾏缓存的过程中出现了缓存穿透问题。然后，我通过⾕歌搜索相关的解决⽅案来解决的。</p></blockquote><blockquote><p>⾯试官： 你还知道缓存穿透啊？不错啊！来说说什么是缓存穿透以及你最后的解决办法。</p></blockquote><p>我： 我先来谈谈什么是缓存穿透吧！</p><blockquote><p>缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请求落到数据库。</p><p>总结⼀下就是：</p><ol><li><p>缓存层不命中。</p></li><li><p>存储层不命中，不将空结果写回缓存。</p></li><li><p>返回空结果给客户端。</p></li></ol><p>⼀般 MySQL 默认的最⼤连接数在 150 左右，这个可以通过 show variables like’%max_connections%’; 命令来查看。最⼤连接数⼀个还只是⼀个指标，cpu，内存，磁盘，⽹络等物理条件都是其运⾏指标，这些指标都会限制其并发能⼒！所以，⼀般 3000 的并发请求就能打死⼤部分数据库了。</p></blockquote><blockquote><p>⾯试官： ⼩伙⼦不错啊！还准备问你：“为什么 3000 的并发能把⽀持最⼤连接数 4000 数据库压死？”想不到你⾃⼰就提前回答了！不错！</p></blockquote><p>我： 别夸了！别夸了！我再来说说我知道的⼀些解决办法以及我最后采⽤的⽅案吧！您帮忙看看有没有问题。</p><blockquote><p>最基本的就是⾸先做好<code>参数校验</code>，⼀些不合法的参数请求直接抛出异常信息返回给客户端。⽐如查询的数据库 id 不能⼩于 0、传⼊的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p>参数校验通过的情况还是会出现缓存穿透，我们还可以通过以下⼏个⽅案来解决这个问题：</p><p><strong>1）缓存⽆效 key :</strong> 如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设置过期时间，具体命令如下： SET key value EX 10086 。这种⽅式可以解决请求的 key 变化不频繁的情况，如何⿊客恶意攻击，每次构建的不同的请求 key，会导致 redis 中缓存⼤量⽆效的 key 。很明显，这种⽅案并不能从根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key 的过期时间设置短⼀点⽐如 1 分钟。另外，这⾥多说⼀嘴，⼀般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值</p><p><strong>2）布隆过滤器：</strong> 布隆过滤器是⼀个⾮常神奇的数据结构，通过它我们可以⾮常⽅便地判断⼀个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“⼈”。</p></blockquote><blockquote><p>⾯试官： 不错不错！你还知道布隆过滤器啊！来给我谈⼀谈。</p></blockquote><p>我： 内⼼ os：“如果你准备过海量数据处理的⾯试题，你⼀定对：“如何确定⼀个数字是否在于包含⼤量数字的数字集中（数字集很⼤，5 亿以上！）?”这个题⽬很了解了！解决这道题⽬就要⽤到布隆过滤器。”</p><blockquote><p>布隆过滤器在针对海量数据去重或者验证数据合法性的时候⾮常有⽤。布隆过滤器的本质实际上是 <strong>“</strong>位**(bit)<strong>数组</strong>”<strong>，也就是说每⼀个存⼊布隆过滤器的数据都只占⼀位。相⽐于我们平时常⽤的的 **List</strong>、<strong>Map</strong> 、<strong>Set</strong> 等数据结构，它占⽤空间更少并且效率更⾼，但是缺点是其返回的结果是概率性的，⽽不是⾮常准确的。</p><p>当⼀个元素<code>加⼊布隆过滤器</code>中的时候，会进⾏如下操作：</p><ol><li><p>使⽤布隆过滤器中的哈希函数对元素值进⾏计算，得到哈希值（有⼏个哈希函数得到⼏个哈希值）。</p></li><li><p>根据得到的哈希值，在位数组中把对应下标的值置为 1。</p></li></ol><p>当我们需要<code>判断⼀个元素是否存在于布隆过滤器</code>的时候，会进⾏如下操作：</p><ol><li><p>对给定元素再次进⾏相同的哈希计算；</p></li><li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在⼀个值不为 1，说明该元素不在布隆过滤器中。</p></li></ol><p>举个简单的例⼦：                        </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219100758.png" alt="image-20210219100431922"></p><p>如图所示，当字符串存储要加⼊到布隆过滤器中时，该字符串⾸先由多个哈希函数⽣成不同的哈希值，然后在对应的位数组的下表的元素设置为 1（当位数组初始化时 ，所有位置均为0）。当第⼆次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重⾮常⽅便）。</p><p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进⾏相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在⼀个值不为 1，说明该元素不在布隆过滤器中。不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组⼤⼩或者调整我们的哈希函数。</p><p>综上，我们可以得出：布隆过滤器说某个元素存在，⼩概率会误判。布隆过滤器说某个元素不在，那么这个元素⼀定不在。</p></blockquote><blockquote><p>⾯试官： 看来你对布隆过滤器了解的还挺不错的嘛！那你快说说你最后是怎么利⽤它来解决缓存穿透的。</p></blockquote><p>我： 知道了布隆过滤器的原理就之后就很容易做了。我是利⽤ Redis + 布隆过滤器来做的。我把所有可能存在的请求的值都存放在布隆过滤器中，当⽤户请求过来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会⾛下⾯的流程。总结⼀下就是下⾯这张图(这张图⽚不是我画的，为了省事直接在⽹上找的)：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210219100730.png" alt="image-20210219100656700"></p><blockquote><p>⾯试官： 好了好了。项⽬就暂时问到这⾥吧！下⾯有⼀些⽐᫾基础的问题我简单地问⼀下你。内⼼ os： 难不成这家伙满⼝⾼并发，连最基础的东⻄都不会吧！</p></blockquote><p>我： 好的好的！没问题！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12_Linux安装MySQL</title>
      <link href="2021/02/17/Linux/12-Linux%E5%AE%89%E8%A3%85MySQL/"/>
      <url>2021/02/17/Linux/12-Linux%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="12-Linux安装MySQL"><a href="#12-Linux安装MySQL" class="headerlink" title="12_Linux安装MySQL"></a>12_Linux安装MySQL</h1><blockquote><p>YUM（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。它基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，无须繁琐地一次次下载、安装</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">步骤1: 检测系统是否自带安装mysql</span><br><span class="line">[root@localhost &#x2F;]# yum list installed | grep mysql </span><br><span class="line"></span><br><span class="line">步骤2: 删除系统自带的mysql及其依赖（防止后面安装发生冲突）</span><br><span class="line">[root@localhost &#x2F;]# yum -y remove mysql-libs.x86_64 </span><br><span class="line"></span><br><span class="line">步骤3: 给CentOS添加rpm源，并且选择较新的源,RPM软件包管理器缩写</span><br><span class="line">[root@localhost &#x2F;]# wget --no-check-certificate dev.mysql.com&#x2F;get&#x2F;mysql-community-release-el6-5.noarch.rpm </span><br><span class="line"></span><br><span class="line">步骤4: 安装第一步下载的rpm文件</span><br><span class="line">[root@localhost &#x2F;]# yum install mysql-community-release-el6-5.noarch.rpm 此处需要输入&quot;y&quot; </span><br><span class="line">[root@localhost &#x2F;]# yum repolist enabled | grep mysql &#x2F;&#x2F;列出你所有的yum repo文件 </span><br><span class="line"></span><br><span class="line">步骤5: 使用yum安装mysql</span><br><span class="line">[root@localhost &#x2F;]# yum install mysql-community-server 此处输入3次“y” 安装完毕 </span><br><span class="line"></span><br><span class="line">步骤6: 启动mysql服务</span><br><span class="line">[root@localhost &#x2F;]# service mysqld start </span><br><span class="line"></span><br><span class="line">步骤7: 查看mysql是否自启动,并且设置开启自启动</span><br><span class="line">[root@localhost &#x2F;]# chkconfig --list | grep mysqld </span><br><span class="line">0 1 2 3 4 5 6 代表centOS启动状态</span><br><span class="line">[root@localhost &#x2F;]# chkconfig mysqld on </span><br><span class="line"></span><br><span class="line">步骤8: 修改字符集为UTF-8</span><br><span class="line">[root@localhost &#x2F;]# vim &#x2F;etc&#x2F;my.cnf</span><br><span class="line">在[mysqld]部分添加：</span><br><span class="line">character-set-server&#x3D;utf8 </span><br><span class="line">在文件末尾新增[client]段，并在[client]段添加：</span><br><span class="line">default-character-set&#x3D;utf8 </span><br><span class="line">esc退出编辑</span><br><span class="line">:wq保存退出</span><br><span class="line">修改完成后保存重启服务</span><br><span class="line">[root@localhost &#x2F;]# service mysqld restart </span><br><span class="line"></span><br><span class="line">步骤9: 修改默认配置 </span><br><span class="line">[root@localhost &#x2F;]# mysql_secure_installation </span><br><span class="line">按照提示进行配置，这里默认root用户的密码空，直接回车即可。此处输入内容:&quot;y&quot;,&quot;y&quot;,&quot;n&quot;,&quot;y&quot;,&quot;y&quot; </span><br><span class="line"></span><br><span class="line">步骤10:授权远程登录</span><br><span class="line">方案1:实现远程连接(授权法)- 将权限改为ALL PRIVILEGES</span><br><span class="line">[root@localhost &#x2F;]# mysql -uroot -p</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed </span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">&#x2F;&#x2F;mysql 新设置用户或更改密码后需用flush privileges刷新MySQL的系统权限相关表，否则会出现拒绝访问</span><br><span class="line">mysql&gt; select host,user,password from user; </span><br><span class="line">这样机器就可以以用户名root密码root远程访问该机器上的MySql. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案2:实现远程连接（改表法）</span><br><span class="line">use mysql;</span><br><span class="line">update user set host &#x3D; &#39;%&#39; where user &#x3D; &#39;root&#39;;</span><br><span class="line">fiush privileges </span><br><span class="line">这样在远端就可以通过root用户访问Mysql</span><br></pre></td></tr></table></figure><p>注意在测试时，要关闭防火墙 ~~</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11_Linux 安装 JDK8</title>
      <link href="2021/02/17/Linux/11-Linux-%E5%AE%89%E8%A3%85-JDK8/"/>
      <url>2021/02/17/Linux/11-Linux-%E5%AE%89%E8%A3%85-JDK8/</url>
      
        <content type="html"><![CDATA[<h1 id="11-Linux-安装-JDK8"><a href="#11-Linux-安装-JDK8" class="headerlink" title="11_Linux 安装 JDK8"></a>11_Linux 安装 JDK8</h1><h4 id="1-下载-JDK"><a href="#1-下载-JDK" class="headerlink" title="1.下载 JDK"></a>1.下载 JDK</h4><p>百度云链接：<a href="https://pan.baidu.com/s/1KFCLXSrsVvjYBNweugZv0w">https://pan.baidu.com/s/1KFCLXSrsVvjYBNweugZv0w</a><br>提取码：r3tt</p><h4 id="2-创建保存JDK的文件夹"><a href="#2-创建保存JDK的文件夹" class="headerlink" title="2.创建保存JDK的文件夹"></a>2.创建保存JDK的文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir jdkhome</span><br></pre></td></tr></table></figure><h4 id="3-解压JDK到jdkhome下"><a href="#3-解压JDK到jdkhome下" class="headerlink" title="3.解压JDK到jdkhome下"></a>3.解压JDK到jdkhome下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf jdk-8u11-linux-x64.tar.gz  -C &#x2F;home&#x2F;admin&#x2F;jdkhome</span><br></pre></td></tr></table></figure><h4 id="4-测试JDK是否安装成功"><a href="#4-测试JDK是否安装成功" class="headerlink" title="4.测试JDK是否安装成功"></a>4.测试JDK是否安装成功</h4><p>在JDK安装后的bin目录下运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xj0927 bin]# .&#x2F;java -version</span><br><span class="line">java version &quot;1.8.0_11&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_11-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)</span><br></pre></td></tr></table></figure><p>现在你只能在bin目录下查看JDK，所以还需要配置环境变量</p><h4 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5.配置环境变量"></a>5.配置环境变量</h4><h6 id="1-先切换到root用户-su-root"><a href="#1-先切换到root用户-su-root" class="headerlink" title="(1)先切换到root用户:su root"></a>(1)先切换到root用户:su root</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su root </span><br><span class="line">:输入密码</span><br></pre></td></tr></table></figure><p>(2)修改 profile 文件的操作权限: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +w &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h6 id="3-编辑profile文件"><a href="#3-编辑profile文件" class="headerlink" title="(3)编辑profile文件:"></a>(3)编辑profile文件:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h6 id="4-添加JAVA-HOME变量"><a href="#4-添加JAVA-HOME变量" class="headerlink" title="(4)添加JAVA_HOME变量:"></a>(4)添加JAVA_HOME变量:</h6><p>在文件末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#前面两条语句即可</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;home&#x2F;admin&#x2F;jdkhome&#x2F;jdk1.8.0_11</span><br><span class="line"># $PATH放在后面,覆盖自带的openjdk</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br></pre></td></tr></table></figure><h6 id="5-使环境变量及时生效"><a href="#5-使环境变量及时生效" class="headerlink" title="(5)使环境变量及时生效"></a>(5)使环境变量及时生效</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h6 id="6-查看变量是否更新成功"><a href="#6-查看变量是否更新成功" class="headerlink" title="(6)查看变量是否更新成功:"></a>(6)查看变量是否更新成功:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><h4 id="6-查看JDK"><a href="#6-查看JDK" class="headerlink" title="6.查看JDK"></a>6.查看JDK</h4><h6 id="7-在任意目录下测试环境是否配置成功"><a href="#7-在任意目录下测试环境是否配置成功" class="headerlink" title="(7)在任意目录下测试环境是否配置成功"></a>(7)在任意目录下测试环境是否配置成功</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>admin用户下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 bin]$ java -version</span><br><span class="line">java version &quot;1.8.0_11&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_11-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)</span><br></pre></td></tr></table></figure><p>也可输入java:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 bin]$ java</span><br><span class="line">Usage: java [-options] class [args...]</span><br><span class="line">           (to execute a class)</span><br><span class="line">   or  java [-options] -jar jarfile [args...]</span><br><span class="line">           (to execute a jar file)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>输入javac:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 bin]$ javac</span><br><span class="line">Usage: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">where possible options include:</span><br><span class="line">....</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10_Linux 基本命令</title>
      <link href="2021/02/17/Linux/10-Linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>2021/02/17/Linux/10-Linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="10-Linux-基本命令"><a href="#10-Linux-基本命令" class="headerlink" title="10_Linux 基本命令"></a>10_Linux 基本命令</h1><h2 id="1）目录结构"><a href="#1）目录结构" class="headerlink" title="1）目录结构"></a>1）目录结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184322.png"></p><p>使用命令查看:<code>ll</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184323.png"></p><ul><li>bin 存放二进制可执行文件(ls,cat,mkdir等) </li><li>boot 存放用于<strong>系统引导</strong>时使用的各种文件</li><li>dev 用于存放<strong>设备文件</strong></li><li>etc 存放系统<strong>配置文件</strong></li><li>home 存放所有<strong>用户文件</strong>的根目录 </li><li>lib 存放跟文件系统中的程序运行所需要的共享库及内核模块</li><li>mnt 系统管理员安装<strong>临时文件</strong>系统的安装点</li><li>opt 额外安装的可选应用<strong>程序包所放</strong>置的位置</li><li>usr 用于存放系统应用程序，比较重要的目录**/usr/local 本地管理员软件**安装目录</li></ul><p>需要关注的目录：</p><p>/etc 配置目录–&gt;软件安装后配置文件选择放入的地址。 </p><p>/usr/local软件安装目录</p><p>/opt目录一般用来安装应用程序。部署的API程序一般放在这个目录。 </p><h2 id="2）文件权限"><a href="#2）文件权限" class="headerlink" title="2）文件权限"></a>2）文件权限</h2><p>在linux下每个用户都有不同的权限，普通用户只能在自己的主目录下进行写操作. </p><p>三种基本权限:</p><ul><li>R 读权限</li><li>W 写权限</li><li>X 执行权限 </li></ul><h6 id="1-文件各部分"><a href="#1-文件各部分" class="headerlink" title="/1.文件各部分:"></a>/1.文件各部分:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--. 1 root root 26 Jul 16&#x3D;1 12:02 qf.log</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184239.png"></p><h6 id="2-权限各部分：分为4部分-1-2-4-5-7-8-10"><a href="#2-权限各部分：分为4部分-1-2-4-5-7-8-10" class="headerlink" title="/2.权限各部分：分为4部分(1,2-4,5-7,8-10)"></a>/2.权限各部分：分为4部分(1,2-4,5-7,8-10)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184251.png"></p><h6 id="3-修改权限方式"><a href="#3-修改权限方式" class="headerlink" title="/3.修改权限方式"></a>/3.修改权限方式</h6><p>方式1：字符设置法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：chmod [who][+ | - | &#x3D;] 文件名</span><br><span class="line">who (u 用户user ,g用户组group,o其他用户,a所有用户默认) </span><br><span class="line">操作符号:</span><br><span class="line">+添加某个权限</span><br><span class="line">-取消某个权限</span><br><span class="line">&#x3D;赋予权限</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">修改一个权限</span><br><span class="line">chmod g+w a.txt</span><br><span class="line">chmod u+x,g+w,o+w a.txt </span><br></pre></td></tr></table></figure><p>方式2：数字设定法</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217184259.png"></p><ul><li>4表可读权限=r</li><li>2表写入权限=w</li><li>1表可执行=x</li><li>0无权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">举例:</span><br><span class="line">当前的数字权限: </span><br><span class="line">用户权限&#x3D;rwx&#x3D;4+2+1&#x3D;7 </span><br><span class="line">所属组权限&#x3D;r--&#x3D;4+0+0&#x3D;4 </span><br><span class="line">其他用户权限&#x3D;r--&#x3D;4+0+0&#x3D;4 </span><br><span class="line">组合:744</span><br><span class="line"></span><br><span class="line">chmod 744 a.txt</span><br></pre></td></tr></table></figure><h5 id="3-常用指令"><a href="#3-常用指令" class="headerlink" title="3)常用指令"></a>3)常用指令</h5><h6 id="1-查看目录"><a href="#1-查看目录" class="headerlink" title="/1.查看目录"></a>/1.查看目录</h6><ul><li>ls 查看目录内容 </li><li>ll 查看详细信息 </li></ul><h6 id="2-创建目录"><a href="#2-创建目录" class="headerlink" title="/2.创建目录"></a>/2.创建目录</h6><ul><li>mkdir ：创建目录 </li><li>mkdir -p 创建目录以及子目录，多个目录同时创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;a&#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure><h6 id="3-切换目录"><a href="#3-切换目录" class="headerlink" title="/3.切换目录"></a>/3.<strong>切换目录</strong></h6><p>cd 切换目录</p><ul><li>cd .. 要加空格</li><li>cd ../xxx 进入上一级目录的子目录 </li></ul><h6 id="4-创建文件"><a href="#4-创建文件" class="headerlink" title="/4.创建文件"></a>/4.创建文件</h6><ul><li>touch ：创建一个空白的普通文件</li></ul><h6 id="5-写入内容"><a href="#5-写入内容" class="headerlink" title="/5.写入内容"></a>/5.写入内容</h6><p>echo :把内容重定向到指定的文件中 ，有则打开，无则创建 </p><ul><li>覆盖模式(会清除之前的内容)&gt;: echo “ww”&gt;aa.txt  </li><li>追加模式(不会清除之前的内容)&gt;&gt;: echo “ww”&gt;&gt;aa.txt</li></ul><h6 id="6-查看文件内容"><a href="#6-查看文件内容" class="headerlink" title="/6.查看文件内容"></a>/6.查看文件内容</h6><ul><li>cat ：查看文件内容 </li><li>more ：分页查看文件内容，按空格键换页 </li></ul><h6 id="7-复制"><a href="#7-复制" class="headerlink" title="/7.复制"></a>/7.复制</h6><ul><li>cp ：复制 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把a.txt复制到b文件夹下</span><br><span class="line">cp a.txt b</span><br></pre></td></tr></table></figure><h6 id="8-剪切、重命名"><a href="#8-剪切、重命名" class="headerlink" title="/8.剪切、重命名"></a>/8.剪切、重命名</h6><ul><li>mv ：剪切、重命名(剪切的文件 放在同一个目录中是重命名) </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">剪切:</span><br><span class="line">剪切a.txt到b文件夹下</span><br><span class="line">mv a.txt b</span><br><span class="line"></span><br><span class="line">重命名:</span><br><span class="line">将a.txt重命名为b.txt</span><br><span class="line">mv a.txt b.txt</span><br></pre></td></tr></table></figure><h6 id="9-删除"><a href="#9-删除" class="headerlink" title="/9.删除"></a>/9.删除</h6><ul><li>删除文件:rm 文件名</li><li>删除文件夹：rm -r 文件夹名</li><li>rm -fr 直接彻底删除，没有提示。 </li></ul><h6 id="10-统计行数"><a href="#10-统计行数" class="headerlink" title="/10.统计行数"></a>/10.统计行数</h6><ul><li>统计行数 : wc  -l  文件名</li></ul><h6 id="11-查看当前路径"><a href="#11-查看当前路径" class="headerlink" title="/11.查看当前路径"></a>/11.查看当前路径</h6><ul><li>pwd ：查看当前目录的绝对路径</li></ul><h6 id="12-显示主机名"><a href="#12-显示主机名" class="headerlink" title="/12.显示主机名"></a>/12.显示主机名</h6><ul><li>hostname ： 显示主机名 </li></ul><h6 id="13-查看系统信息"><a href="#13-查看系统信息" class="headerlink" title="/13.查看系统信息"></a>/13.查看系统信息</h6><ul><li><p>uname -a ：显示完整的系统信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 test]$ uname -a</span><br><span class="line">Linux xj0927 2.6.32-431.el6.x86_64 #1 SMP Fri Nov 22 03:15:09 UTC 2013 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><h6 id="14-查看进程耗时与占用"><a href="#14-查看进程耗时与占用" class="headerlink" title="/14.查看进程耗时与占用"></a>/14.查看进程耗时与占用</h6></li><li><p> top ：显示当前耗时的进程信息 ,每3秒刷新一次</p></li><li><p>cltr+c: 中断</p><p>top确认cpu和内存的占用情况</p></li></ul><h6 id="15-查看进程快照"><a href="#15-查看进程快照" class="headerlink" title="/15.查看进程快照"></a>/15.查看进程快照</h6><ul><li>ps - axu : 显示当前进程的快照</li><li>ps - axu  | grep java : 显示某個程序当前进程的快照</li></ul><h6 id="16-文件大小"><a href="#16-文件大小" class="headerlink" title="/16.文件大小"></a>/16.文件大小</h6><ul><li>du -sh:  显示文件的大小信息 </li></ul><h6 id="17-磁盘占用情况"><a href="#17-磁盘占用情况" class="headerlink" title="/17.磁盘占用情况"></a>/17.磁盘占用情况</h6><ul><li>df -lh : 磁盘使用情况 </li></ul><h6 id="18-查看网卡情况"><a href="#18-查看网卡情况" class="headerlink" title="/18.查看网卡情况"></a>/18.查看网卡情况</h6><ul><li>ifconfig ：查看或者配置网卡信息(ip addr) </li></ul><h6 id="19-结束进程"><a href="#19-结束进程" class="headerlink" title="/19.结束进程"></a>/19.结束进程</h6><ul><li>kill pid ：杀死进程 ,pid进程编号</li><li>Kill -9 :强制杀死</li></ul><h6 id="20-查看端口号"><a href="#20-查看端口号" class="headerlink" title="/20.查看端口号"></a>/20.查看端口号</h6><ul><li>netstat </li></ul><p>常用参数: </p><p>-a或–all：显示所有连线中的Socket； </p><p>-l或–listening：显示监控中的服务器的Socket； </p><p>-n或–numeric：直接使用ip地址，而不通过域名服务器； </p><p>-p或–programs：显示正在使用Socket的程序识别码和程序名称； </p><p>-t或–tcp：显示TCP传输协议的连线状况； </p><p>简写：netstat -tlnp</p><p>找出运行在指定端口的进程：netstat -tlnp | grep ‘:22’ </p><h6 id="21-压缩文件与解压"><a href="#21-压缩文件与解压" class="headerlink" title="/21.压缩文件与解压"></a>/21.压缩文件与解压</h6><ul><li><p>c ：创建的一个归档文件 </p></li><li><p>x ：拆包 </p></li><li><p>z ：以gzip 格式压缩 j ：以bzip2格式压缩 </p></li><li><p>v ：显示打包或者拆包的文件信息 </p></li><li><p>f ： 后面紧接一个 归档文件 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">压缩指定文件到指定目录下:</span><br><span class="line">tar -czvf 目录/压缩文件名.tar.gz 源文件</span><br><span class="line"></span><br><span class="line">将b1文件夹下的a.txt压缩到b2文件夹下:</span><br><span class="line">tar -czvf b2/b1.tar.gz b1/a.txt</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解压指点文件到指定文件夹下:</span><br><span class="line">tar -xzvf 目录/压缩包名.tar.gz -C 路径/</span><br><span class="line"></span><br><span class="line">将d2目录下的a.tar.gz解压到d1目录下</span><br><span class="line">tar -xzvf d2/a.tar.gz -C /home/admin/test/</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="3）文本编辑器"><a href="#3）文本编辑器" class="headerlink" title="3）文本编辑器"></a>3）文本编辑器</h2><p>一般模式 ，默认方式，该模式不能编辑</p><ul><li><p>按 i（insert） 进入 插入模式</p><p>编辑模式</p></li><li><p>该模式可以编辑文档，按esc 退出插入模式 </p><p>命令模式</p></li><li><p>一般模式中按：进入命令模式[yy复制一行, dd剪切一行,p粘贴] </p></li><li><p>:q 安全退出，当没有操作该文档 </p></li><li><p>:q！修改了内容，但不想保存，强制退出 </p></li><li><p>:wq 保存退出 </p></li><li><p>:set number 显示行号set nonumber 取消行号显示</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9_CentOs 设置防火墙及开放端口</title>
      <link href="2021/02/17/Linux/9-CentOs-%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E5%8F%8A%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/"/>
      <url>2021/02/17/Linux/9-CentOs-%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E5%8F%8A%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="9-CentOs-设置防火墙及开放端口"><a href="#9-CentOs-设置防火墙及开放端口" class="headerlink" title="9_CentOs 设置防火墙及开放端口"></a>9_CentOs 设置防火墙及开放端口</h1><blockquote><p>Linux系统中默认有防火墙 Iptables 管理所有的端口，只启用默认远程连接22端口其他都关闭</p></blockquote><h5 id="1-方案一：修改防火墙配置"><a href="#1-方案一：修改防火墙配置" class="headerlink" title="1)方案一：修改防火墙配置"></a>1)<strong>方案一：修改防火墙配置</strong></h5><p>将开启的端口加入防火墙白名单中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure><p>增加下面代码 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -p tcp -m state -- state NEW -m tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state -- state NEW -m tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure><p>保存退出，重启防火墙 </p><h6 id="重启防火墙："><a href="#重启防火墙：" class="headerlink" title="重启防火墙："></a>重启防火墙：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><h6 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables status</span><br></pre></td></tr></table></figure><h5 id="2-方案二：关闭防火墙"><a href="#2-方案二：关闭防火墙" class="headerlink" title="2)方案二：关闭防火墙"></a>2)<strong>方案二：关闭防火墙</strong></h5><h6 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙 :"></a>关闭防火墙 :</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><h6 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙:"></a>开启防火墙:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables start</span><br></pre></td></tr></table></figure><h6 id="关闭防火墙自动启动"><a href="#关闭防火墙自动启动" class="headerlink" title="关闭防火墙自动启动"></a>关闭防火墙自动启动</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfifig iptables of</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8_CentOs 下安装 Tomcat</title>
      <link href="2021/02/17/Linux/8-CentOs-%E4%B8%8B%E5%AE%89%E8%A3%85-Tomcat/"/>
      <url>2021/02/17/Linux/8-CentOs-%E4%B8%8B%E5%AE%89%E8%A3%85-Tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="8-CentOs-下安装-Tomcat"><a href="#8-CentOs-下安装-Tomcat" class="headerlink" title="8_CentOs 下安装 Tomcat"></a>8_CentOs 下安装 Tomcat</h1><h5 id="1-上传tomcat压缩包"><a href="#1-上传tomcat压缩包" class="headerlink" title="1.上传tomcat压缩包"></a>1.上传tomcat压缩包</h5><p>百度云链接：<a href="https://pan.baidu.com/s/1R2njJS-l8DDwCDhV1sFZJw">https://pan.baidu.com/s/1R2njJS-l8DDwCDhV1sFZJw</a><br>提取码：tscu</p><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf apache-tomcat-8.5.56.tar.gz </span><br></pre></td></tr></table></figure><h5 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h5><p>进入解压包下的bin目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">启动:</span><br><span class="line">.&#x2F;startup.sh</span><br><span class="line"></span><br><span class="line">关闭:</span><br><span class="line">.&#x2F;shutdown.sh</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7_本地文件上传到Linux</title>
      <link href="2021/02/17/Linux/7-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Linux/"/>
      <url>2021/02/17/Linux/7-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="7-本地文件上传到Linux"><a href="#7-本地文件上传到Linux" class="headerlink" title="7_本地文件上传到Linux"></a>7_本地文件上传到Linux</h1><h4 id="1-SecureFXPortable软件下载"><a href="#1-SecureFXPortable软件下载" class="headerlink" title="1. SecureFXPortable软件下载"></a>1. SecureFXPortable软件下载</h4><p>百度云链接：<a href="https://pan.baidu.com/s/19QHs7QCFCkgRgk1Nq9d2Gw">https://pan.baidu.com/s/19QHs7QCFCkgRgk1Nq9d2Gw</a><br>提取码：01ue</p><h4 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2. 建立连接"></a>2. 建立连接</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183850.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183851.png"></p><h4 id="3-上传"><a href="#3-上传" class="headerlink" title="3)上传"></a>3)上传</h4><p>直接将左侧Windows系统下的压缩包拖拽到右侧即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183852.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6_更改系统语言</title>
      <link href="2021/02/17/Linux/6-%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/"/>
      <url>2021/02/17/Linux/6-%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="6-更改系统语言"><a href="#6-更改系统语言" class="headerlink" title="6_更改系统语言"></a>6_更改系统语言</h1><p>使用root权限进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su root </span><br><span class="line">password:输入密码(密码不可见)</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看当前所有语言环境：</span></span><br><span class="line">locale -a</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看当前系统语言环境：</span></span><br><span class="line">echo $LANG</span><br></pre></td></tr></table></figure><p>编辑i18n配置文件:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;i18n</span><br></pre></td></tr></table></figure><p>进行如下配置并保存退出：esc+ :wq!</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183732.png"></p><p>重启系统后系统文字变成英文简体。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_CentOs 7 连接外网的解决办法</title>
      <link href="2021/02/17/Linux/5-CentOs-7-%E8%BF%9E%E6%8E%A5%E5%A4%96%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>2021/02/17/Linux/5-CentOs-7-%E8%BF%9E%E6%8E%A5%E5%A4%96%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="5-CentOs-7-连接外网的解决办法"><a href="#5-CentOs-7-连接外网的解决办法" class="headerlink" title="5_CentOs 7 连接外网的解决办法"></a>5_CentOs 7 连接外网的解决办法</h1><h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>在新安装 CentOs 7后，想要连接外网，发现不能上网，同时 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p>出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name or service not known</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>网络未配置好 。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="一、选择-VMWare-的-NAT-模式"><a href="#一、选择-VMWare-的-NAT-模式" class="headerlink" title="一、选择 VMWare 的 NAT 模式"></a>一、选择 VMWare 的 NAT 模式</h3><h4 id="1）导航栏“编辑”-gt-“虚拟网络编辑器”-gt-NAT模式-gt-NAT设置"><a href="#1）导航栏“编辑”-gt-“虚拟网络编辑器”-gt-NAT模式-gt-NAT设置" class="headerlink" title="1）导航栏“编辑”-&gt;“虚拟网络编辑器” -&gt;NAT模式-&gt;NAT设置"></a>1）导航栏“编辑”-&gt;“虚拟网络编辑器” -&gt;NAT模式-&gt;NAT设置</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183642.png"></p><p>这一步主要是：记住NAT设置中的子网IP、子网掩码、网关IP三项，接下来配置文件主要是这三项。</p><h4 id="2）编辑网络配置文件"><a href="#2）编辑网络配置文件" class="headerlink" title="2）编辑网络配置文件"></a>2）编辑网络配置文件</h4><p>首先查看自己的网络使用的是哪个配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183643.png"></p><p>也可以使用下面命令查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183644.png"></p><p>然后编辑该文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183645.png"></p><p>保存退出！</p><blockquote><p>如何配置 Linux 的静态 IP，可参考我写的这篇博客</p></blockquote><h4 id="3）重启网络"><a href="#3）重启网络" class="headerlink" title="3）重启网络"></a>3）重启网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h4 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183646.png"></p><p>说明可正常连接外网！！！</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_设置主机名访问任意主机</title>
      <link href="2021/02/17/Linux/4-%E8%AE%BE%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%90%8D%E8%AE%BF%E9%97%AE%E4%BB%BB%E6%84%8F%E4%B8%BB%E6%9C%BA/"/>
      <url>2021/02/17/Linux/4-%E8%AE%BE%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%90%8D%E8%AE%BF%E9%97%AE%E4%BB%BB%E6%84%8F%E4%B8%BB%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="4-设置主机名访问任意主机"><a href="#4-设置主机名访问任意主机" class="headerlink" title="4_设置主机名访问任意主机"></a>4_设置主机名访问任意主机</h1><p>修改之前，只能通过ip进行访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 myfile]$ ping 192.168.77.131</span><br><span class="line">PING 192.168.77.131 (192.168.77.131) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.77.131: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.156 ms</span><br><span class="line">64 bytes from 192.168.77.131: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.127 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="ip与主机名映射"><a href="#ip与主机名映射" class="headerlink" title="ip与主机名映射"></a>ip与主机名映射</h2><h5 id="1-切换root"><a href="#1-切换root" class="headerlink" title="1)切换root"></a>1)切换root</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><h5 id="2-修改文件"><a href="#2-修改文件" class="headerlink" title="2)修改文件"></a>2)修改文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><h5 id="3-修改内容为"><a href="#3-修改内容为" class="headerlink" title="3)修改内容为:"></a>3)修改内容为:</h5><p>此时两个centos的ip和主机名分别为:</p><ul><li>192.168.77.130 xj0927</li><li>192.168.77.131 xj0928</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.77.130 xj0927</span><br><span class="line">192.168.77.131 xj0928</span><br><span class="line"></span><br><span class="line">若有其他ip和主机名也可继续添加...</span><br></pre></td></tr></table></figure><h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4)测试"></a>4)测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[admin@xj0927 myfile]$ ping xj0928</span><br><span class="line">PING xj0928 (192.168.77.131) 56(84) bytes of data.</span><br><span class="line">64 bytes from xj0928 (192.168.77.131): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;15.4 ms</span><br><span class="line">64 bytes from xj0928 (192.168.77.131): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.207 ms</span><br><span class="line">64 bytes from xj0928 (192.168.77.131): icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.202 ms</span><br><span class="line">....</span><br></pre></td></tr></table></figure><hr><h2 id="Linux修改主机名"><a href="#Linux修改主机名" class="headerlink" title="Linux修改主机名"></a>Linux修改主机名</h2><h5 id="1-切换到root用户"><a href="#1-切换到root用户" class="headerlink" title="1)切换到root用户"></a>1)切换到root用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><h5 id="2-修改文件-1"><a href="#2-修改文件-1" class="headerlink" title="2)修改文件"></a>2)修改文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network</span><br></pre></td></tr></table></figure><p>注意:该文件是只读文件，退出时使用:wq退出 </p><h5 id="3-重新连接"><a href="#3-重新连接" class="headerlink" title="3)重新连接"></a>3)重新连接</h5><p>重新连接后显示修改后的服务器名 </p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_CentOs 7修改 IP 地址</title>
      <link href="2021/02/17/Linux/3-CentOs-7%E4%BF%AE%E6%94%B9-IP-%E5%9C%B0%E5%9D%80/"/>
      <url>2021/02/17/Linux/3-CentOs-7%E4%BF%AE%E6%94%B9-IP-%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="3-CentOs-7修改-IP-地址"><a href="#3-CentOs-7修改-IP-地址" class="headerlink" title="3_CentOs 7修改 IP 地址"></a>3_CentOs 7修改 IP 地址</h1><h3 id="问题场景："><a href="#问题场景：" class="headerlink" title="问题场景："></a>问题场景：</h3><p>安装完 CentOs 7 后，使用 ifconfig 查看 ip，没有显示出来，xshell 也就连接不上，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job for network.service failed because the control process exited with error</span><br></pre></td></tr></table></figure><p>此时，我们可以自己去配置静态 IP</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>首先，切换到 root 用户，查看自己需要修改哪个文件,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183404.png"></p><p>然后进入网络配置文件 network-scripts 目录下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</span><br></pre></td></tr></table></figure><p>使用 ls 命令，列出该目录下的文件，其中<strong>“ifcfg-ens33”</strong>的文件，为我们需要修改的网络配置文件。</p><p>使用 <strong>vim 命令</strong>（vi命令也可以）,对文件进行配置，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ifcfg-ens33</span><br></pre></td></tr></table></figure><p>我们需要修改：</p><p><strong>BOOTPROTO=”static</strong>“也就是将 dhcp 改为 static ，</p><p><strong>ONBOOT=”yes”</strong> 意思是将网卡设置为 开机启用，</p><p>同时在最后添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IPADDR&#x3D;192.168.0.230 #静态IP  </span><br><span class="line"></span><br><span class="line">GATEWAY&#x3D;192.168.0.1 #默认网关  </span><br><span class="line"></span><br><span class="line">NETMASK&#x3D;255.255.255.0 #子网掩码  </span><br><span class="line"></span><br><span class="line">DNS1&#x3D;192.168.0.1 #DNS 配置  </span><br><span class="line"></span><br><span class="line">DNS2&#x3D;8.8.8.8     #谷歌地址</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183405.png"></p><p>保存退出！</p><p>重启网络，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><hr><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217183406.png"></p><p>如果报错，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job for network.service failed because the control process exited with error code. See &quot;systemctl status network.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure><p>可能是不小心改了一些文件，</p><p>解决办法：</p><p>在 /etc/sysconfig/network-scripts 目录下删除掉别的 ifcfg-xxx(只保留一个你网卡同名的文档)</p><p>再把 NetworkManager 停用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl disable NetworkManager</span><br></pre></td></tr></table></figure><p>保存之后再执行 systemctl restart network 就可以解决了 。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_CentOs 6 修改 IP 地址</title>
      <link href="2021/02/17/Linux/2_CentOs%206%20%E4%BF%AE%E6%94%B9%20IP%20%E5%9C%B0%E5%9D%80/"/>
      <url>2021/02/17/Linux/2_CentOs%206%20%E4%BF%AE%E6%94%B9%20IP%20%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux修改IP地址"><a href="#Linux修改IP地址" class="headerlink" title="Linux修改IP地址"></a>Linux修改IP地址</h1><h5 id="1-切换到root用户"><a href="#1-切换到root用户" class="headerlink" title="1)切换到root用户"></a>1)切换到root用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><h5 id="2-运行setup命令"><a href="#2-运行setup命令" class="headerlink" title="2)运行setup命令"></a>2)运行setup命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup</span><br></pre></td></tr></table></figure><h5 id="3-选择Network-configuration"><a href="#3-选择Network-configuration" class="headerlink" title="3)选择Network configuration"></a>3)选择Network configuration</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216232416.png"></p><h5 id="4-选择Device-configuration"><a href="#4-选择Device-configuration" class="headerlink" title="4)选择Device configuration"></a>4)选择Device configuration</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216232417.png"></p><h5 id="5-选择eth0"><a href="#5-选择eth0" class="headerlink" title="5)选择eth0"></a>5)选择eth0</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216232418.png"></p><h5 id="6-按空格-去掉-进行设置即可"><a href="#6-按空格-去掉-进行设置即可" class="headerlink" title="6)按空格,去掉*,进行设置即可"></a>6)按空格,去掉*,进行设置即可</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216232419.png"></p><h5 id="7-重启网络服务"><a href="#7-重启网络服务" class="headerlink" title="7)重启网络服务"></a>7)重启网络服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h5 id="8-测试"><a href="#8-测试" class="headerlink" title="8)测试:"></a>8)测试:</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看地址是否为修改后的地址</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_Xsell连接Linux</title>
      <link href="2021/02/17/Linux/1_Xsell%E8%BF%9E%E6%8E%A5Linux/"/>
      <url>2021/02/17/Linux/1_Xsell%E8%BF%9E%E6%8E%A5Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Xsell连接Linux"><a href="#Xsell连接Linux" class="headerlink" title="Xsell连接Linux"></a>Xsell连接Linux</h1><blockquote><p>来回切换虚拟机与Windows比较麻烦</p></blockquote><p>此时通过Xshell来连接</p><p><a href="https://pan.baidu.com/s/1yG6YFaSig4y1LcQ89FaV5A">百度云链接：提取码：ie6f </a></p><h5 id="1）查看Linux端口号"><a href="#1）查看Linux端口号" class="headerlink" title="1）查看Linux端口号"></a>1）查看Linux端口号</h5><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231615.png"  /><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231616.png"  /><h5 id="2）打开xshell，输入相关信息，建立连接"><a href="#2）打开xshell，输入相关信息，建立连接" class="headerlink" title="2）打开xshell，输入相关信息，建立连接"></a>2）打开xshell，输入相关信息，建立连接</h5><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231617.png"  /><h5 id="3-输入登录的Linux用户名"><a href="#3-输入登录的Linux用户名" class="headerlink" title="3)输入登录的Linux用户名"></a>3)输入登录的Linux用户名</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231618.png"></p><h5 id="4-输入登录的Linux密码"><a href="#4-输入登录的Linux密码" class="headerlink" title="4)输入登录的Linux密码"></a>4)输入登录的Linux密码</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231619.jpg"></p><h5 id="5-连接成功"><a href="#5-连接成功" class="headerlink" title="5)连接成功"></a>5)连接成功</h5><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231620.png"  /><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Xshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0_在VM虚拟机下安装-Linux</title>
      <link href="2021/02/17/Linux/0_%E5%9C%A8VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E5%AE%89%E8%A3%85-Linux/"/>
      <url>2021/02/17/Linux/0_%E5%9C%A8VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E5%AE%89%E8%A3%85-Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="在-VM-虚拟机下安装-Linux"><a href="#在-VM-虚拟机下安装-Linux" class="headerlink" title="在 VM 虚拟机下安装 Linux"></a>在 VM 虚拟机下安装 Linux</h1><h2 id="VM虚拟机安装"><a href="#VM虚拟机安装" class="headerlink" title="VM虚拟机安装"></a>VM虚拟机安装</h2><p><a href="https://pan.baidu.com/s/1xOLBGDqy2SmSI204AoIj7g">百度云链接：提取码：o6e6</a></p><p>安装完成后…查看是否有这两项</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231011.png"></p><hr><h2 id="安装Linux"><a href="#安装Linux" class="headerlink" title="安装Linux"></a>安装Linux</h2><h5 id="1）-Create-a-New-Virtual-Machine-新建虚拟机"><a href="#1）-Create-a-New-Virtual-Machine-新建虚拟机" class="headerlink" title="1） Create a New Virtual Machine (新建虚拟机)"></a>1） Create a New Virtual Machine (新建虚拟机)</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231012.png"></p><h5 id="2）选择Typical-典型"><a href="#2）选择Typical-典型" class="headerlink" title="2）选择Typical(典型)"></a>2）选择Typical(典型)</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231013.png"></p><h5 id="3）稍后选择-Linux-CentOS安装镜像"><a href="#3）稍后选择-Linux-CentOS安装镜像" class="headerlink" title="3）稍后选择 Linux CentOS安装镜像"></a>3）稍后选择 Linux CentOS安装镜像</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231014.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231015.png"></p><h5 id="4）选择CentOS安装目录"><a href="#4）选择CentOS安装目录" class="headerlink" title="4）选择CentOS安装目录"></a>4）选择CentOS安装目录</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231016.png"></p><h5 id="5）给系统指定最大磁盘空间-不建议小于5G"><a href="#5）给系统指定最大磁盘空间-不建议小于5G" class="headerlink" title="5）给系统指定最大磁盘空间(不建议小于5G)"></a>5）给系统指定最大磁盘空间(不建议小于5G)</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231017.png"></p><h5 id="6）完成"><a href="#6）完成" class="headerlink" title="6）完成"></a>6）完成</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231018.png"></p><h5 id="7）开始Server安装"><a href="#7）开始Server安装" class="headerlink" title="7）开始Server安装"></a>7）开始Server安装</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231019.png"></p><h5 id="8）开启虚拟机"><a href="#8）开启虚拟机" class="headerlink" title="8）开启虚拟机"></a>8）开启虚拟机</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231020.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231021.jpg"></p><h5 id="小插曲："><a href="#小插曲：" class="headerlink" title="小插曲："></a>小插曲：</h5><p>若第一次安装,此时可能出现下列问题</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231022.jpg"></p><p>解决措施:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.重启电脑进入 BIOS，既是按F1 或 F2、或F5、或delete等..不同品牌进入不同。</span><br><span class="line">2.找到菜单 Advanced   进入cpu configuration </span><br><span class="line">3.将 intel virtual technology 设置为 Enable，f10，然后保存退出；</span><br><span class="line">  或者是将SVM Mode 设置为Enable</span><br><span class="line">3.重新打开虚拟机即可。</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231023.png"></p><h5 id="9）设置语言"><a href="#9）设置语言" class="headerlink" title="9）设置语言"></a>9）设置语言</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231024.png"></p><h5 id="10）键盘选择"><a href="#10）键盘选择" class="headerlink" title="10）键盘选择"></a>10）键盘选择</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231025.png"></p><h5 id="11）基本储存设备"><a href="#11）基本储存设备" class="headerlink" title="11）基本储存设备"></a>11）基本储存设备</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231026.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231027.png"></p><h5 id="12）设置主机名"><a href="#12）设置主机名" class="headerlink" title="12）设置主机名"></a>12）设置主机名</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231028.png"></p><h5 id="13）选择时区"><a href="#13）选择时区" class="headerlink" title="13）选择时区"></a>13）选择时区</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231029.png"></p><h5 id="14）设置root账户"><a href="#14）设置root账户" class="headerlink" title="14）设置root账户"></a>14）设置root账户</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231030.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231031.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231032.jpg"></p><h5 id="15）安装中…"><a href="#15）安装中…" class="headerlink" title="15）安装中…"></a>15）安装中…</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231033.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231034.png"></p><h5 id="16）创建普通用户"><a href="#16）创建普通用户" class="headerlink" title="16）创建普通用户"></a>16）创建普通用户</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231035.png"></p><h5 id="17）设置时间"><a href="#17）设置时间" class="headerlink" title="17）设置时间"></a>17）设置时间</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231036.jpg"></p><h5 id="18）登录"><a href="#18）登录" class="headerlink" title="18）登录"></a>18）登录</h5><p>![](0_在 VM 虚拟机下安装 Linux/Linux/images/登录.jpg)</p><h5 id="19）网卡设置-非必须"><a href="#19）网卡设置-非必须" class="headerlink" title="19）网卡设置(非必须)"></a>19）网卡设置(非必须)</h5><p><img src= "/img/loading.gif" data-lazy-src="../../../Typora_%E5%B7%A5%E5%85%B7%E7%B1%BB/Linux/images/%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%A9.jpg"></p><p><strong>nat方式</strong>，每次换网络的情况下，<strong>IP不会变化。</strong>跨网段访问。<br><strong>桥接模式</strong>，每次换网络的情况下，<strong>IP都会变化。优势是和主机一个段，相对更快。</strong></p><p>上面是开发环境，下面是线上环境。 </p><hr><h2 id="克隆Linux"><a href="#克隆Linux" class="headerlink" title="克隆Linux"></a>克隆Linux</h2><p>发现一步一步安装确实挺繁琐的，可以选择直接克隆</p><h5 id="1）克隆"><a href="#1）克隆" class="headerlink" title="1）克隆"></a>1）克隆</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231037.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231038.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231039.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231040.png"></p><h5 id="2）克隆路径"><a href="#2）克隆路径" class="headerlink" title="2）克隆路径"></a>2）克隆路径</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231041.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231042.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231043.png"></p><h5 id="3）完成克隆后多台服务器："><a href="#3）完成克隆后多台服务器：" class="headerlink" title="3）完成克隆后多台服务器："></a>3）完成克隆后多台服务器：</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210216231044.jpg"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_redis缓存过期淘汰策略</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/4-redis%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/4-redis%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="4-redis缓存过期淘汰策略"><a href="#4-redis缓存过期淘汰策略" class="headerlink" title="4_redis缓存过期淘汰策略"></a>4_redis缓存过期淘汰策略</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>问题1：生产上你们的redis内存设置多少?</p></blockquote><blockquote><p>问题2：如何配置、修改redis的内存大小？</p></blockquote><blockquote><p>问题3：redis清理内存的方式?定期删除和惰性删除了解过吗？</p></blockquote><blockquote><p>问题4：redis缓存淘汰策略？</p></blockquote><blockquote><p>问题5：redis的LRu了解过吗?可否手写一个LRu算法？</p></blockquote><hr><p>redis默认内存多少？在哪里查看? 如何设置修改?</p><h4 id="查看Redis最大占用内存"><a href="#查看Redis最大占用内存" class="headerlink" title="查看Redis最大占用内存"></a>查看Redis最大占用内存</h4><blockquote><p>打开redis配置文件，设置maxmemory参数，maxmemory是bytes字节类型，注意转换。 </p></blockquote><hr><h4 id="redis默认内存多少可以用？"><a href="#redis默认内存多少可以用？" class="headerlink" title="redis默认内存多少可以用？"></a>redis默认内存多少可以用？</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182352.png"></p><hr><h4 id="一般生产上你如何配置？"><a href="#一般生产上你如何配置？" class="headerlink" title="一般生产上你如何配置？"></a>一般生产上你如何配置？</h4><blockquote><p>一般推荐Redis设置内存为最大物理内存的<code>四分之三</code>，也就是0.75</p></blockquote><hr><h4 id="如何修改redis内存设置"><a href="#如何修改redis内存设置" class="headerlink" title="如何修改redis内存设置"></a>如何修改redis内存设置</h4><p>通过修改文件配置：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182353.png"></p><p>通过命令修改：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182354.png"></p><hr><h4 id="什么命令查看redis内存使用情况"><a href="#什么命令查看redis内存使用情况" class="headerlink" title="什么命令查看redis内存使用情况?"></a>什么命令查看redis内存使用情况?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></table></figure><hr><h4 id="真要打满了会怎么样-如果Redis内存使用超出了设置的最大值会怎样"><a href="#真要打满了会怎么样-如果Redis内存使用超出了设置的最大值会怎样" class="headerlink" title="真要打满了会怎么样? 如果Redis内存使用超出了设置的最大值会怎样?"></a>真要打满了会怎么样? 如果Redis内存使用超出了设置的最大值会怎样?</h4><p>改改配置，故意把最大值设为1个byte试试</p><blockquote><p>报<code>OOM</code></p></blockquote><p>设置了maxmemory的选项，假如redis内存使用达到上限</p><p>没有加上过期时间就会导致数据写满maxmemory 为了避免类似情况，引出下一章内存淘汰策略</p><hr><h2 id="redis缓存淘汰策略"><a href="#redis缓存淘汰策略" class="headerlink" title="redis缓存淘汰策略"></a>redis缓存淘汰策略</h2><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p>如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢??如果回答yes，你自己走还是面试官送你?如果不是，那过期后到底什么时候被删除呢?？是个什么操作?</p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><blockquote><p>总结：<code>对CPU不友好</code>，用处理器性能换取存储空间（拿时间换空间）</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182355.png"></p><hr><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><blockquote><p>总结：<code>对memory不友好</code>，用存储空间换取处理器性能（拿空间换时间)</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182356.png"></p><hr><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><blockquote><p>定期<code>抽样key</code>，判断是否过期，但存在漏网之鱼</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182357.png"></p><hr><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182358.png"></p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>种类：(redis6.0.8版本)</p><ul><li>noeviction: 不会驱逐任何key</li><li>allkeys-lru: 对所有key使用LRU算法进行删除</li><li>volatile-lru: 对所有设置了过期时间的key使用LRU算法进行删除</li><li>allkeys-random: 对所有key随机删除</li><li>volatile-random: 对所有设置了过期时间的key随机删除</li><li>volatile-ttl: 删除马上要过期的key</li><li>allkeys-lfu: 对所有key使用LFU算法进行删除</li><li>volatile-lfu: 对所有设置了过期时间的key使用LFU算法进行删除</li></ul><hr><p>2个维度：</p><ul><li>过期键中筛选</li><li>所有键中筛选</li></ul><p>4个方面：</p><ul><li>LRU</li><li>LFU</li><li>random</li><li>ttl</li></ul><p>组成8个选项</p><hr><blockquote><p>你平时用哪一种？</p><p>allkeys-lru: 对所有key使用LRU算法进行删除</p></blockquote><blockquote><p>如何配置、修改？</p><p>方式一：使用配置文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182359.png"></p><hr><p>方式二：使用命令</p><p>config set maxmemory-policy allkeys-lru</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_分布式锁</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3_分布式锁"></a>3_分布式锁</h1><h2 id="分布式锁的面试题"><a href="#分布式锁的面试题" class="headerlink" title="分布式锁的面试题"></a>分布式锁的面试题</h2><blockquote><p>问题1：Redis除了拿来做缓存，你还见过基于Redis的什么用法?</p><p>答：传统五大数据类型的落地应用；做分布式锁</p></blockquote><blockquote><p>问题2：Redis做分布式锁的时候有需要注意的问题?</p></blockquote><blockquote><p>问题3：如果是Redis是单点部署的，会带来什么问题?</p><p>​            那你准备怎么解决单点问题呢?</p></blockquote><blockquote><p>问题4：集群模式下，比如主从模式，有没有什么问题呢?</p></blockquote><blockquote><p>问题5：那你简单的介绍一下Redlock吧?你简历上写redisson，你谈谈</p></blockquote><blockquote><p>问题6：Redis分布式锁如何续期?看门狗知道吗?</p></blockquote><hr><h2 id="Base案例-boot-redis"><a href="#Base案例-boot-redis" class="headerlink" title="Base案例(boot+redis)"></a>Base案例(boot+redis)</h2><blockquote><p>使用场景：<font color='red'>多个服务间保证同一时刻同一时间段内同一用户只能有一个请求(防止关键业务出现并发攻击)</font></p></blockquote><h4 id="1、建Module"><a href="#1、建Module" class="headerlink" title="1、建Module"></a>1、建Module</h4><blockquote><p>两个微服务：boot_redis01、boot_redis02</p></blockquote><h4 id="2、改POM"><a href="#2、改POM" class="headerlink" title="2、改POM"></a>2、改POM</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hhf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>boot_redis01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="3、建YML"><a href="#3、建YML" class="headerlink" title="3、建YML"></a>3、建YML</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">1111</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379 </span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）默认8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">#连接池最大阻塞等待时间（使用负值表示没有限制）默认-1</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接默认8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接默认0</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0 </span></span><br></pre></td></tr></table></figure><hr><h4 id="4、启动类"><a href="#4、启动类" class="headerlink" title="4、启动类"></a>4、启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application01.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="5、config"><a href="#5、config" class="headerlink" title="5、config"></a>5、config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证不是序列化后的乱码配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="6、controller"><a href="#6、controller" class="headerlink" title="6、controller"></a>6、controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h4><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:1111&#x2F;buy_goods</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:2222&#x2F;buy_goods</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182252.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182253.jpg"></p><p>正常访问！</p><hr><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><h3 id="1-单机版没加锁"><a href="#1-单机版没加锁" class="headerlink" title="1.单机版没加锁"></a>1.单机版没加锁</h3><blockquote><p>没有加锁，并发下数字不对，出现<code>超卖现象</code></p></blockquote><p>思考：加synchronized？加ReentrantLock？还是都可以?</p><p>答 ：视业务需求而定。synchronized加锁的话会一直进行阻塞直到获得锁，而ReentrantLock可以使用tryLock()设置获取锁的时间，如果获取不到锁可以中断做其它事情。</p><hr><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p><font color='red'>修改为2.0版本：</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-nginx分布式微服务架构"><a href="#2-nginx分布式微服务架构" class="headerlink" title="2.nginx分布式微服务架构"></a>2.nginx分布式微服务架构</h3><blockquote><p> 分布式部署后，单机锁还是出现超卖现象，需要分布式锁</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182254.png"></p><hr><h4 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h4><p>我这里使用的docker配置Nginx实现负载均衡</p><p>详细参考：<a href="https://blog.csdn.net/XJ0927/article/details/109635711">Dokcer部署Nginx</a> 与 <a href="https://blog.csdn.net/XJ0927/article/details/109501188">Nginx实现负载均衡</a></p><hr><p>下面进行测试</p><p>手动方式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182255.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182256.png"></p><p>可以发现可以轮询访问微服务。</p><hr><p>高并发模拟：模拟2000个线程同时访问微服务</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182257.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182258.png"></p><hr><p>结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182259.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182300.png"></p><p>出现重复消费问题！</p><hr><h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><blockquote><p>上redis分布式锁<code>setnx</code>：Redis具有极高的性能，且其命令对分布式锁支持友好，借助SET命令即可实现加锁处理. </p></blockquote><p>修改为3.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_LOCK_KEY = <span class="string">&quot;lock&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">    Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);<span class="comment">//setnx</span></span><br><span class="line">    <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-程序异常"><a href="#3-程序异常" class="headerlink" title="3.程序异常"></a>3.程序异常</h3><blockquote><p><font color='red'>出异常的话，可能无法释放锁， 必须要在代码层面finally释放锁 </font></p></blockquote><p>加锁解锁，lock/unlock必须同时出现并保证调用</p><h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改为4.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建           </span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);<span class="comment">//setnx   </span></span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-微服务宕机"><a href="#4-微服务宕机" class="headerlink" title="4.微服务宕机"></a>4.微服务宕机</h3><blockquote><p><font color='red'>部署了微服务jar包的机器挂了，代码层面根本没有走到finally这块， 没办法保证解锁，这个key没有被删除，需要加入一个过期时间限定key</font></p></blockquote><h4 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改为5.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建 </span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value);<span class="comment">//setnx   </span></span><br><span class="line">        stringRedisTemplate.expire(REDIS_LOCK_KEY, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-过期时间设置不能保证原子性"><a href="#5-过期时间设置不能保证原子性" class="headerlink" title="5.过期时间设置不能保证原子性"></a>5.过期时间设置不能保证原子性</h3><blockquote><p><font color='red'>设置key+过期时间分开了，必须要合并成一行具备原子性</font></p></blockquote><h4 id="解决办法-4"><a href="#解决办法-4" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改为6.0：换重载方法，同时设置过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-误释放锁"><a href="#6-误释放锁" class="headerlink" title="6.误释放锁"></a>6.误释放锁</h3><blockquote><p><font color='red'>张冠李戴，删除了别人的锁</font></p></blockquote><h4 id="解决办法-5"><a href="#解决办法-5" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改为7.0版本：对要删除的锁进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))) &#123;</span><br><span class="line">            stringRedisTemplate.delete(REDIS_LOCK_KEY);<span class="comment">//释放锁    </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-释放锁不是原子性"><a href="#7-释放锁不是原子性" class="headerlink" title="7.释放锁不是原子性"></a>7.释放锁不是原子性</h3><blockquote><p><font color='red'>finally块的判断+del删除操作不是原子性的</font></p></blockquote><h4 id="解决办法1：使用Redis事务"><a href="#解决办法1：使用Redis事务" class="headerlink" title="解决办法1：使用Redis事务"></a>解决办法1：使用Redis事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            stringRedisTemplate.watch(REDIS_LOCK_KEY); <span class="comment">//加事务，乐观锁     </span></span><br><span class="line">            <span class="keyword">if</span> (value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))) &#123;</span><br><span class="line">                stringRedisTemplate.setEnableTransactionSupport(<span class="keyword">true</span>);</span><br><span class="line">                stringRedisTemplate.multi();<span class="comment">//开始事务      </span></span><br><span class="line">                stringRedisTemplate.delete(REDIS_LOCK_KEY);</span><br><span class="line">                List&lt;Object&gt; list = stringRedisTemplate.exec();</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;  <span class="comment">//如果等于null，就是没有删掉，删除失败，再回去while循环那再重新执行删除                     </span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="comment">//如果删除成功，释放监控器，并且break跳出当前循环   </span></span><br><span class="line">            stringRedisTemplate.unwatch();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="解决办法2：使用Lua脚本"><a href="#解决办法2：使用Lua脚本" class="headerlink" title="解决办法2：使用Lua脚本"></a>解决办法2：使用Lua脚本</h4><p>Redis可以通过<code>eval命令</code>保证代码执行的原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">20</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, <span class="string">&quot;ip&quot;</span>, <span class="number">6379</span>, <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jedisPool) &#123;</span><br><span class="line">            <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Jedispool is not ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//setIfAbsent() 就是如果不存在就新建</span></span><br><span class="line">        Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!lockFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;抢锁失败，┭┮﹏┭┮&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">            <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Jedis jedis = RedisUtils.getJedis();</span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]&quot;</span> + <span class="string">&quot;then &quot;</span> + <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1])&quot;</span> + <span class="string">&quot;else &quot;</span> + <span class="string">&quot;  return 0 &quot;</span> + <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = jedis.eval(script, Collections.singletonList(REDIS_LOCK_KEY), Collections.singletonList(value));</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(result.toString())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------del REDIS_LOCK_KEY success&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------del REDIS_LOCK_KEY error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-redis续期问题"><a href="#8-redis续期问题" class="headerlink" title="8.redis续期问题"></a>8.redis续期问题</h3><blockquote><p><font color='red'>确保redisLock过期时间大于业务执行时间的问题</font></p></blockquote><p>集群+CAP对比zookeeper</p><ul><li>Redis：AP：redis异步复制造成的锁丢失， 比如:主节点没来的及把刚刚set进来这条数据给从节点，就挂了。此时如果集群模式下，就得上Redisson来解决</li><li>Zookeeper：CP</li></ul><hr><h4 id="解决办法-6"><a href="#解决办法-6" class="headerlink" title="解决办法"></a>解决办法</h4><p>redis集群环境下，我们自己写的也不OK, 直接上RedLock之Redisson落地实现</p><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Redisson <span class="title">redisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://&quot;</span> + redisHost + <span class="string">&quot;:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);</span><br><span class="line">    redissonLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redissonLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-完善"><a href="#9-完善" class="headerlink" title="9.完善"></a>9.完善</h3><p>可能出现错误：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182301.png"></p><p>是在并发多的时候就可能会遇到这种错误，可能会被重新抢占</p><p>不见得当前这个锁的状态还是在锁定，并且本线程持有</p><h4 id="解决办法-7"><a href="#解决办法-7" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/buy_goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buy_Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String value = UUID.randomUUID().toString() + Thread.currentThread().getName();</span><br><span class="line">    RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);</span><br><span class="line">    redissonLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = stringRedisTemplate.opsForValue().get(<span class="string">&quot;goods:001&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> goodsNumber = result == <span class="keyword">null</span> ? <span class="number">0</span> : Integer.parseInt(result);</span><br><span class="line">        <span class="keyword">if</span> (goodsNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> realNumber = goodsNumber - <span class="number">1</span>;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;goods:001&quot;</span>, realNumber + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你已经成功秒杀商品，此时还剩余：&quot;</span> + realNumber + <span class="string">&quot;件&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;商品已经售罄/活动结束/调用超时，欢迎下次光临&quot;</span> + <span class="string">&quot;\t 服务器端口: &quot;</span> + serverPort;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//还在持有锁的状态，并且是当前线程持有的锁再解锁   </span></span><br><span class="line">        <span class="keyword">if</span> (redissonLock.isLocked() &amp;&amp; redissonLock.isHeldByCurrentThread()) &#123;</span><br><span class="line">            redissonLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>synchronized  单机版oK，上分布式</p><p>===&gt; nginx分布式微服务 单机锁不行</p><p>===&gt;取消单机锁  上redis分布式锁setnx</p><p>===&gt; 只加了锁，没有释放锁，  出异常的话，可能无法释放锁，必须要在代码层面finally释放锁 </p><p>===&gt; 宕机了，部署了微服务代码层面根本没有走到finally这块，没办法保证解锁，这个key没有被删除，需要有lockKey的过期时间设定</p><p>===&gt; 为redis的分布式锁key，增加过期时间此外，还必须要setnx+过期时间必须同一行的原子性操作 </p><p>===&gt;必须规定只能自己删除自己的锁，你不能把别人的锁删除了,防止张冠李戴，1删2,2删3</p><p>===&gt; lua或者事务 </p><p>===&gt; redis集群环境下，我们自己写的也不OK直接上RedLock之Redisson落地实现</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_redis传统五大基本类型的落地应用</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/2-redis%E4%BC%A0%E7%BB%9F%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%90%BD%E5%9C%B0%E5%BA%94%E7%94%A8/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/2-redis%E4%BC%A0%E7%BB%9F%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%90%BD%E5%9C%B0%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="2-redis传统五大基本类型的落地应用"><a href="#2-redis传统五大基本类型的落地应用" class="headerlink" title="2_redis传统五大基本类型的落地应用"></a>2_redis传统五大基本类型的落地应用</h1><p>官网命令大全网址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.redis.cn&#x2F;commands.html</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182057.png"></p><hr><p>8大类型：</p><ol><li>String(字符类型)</li><li>Hash(散列类型)</li><li>List(列表类型)</li><li>Set(集合类型)</li><li>SortedSet(有序集合类型，简称zset)</li><li>Bitmap(位图)</li><li>HyperLogLog(统计)</li><li>GEO（地理）</li></ol><hr><p><strong>备注：</strong> </p><ul><li><font color='red'>命令不区分大小写，而key是区分大小写的</font></li><li><font color='red'>help @类型名词</font></li></ul><hr><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 最常用</span></span><br><span class="line">set key value</span><br><span class="line">get key</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 同时设置/获取多个键值（m就是more的意思）</span></span><br><span class="line">MSET key value [key value ....]</span><br><span class="line">MGET key [key ....]</span><br></pre></td></tr></table></figure><hr><h4 id="数值增减"><a href="#数值增减" class="headerlink" title="数值增减"></a>数值增减</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 递增数字</span></span><br><span class="line">INCR key</span><br><span class="line"><span class="section"># 增加指定的整数</span></span><br><span class="line">INCRBY key increment</span><br><span class="line"></span><br><span class="line"><span class="section"># 递减数值</span></span><br><span class="line">DECR key</span><br><span class="line"><span class="section"># 减少指定的整数</span></span><br><span class="line">DECRBY key decrement</span><br></pre></td></tr></table></figure><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 获取字符串长度</span></span><br><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><hr><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><font color='red'>分布式锁</font></h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># key不存在时则创建,存在则不创建</span></span><br><span class="line">setnx key value</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># </span></span><br><span class="line">set key value [<span class="string">Ex seconds</span>][<span class="symbol">PX milliseconds</span>][<span class="string">NX|XX</span>]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182058.png"></p><hr><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>商品编号、订单号采用INCR命令生成：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182059.png"></p><p>类似：点赞数+1就使用incr，踩数-1就使用decr</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182100.png"></p><blockquote><p><font color='red'>是否喜欢的文章</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182101.png"></p><hr><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><blockquote><p>对应Java中的结构：<font color='red'>Map&lt;String,Map&lt;Object,object&gt;&gt;</font></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一次设置一个字段值</span></span><br><span class="line">HSET key field value</span><br><span class="line"><span class="section"># 一次获取一个字段值</span></span><br><span class="line">HGET key field</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一次设置多个字段值</span></span><br><span class="line">HMSET key field value [field value ...]</span><br><span class="line"><span class="section"># 一次获取多个字段值</span></span><br><span class="line">HMGET key field [field ....]</span><br><span class="line"></span><br><span class="line"><span class="section"># 获取所有字段值</span></span><br><span class="line">hgetall key</span><br><span class="line"><span class="section"># 获取某个key内的全部数量</span></span><br><span class="line">hlen key</span><br><span class="line"><span class="section"># 删除某个key的一个字段</span></span><br><span class="line">hdel key field</span><br></pre></td></tr></table></figure><hr><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>购物车早期，当前小中厂可用：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182102.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182103.png"></p><p>实现方案：以用户id作为hash结构中的key，新增商品时使用hset为用户key增加一个字段，字段值就是商品数量，同样如果再增加一件商品，就再添加一个field，而如果对添加的商品进行数量+1就使用hincrby增加相应的数量，需要全选商品时，就使用hgetall，购物车商品的数量显示就使用hlen。</p><hr><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><blockquote><p>其实就是一个双向链表：有序可重复</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 向列表左边添加元素</span></span><br><span class="line">LPUSH key value [value ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 向列表右边添加元素</span></span><br><span class="line">RPUSH key value [value ....]</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看列表</span></span><br><span class="line">LRANGE key start stop</span><br><span class="line"><span class="section"># 获取列表中元素的个数</span></span><br><span class="line">LLEN key</span><br></pre></td></tr></table></figure><hr><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>微信文章订阅公众号：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182104.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182105.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182106.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182107.png"></p><hr><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><blockquote><p>无序不可重复</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 添加元素</span></span><br><span class="line">SADD key member[member ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 删除元素</span></span><br><span class="line">SREM key member [member ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 获取集合中的所有元素</span></span><br><span class="line">SMEMBERS key</span><br><span class="line"></span><br><span class="line"><span class="section"># 判断元素是否在集合中</span></span><br><span class="line">SISMEMBER key member</span><br><span class="line"></span><br><span class="line"><span class="section"># 获取集合中的元素个数</span></span><br><span class="line">SCARD key</span><br></pre></td></tr></table></figure><hr><p>随机取一个元素</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 从集合中随机弹出一个元素，元素不删除</span></span><br><span class="line">SRANDMEMBER key [数字]</span><br><span class="line"></span><br><span class="line"><span class="section"># 从集合中随机弹出一个元素，出一个删一个</span></span><br><span class="line">SPOP key[数字]</span><br></pre></td></tr></table></figure><hr><p>集合运算</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 集合的差集运算A-B：属于A但不属于B的元素构成的集合</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 集合的交集运算A∩B：属于A同时也属于B的共同拥有的元素构成的集合</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 集合的并集运算AUB：属于A或者属于B的元素合并后的集合</span></span><br><span class="line">SUNION key [key ...]</span><br></pre></td></tr></table></figure><hr><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>微信抽奖小程序：</font></p><ul><li><p>1 用户ID，立即参与按钮：sadd key 用户ID</p></li><li><p>2 显示已经有多少人参与了上图23208人参加：SCARD key</p></li><li><p>3 抽奖(从set中任意选取N个中奖人)：</p><p>​     SRANDMEMBER key 2   随机抽奖2个人，元素不删除</p><pre><code> SPOP key3            随机抽奖3个人，元素会删除 </code></pre></li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182108.png"></p><hr><blockquote><p><font color='red'>微信朋友圈点赞：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182109.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182110.png"></p><hr><blockquote><p><font color='red'>微博好友关注社交关系：</font></p></blockquote><p>共同关注的人：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182111.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182112.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182113.png"></p><hr><p>我关注的人也关注他(大家爱好相同)：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182114.png"></p><hr><blockquote><p><font color='red'>QQ内推可能认识的人：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182115.png"></p><hr><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><blockquote><p>向有序集合中加入一个元素和该元素的分数</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 添加元素</span></span><br><span class="line">ZADD key score member [score member ...]</span><br><span class="line"></span><br><span class="line"><span class="section"># 按照元素分数从小到大的顺序 返回索引从start到stop之间的所有元素</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="section"># 获取元素的分数</span></span><br><span class="line"> ZSCORE key member</span><br><span class="line"> </span><br><span class="line"> # 删除元素</span><br><span class="line"> ZREM key member [member ...]</span><br><span class="line"> </span><br><span class="line"> # 获取指定分数范围的元素</span><br><span class="line"> ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"> </span><br><span class="line"> # 增加某个元素的分数</span><br><span class="line"> ZINCRBY key increment member</span><br><span class="line"> </span><br><span class="line"> # 获取集合中元素的数量</span><br><span class="line"> ZCARD key</span><br><span class="line"> </span><br><span class="line"> # 获得指定分数范围内的元素个数</span><br><span class="line"> ZCOUNT key min max</span><br><span class="line"> </span><br><span class="line"> # 按照排名范围删除元素</span><br><span class="line"> ZREMRANGEBYRANK key start stop</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取元素的排名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 从小到大</span></span><br><span class="line">ZRANK key member</span><br><span class="line"><span class="section"># 从大到小</span></span><br><span class="line">ZREVRANK key member</span><br></pre></td></tr></table></figure><hr><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a><font color='red'>应用场景</font></h4><blockquote><p><font color='red'>根据商品销售对商品进行排序显示：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182116.png"></p><hr><blockquote><p><font color='red'>抖音热搜：</font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182117.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217182118.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_安装Redis</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/1-%E5%AE%89%E8%A3%85Redis/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Redis/1-%E5%AE%89%E8%A3%85Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-安装Redis"><a href="#1-安装Redis" class="headerlink" title="1_安装Redis"></a>1_安装Redis</h1><p>官网地址：<a href="https://redis.io/">https://redis.io/</a></p><p>中文官网地址：<a href="http://www.redis.cn/">http://www.redis.cn/</a></p><blockquote><p>说明：安全Bug按照官网提示，升级成为6.0.8</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_AQS</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/3-AQS/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/3-AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="3-AQS"><a href="#3-AQS" class="headerlink" title="3_AQS"></a>3_AQS</h1><p>前置知识:</p><ul><li>公平锁和非公平锁</li><li>可重入锁</li><li>LockSupport</li><li>自旋锁</li><li>数据结构之链表</li><li>设计模式之模板设计模式</li></ul><hr><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>字面意思：抽象的队列同步器</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181731.png"></p><p>源代码：AbstractQueuedSynchronizer 简称为AQS</p><blockquote><p>技术翻译：是用来构建锁或者其它同步器组件<code>的重量级基础框架及整个JUC体系的基石</code>，通过内置的<code>FIFO队列</code>来完成资源获取线程的排队工作，并通过一个<code>int类变量</code>表示持有锁的状态。</p><p>这里的同步器组件指CountDownLatch、Semaphore、ReentrantLock、ReentrantReadWriteLock 等</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181732.png">  </p><p><strong>锁和同步器的关系</strong></p><blockquote><p>锁：面向锁的<code>使用者</code>(定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可)</p><p>同步器：面向锁的<code>实现者</code>(比如Java并发大神Douglee，提出统一规 范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。)</p></blockquote><hr><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><p><font color='red'>加锁会导致阻塞</font>，有阻塞就需要排队，实现排队必然需要有某种形式的队列来进行管理</p><p>抢到资源的线程直接使用办理业务，抢占不到资源的线程的必然涉及一种<code>排队等候机制</code>，抢占资源失败的线程继续去等待(类似办理窗口都满了，暂时没有受理窗口的顾客只能去<code>候客区排队等候</code>)，仍然保留获取锁的可能且获取锁流程仍在继续(候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。</p><p>既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢? </p><p>如果共享资源被占用，<code>就需要一定的阻塞等待唤醒机制来保证锁分配</code>。这个机制主要用的是<strong>CLH队列</strong>的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是<strong>AQS</strong>的抽象表现。它将请求共享资源的线程封装成队列的 <font color='red'>结点(Node)</font>，通过<strong>CAS、自旋以及LockSuport.park()**的方式，维护</strong>state变量**的状态，使并发达到同步的效果。                 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181732.png"></p><hr><h2 id="AQS初识"><a href="#AQS初识" class="headerlink" title="AQS初识"></a>AQS初识</h2><p>官网解释：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181733.png"></p><p>有阻塞就需要排队，实现排队必然需要队列</p><p>AQS使用一个volatile的<code> int类型的成员变量state</code>来表示同步状态，通过内置的<code> FIFO队列</code>来完成资源获取的排队工作将每条要去抢占资源的线程封装成 一个 <font color='red'>Node节点</font> 来实现锁的分配，通过<strong>CAS</strong>完成对<strong>State</strong>值的修改。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181734.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181735.png"></p><hr><h2 id="AQS内部体系架构"><a href="#AQS内部体系架构" class="headerlink" title="AQS内部体系架构"></a>AQS内部体系架构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181736.png"></p><hr><h3 id="AQS自身"><a href="#AQS自身" class="headerlink" title="AQS自身"></a>AQS自身</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181734.png"></p><h4 id="AQS的int变量："><a href="#AQS的int变量：" class="headerlink" title="AQS的int变量："></a>AQS的int变量：</h4><blockquote><p>AQS的同步状态State成员变量</p><p>类比，银行办理业务的受理窗口状态：</p><ul><li>零就是没人，自由状态可以办理</li><li>大于等于1，有人占用窗口，等着去</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The synchronization state.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><hr><h4 id="AQS的CLH队列"><a href="#AQS的CLH队列" class="headerlink" title="AQS的CLH队列"></a>AQS的CLH队列</h4><blockquote><p>CLH队列（三个大牛的名字组成），为一个<code>双向队列</code></p><p>类比，银行侯客区的等待顾客</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181737.png"></p><hr><p>小总结：</p><ul><li><font color='red'>有阻塞就需要排队，实现排队必然需要队列</font></li><li>state变量+CLH双端Node队列</li></ul><hr><h3 id="内部类Node（Node类在AQS类内部）"><a href="#内部类Node（Node类在AQS类内部）" class="headerlink" title="内部类Node（Node类在AQS类内部）"></a>内部类Node（Node类在AQS类内部）</h3><h4 id="Node的int变量"><a href="#Node的int变量" class="headerlink" title="Node的int变量"></a>Node的int变量</h4><blockquote><p>Node的等待状态<code>waitState</code>成员变量（注意与status状态区分，status表示同步状态）</p><p>类比，等候区其它顾客(其它线程)的等待状态</p><p>​         队列中每个排队的个体就是一个Node.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure><hr><h4 id="Node此类的讲解"><a href="#Node此类的讲解" class="headerlink" title="Node此类的讲解"></a>Node此类的讲解</h4><p>内部结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181738.png" alt="17"></p><hr><p>属性说明：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181739.png"></p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181740.png"></p><hr><h2 id="从我们的ReentrantLock开始解读AQS"><a href="#从我们的ReentrantLock开始解读AQS" class="headerlink" title="从我们的ReentrantLock开始解读AQS"></a>从我们的ReentrantLock开始解读AQS</h2><blockquote><p>Lock接口的实现类，基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock();</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181734.png"></p><h4 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181741.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181742.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181743.png"></p><h4 id="从最简单的lock方法开始看看公平和非公平"><a href="#从最简单的lock方法开始看看公平和非公平" class="headerlink" title="从最简单的lock方法开始看看公平和非公平"></a>从最简单的lock方法开始看看公平和非公平</h4><p>通过ReentrantLock的源码来讲解公平锁和非公平锁 可以明显看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件:<code>hasQueuedPredecessors()</code>，</p><p>hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181744.png"></p><h4 id="非公平锁走起，方法lock"><a href="#非公平锁走起，方法lock" class="headerlink" title="非公平锁走起，方法lock()"></a>非公平锁走起，方法lock()</h4><p>对比公平锁和非公平锁的tryAcqure()方法的实现代码， 其实差别就在于非公平锁获取锁时比公平锁中少了一个判断!hasQueuedPredecessors() </p><p>hasQueuedPredecessors()中判断了是否需要排队，导致公平锁和非公平锁的差异如下: </p><ul><li>公平锁: 公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中;</li><li>非公平锁: 不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程在unpark(), 之后还是需要竞争锁(存在线程竞争的情况下) </li></ul><h4 id="AQS源码深度分析走起"><a href="#AQS源码深度分析走起" class="headerlink" title="AQS源码深度分析走起"></a>AQS源码深度分析走起</h4><p>需要的快捷键：</p><ul><li>ctrl + alt + B：跳到实现类</li><li>ctrl + alt + 左箭头/右箭头：回到上次操作/回到下一次操作</li></ul><p><strong>公平锁：</strong> 从lock()开始，依次跳…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>非公平锁：</strong> 从lock()开始，依次跳…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是公平还是非公平，最终都会走向<code>tryAcquire</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181745.png"></p><hr><blockquote><p>带入一个银行办理业务的案例来模拟我们的AQS如何进行线程的管理和通知唤醒机制 ：</p><p>3个线程模拟3个来银行网点，受理窗口办理业务的顾客</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> Created in 2021-01-25 16:43</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AQSDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//非公平锁</span></span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A顾客就是第一个顾客，此时受理窗口没有任何人，A可以直接去办理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----A thread come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MINUTES.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个顾客，第二个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时B只能等待，</span></span><br><span class="line">        <span class="comment">// 进入候客区</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----B thread come in&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三个顾客，第三个线程---》由于受理业务的窗口只有一个(只能一个线程持有锁)，此时C只能等待，</span></span><br><span class="line">        <span class="comment">// 进入候客区</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----C thread come in&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="lock方法分析"><a href="#lock方法分析" class="headerlink" title="lock方法分析"></a>lock方法分析</h5><p>A顾客过来办理业务，由于是非公平方式，走下面这条路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于state的状态确实为0，和CAS预估值一样，CAS操作成功，将state值改为1，同时将Node节点中的线程设置为当前线程A</p><p>初始状态：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181746.png"></p><p>第一个顾客来之后：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181747.png"></p><hr><h5 id="acquire-方法分析"><a href="#acquire-方法分析" class="headerlink" title="acquire()方法分析"></a>acquire()方法分析</h5><p>第二个顾客过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181748.png"></p><p>此时state的状态值为1，代表锁已经被占有，CAS失败，走<code>acquire()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先走<code>tryAcquire()</code>方法，如果成功就返回<code>ture</code>，取反返回<code>false</code>，就不走后面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread(); <span class="comment">//获取当前线程：此时是顾客B</span></span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">//获取state状态，此时值为1</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>下面对这个类中的两个判断进行分别解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况1：顾客B此时走入大厅，发现柜台有人在办理业务，需要去候客区排队，刚准备坐下时，此时顾客A办理完成，就直接去窗口办理：判断当前state状态是否为0，如果为0，进行CAS操作，将state设置为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//附上state+1的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况2：顾客A办理完，准备起身走时，发现还有件事忘记了办理，又坐下进行办理：判断当前线程是否为线程A，如果是，将state的状态值+1，（<font color='red'>可重入锁的实现</font>）</p><p>总结：这两种情形都是可以获取到锁，即走<code>tryAcquire()</code>方法时返回true</p><hr><h5 id="addWaiter方法分析"><a href="#addWaiter方法分析" class="headerlink" title="addWaiter方法分析"></a>addWaiter方法分析</h5><p>但，此时两种情形都不满足：即返回<code>false</code>，取反为<code>true</code>，继续走后面的方法<code>addWaiter(Node.EXCLUSIVE)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181749.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);  <span class="comment">//当前线程为B，节点为null</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail; <span class="comment">//tail为null</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将tail节点赋给pred节点，此时就为null，不会进入if，走入队方法<code>enq(node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123; <span class="comment">//此时node为B顾客</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>注意：这是一个自旋操作，</font></p><p>tail为空节点，会进入<code>if</code>判断，通过CAS操作设置<code>head</code>头结点的指向Node空节点（此时Node节点即图中的傀儡节点，不储存数据，仅用于占位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123; <span class="comment">//此时传入的update为一个Node空节点</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181750.png"></p><p>然后再将<code>head</code>头结点的执行赋给<code>tail</code>尾结点的指向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail &#x3D; head;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181751.png"></p><p>完成后，不会走下面的else 分支。由于是自旋，继续从头开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;<span class="comment">//此时tail执行空节点，即不为null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;<span class="comment">//将B线程的前指针指向t节点（这里即tail节点）所执行的节点（这里即空节点）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tail</code>不为null，走<code>else</code>分支，</p><p>首先：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.prev &#x3D; t;&#x2F;&#x2F;将B线程的前指针指向空节点</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181752.png"></p><p>然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSetTail(t, node) &#x2F;&#x2F;设置尾结点：将tail尾结点所执向的节点改为执向顾客B</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181753.png"></p><p>然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.next &#x3D; node; &#x2F;&#x2F;将空节点的next指针指向顾客B</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181754.png"></p><p>最后：<code>return</code>结束自旋！</p><hr><p>此时，第三个顾客C，也来办理业务，同样也没有抢到锁，需要走到<code>addWaiter(Node.EXCLUSIVE)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail; <span class="comment">//tail节点执行顾客B</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，tail节点执行顾客B，赋给pred节点，所以pred节点也执行B，即pred不为null，需要进入<code>if</code>判断</p><p>首先：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.prev &#x3D; pred;&#x2F;&#x2F;将顾客C的头指针指向顾客B</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181755.png"></p><p>然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSetTail(pred, node)&#x2F;&#x2F;设置尾结点指向顾客C</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181756.png"></p><p>最后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred.next &#x3D; node;&#x2F;&#x2F;将顾客B的后指针指向顾客C</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181757.png"></p><p>发现没有顾客C没有走<code>enq(node)</code>方法，也就是说此时已有哨兵节点，不需要再去创建哨兵节点进行占位。</p><p>若还有其他顾客D、E….走这条路依然是这样。</p><hr><h5 id="acquireQueued方法分析"><a href="#acquireQueued方法分析" class="headerlink" title="acquireQueued方法分析"></a>acquireQueued方法分析</h5><p>虽然顾客B和顾客C依次都入了队，但是，没有真正的阻塞，下面开始执行<code>acquireQueued()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//此时传入进的node为顾客B</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//先不管这个，这是防止中途打断放弃的设置</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>这里又是一个自旋</font></p><p>首先：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//设置p为哨兵节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//附上源码</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">    Node p = prev;<span class="comment">//prev为头指针，将其指向的节点付给p</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后：<code>p=head</code>相等，进入<code>tryAcquire</code>方法，再次尝试获取锁，假设现在依然抢不到锁，不能继续往下走，进入下一个<code>if</code>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;<span class="comment">//此时pred为哨兵节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//此时为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//-1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//进入此语句</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&#x2F;&#x2F;设置waitStatus为-1</span><br></pre></td></tr></table></figure><p>由于是自旋，再次进入<code>acquireQueued</code>，尝试获取锁，获取失败，同理又进入<code>shouldParkAfterFailedAcquire</code>方法，但此时<code>waitStatus</code>值为1，所以进入下列<code>if</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p><code>shouldParkAfterFailedAcquire</code>返回为<code>true</code>，继续向下执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时：真正被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>这个时候，才调用<code>park()</code>方法，将线程进行阻塞！！！</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181758.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181759.png"></p><p>顾客C同理，都被阻塞在这里，直到拿到许可证，才可被依次放行</p><hr><h5 id="unlock-方法"><a href="#unlock-方法" class="headerlink" title="unlock()方法"></a>unlock()方法</h5><p>此时顾客A办理完业务，准备释放锁，走到<code>tryRelease</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;<span class="comment">//此时c就为0</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">//将当前拥有锁的线程设置为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c); <span class="comment">//同时设置state值为0</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回<code>true</code>，进入<code>release</code>方法的if语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;<span class="comment">//将头节点赋给h</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)<span class="comment">//h的waitStarus状态值为-1</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>unparkSuccessor(h)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;  <span class="comment">//此时为-1</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">//进入，通过CAS操作将状态设置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">//upark唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181800.png"></p><hr><p>此时，顾客B和顾客C正挂起阻塞着，这里unpark后，相当于给了一张许可证</p><p><font color='red'>顾客B来个回马枪！！！</font></p><p>顾客B再次来到这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">//顾客B</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试获取锁<code>tryAcquire</code>,来到<code>nonfairTryAcquire</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时state的状态值为0，顾客B进入<code>if</code>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将锁的线程设置当前线程B，返回<code>true</code></p><hr><p>即进入下列<code>if</code>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    failed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setHead(node);<span class="comment">//设置头节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//附上源码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node; <span class="comment">//将头节点指向顾客B</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">//将顾客B的线程设置为null</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;<span class="comment">//前指针设置为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181801.png"></p><p>然后：<font color='red'>将哨兵节点的后指针设置为null，此时哨兵节点等待垃圾回收</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181802.png"></p><p>此时原顾客B节点就成为新的哨兵节点</p><p>同理，顾客C出队也是如此操作！！！</p><hr><h2 id="AQS考点"><a href="#AQS考点" class="headerlink" title="AQS考点"></a>AQS考点</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 第一个考点我相信你应该看过源码了，那么AQS里面有个变量叫State，它的值有几种？</span></span><br><span class="line"></span><br><span class="line">答 3个状态：没占用是0，占用了是1，大于1是可重入锁</span><br><span class="line"></span><br><span class="line"><span class="section"># 第二个考点 如果AB两个线程进来了以后，请问这个总共有多少个Node节点？</span></span><br><span class="line">答案是3个</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> AQS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_LockSupport</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/2-LockSupport/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/2-LockSupport/</url>
      
        <content type="html"><![CDATA[<h1 id="2-LockSupport"><a href="#2-LockSupport" class="headerlink" title="2_LockSupport"></a>2_LockSupport</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>官方解释：LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><p>一句话：LockSupport中的park()和unpark()的作用分别是<code>阻塞线程</code>和<code>解除阻塞线程</code></p></blockquote><hr><h2 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h2><p>线程等待唤醒机制(wait/notify)</p><h4 id="3种让线程等待和唤醒的方法"><a href="#3种让线程等待和唤醒的方法" class="headerlink" title="3种让线程等待和唤醒的方法"></a>3种让线程等待和唤醒的方法</h4><h5 id="方式1-使用synchronized"><a href="#方式1-使用synchronized" class="headerlink" title="方式1:  使用synchronized"></a>方式1:  使用synchronized</h5><blockquote><p>使用Object中的<code>wait()</code>方法让线程等待， 使用Object中的<code>notify()</code>方法唤醒线程</p></blockquote><p>正常情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedWaitNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo.synchronizedWaitNotify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181558.png"></p><hr><p>异常情况1：wait方法和notify方法，两个都去掉同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedWaitNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            synchronized (objectLock) &#123;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            synchronized (objectLock) &#123;</span></span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo.synchronizedWaitNotify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181559.png"></p><p>抛出异常！</p><blockquote><p>原因：synchronized是关键字属于JVM层面。monitorenter(底层是通过monitor对象来完成,其实wait/notify等方法也依赖monitor对象只能在同步块或方法中才能调用wait/notify等方法)</p></blockquote><hr><p>异常情况2：将notify放在wait方法前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181600.png"></p><p>B线程先notify后，A线程后使用wait会出现另一个线程一直处于等待状态</p><hr><p><strong>小总结</strong></p><ul><li>wait和notify方法必须要在同步块或者方法里面且成对出现使用</li><li>先wait后notify才OK</li></ul><hr><h5 id="方式2：使用-lock"><a href="#方式2：使用-lock" class="headerlink" title="方式2：使用 lock"></a>方式2：使用 lock</h5><blockquote><p>Condition接口中的<code>await</code>后<code>signal</code>方法实现线程的等待和唤醒</p></blockquote><p>正常情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//唤醒</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181601.png"></p><hr><p>异常情况1：不进行lock加锁、放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                lock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//                lock.unlock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181602.png"></p><p>同样也抛出异常！</p><hr><p>异常情况2：先unlock释放锁，再lock加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object objectLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//TODO 一直卡在这里等待被唤醒</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181603.png"></p><p>B线程先进行释放锁，A线程再加锁，线程一直处于等待状态！</p><hr><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>传统的synchronized和Lock实现等待唤醒通知的约束</p><p>必须满足下列条件：</p><ul><li>线程先要获得并持有锁，必须在锁块（synchronized或lock）中</li><li>必须要先等待后唤醒，线程才能够被唤醒</li></ul></blockquote><hr><h5 id="方式3：使用LockSupport"><a href="#方式3：使用LockSupport" class="headerlink" title="方式3：使用LockSupport"></a>方式3：使用LockSupport</h5><blockquote><p>LockSupport类中的<code>park</code>等待和<code>unpark</code>唤醒</p></blockquote><h6 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h6><blockquote><p>通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作</p></blockquote><p>官网解释：LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><p>LockSupport类使用了一种名为Permit(许可）的概念来做到阻塞和唤醒线程的功能，<code>每个线程都有一个许可(permit)</code>,permit只有两个值1和零，默认是零。可以把许可看成是一种(0,1)信号量(Semaphore），但与Semaphore不同的是，许可的累加上限是1。 </p><hr><h6 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h6><p>阻塞：park()/park(Object blocker)：阻塞当前线程/阻塞传入的具体线程</p><p>permit默认是0，所以一开始调用park()方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时,park方法会被唤醒，然后会将permit再次设置为0并返回。 </p><p>唤醒：unpark(Thread thread)：唤醒处于阻断状态的指定线程</p><p>调用unpark(thread)方法后，就会将thread线程的许可permit设置成1(注意多次调用unpark方法，不会累加，permit值还是1)会自动唤醒thread线程，即之前阻塞中的LockSupport.park()方法会立即返回。</p><hr><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>正常情况：无锁块要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs.locksupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LockSupport：俗称 锁中断</span></span><br><span class="line"><span class="comment"> * 以前的两种方式：</span></span><br><span class="line"><span class="comment"> * 1.以前的等待唤醒通知机制必须synchronized里面有一个wait和notify</span></span><br><span class="line"><span class="comment"> * 2.lock里面有await和signal</span></span><br><span class="line"><span class="comment"> * 这上面这两个都必须要持有锁才能干</span></span><br><span class="line"><span class="comment"> * LockSupport它的解决的痛点</span></span><br><span class="line"><span class="comment"> * 1.LockSupport不用持有锁块，不用加锁，程序性能好，</span></span><br><span class="line"><span class="comment"> * 2.先后顺序，不容易导致卡死</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;come  in....&quot;</span>);</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程...等待被放行</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待3s，让t2线程发放许可证</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181604.png"></p><hr><p>之前错误的先唤醒后等待，LockSupport照样支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;come  in....&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            LockSupport.park();<span class="comment">//阻塞当前线程...等待被放行</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒....&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181605.png"></p><p>发现t1线程并没有进入执行lock方法（此时它已有许可证）</p><hr><h6 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h6><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根结底，LockSupport调用的Unsafe中的<code>native代码</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockSupport提供park()和unpark()方法实现<code>阻塞线程</code>和<code>解除线程阻塞</code>的过程：</p><ul><li>LockSupport和每个使用它的线程都有一个许可(permit)关联。permit相当于1，0的开关，默认是0。</li><li>调用一次unpark就加1变成1，<code>调用一次park会消费permit，也就是将1变成0</code>，同时park立即返回。</li><li>如再次调用park会变成阻塞(因为permit为零了会阻塞在这里，一直到permit变为1)，这时调用unpark会把permit置为1。</li><li>每个线程都有一个相关的permit, <code>permit最多只有一个</code>，重复调用unpark也不会积累凭证。</li></ul><p>形象的理解：</p><ul><li>线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。</li><li>当调用park方法时 ，如果有凭证，则会直接消耗掉这个凭证然后正常退出;  如果无凭证，就必须阻塞等待凭证可用;</li><li>而unpark则相反，它会增加一个凭证，但凭证最多只能有1个，累加无效。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;come  in....&quot;</span>);</span><br><span class="line">            <span class="comment">//消耗一张凭证</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="comment">//TODO 没有凭证,继续等待.....</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----&quot;</span> + <span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO 发放凭证：最多为1</span></span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            </span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181606.png"></p><p>此时虽然unpark了两次，但是permit许可证最多为1，所以第一次park消费掉凭证，第二次park时，许可证为0，阻塞等待。</p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 面试题</span></span><br><span class="line"><span class="section"># 为什么可以先唤醒线程后阻塞线程?</span></span><br><span class="line">因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。</span><br><span class="line"></span><br><span class="line"><span class="section"># 为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</span></span><br><span class="line">因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证;而调用两次park却需要消费两个凭证，证不够，不能放行。</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> AQS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LockSupport </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_可重入锁</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%B8%89%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/AQS/1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="1_可重入锁"></a>1_可重入锁</h1><blockquote><p><strong>可重入锁：</strong> 又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提：<code>锁对象得是同一个对象</code>)，不会因为之前已经获取过还没释放而阻塞。</p><p>Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p></blockquote><p>类似于家里面的大门,进入之后可以进入厕所、厨房等</p><hr><p>“可重入锁”这四个字分开来解释:</p><ul><li>可：可以。</li><li>重：再次。</li><li>入：进入</li><li>锁：同步锁</li><li>进入什么：进入同步域（即同步代码块/方法或显式锁锁定的代码）</li></ul><blockquote><p>一句话：一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁</p></blockquote><hr><h2 id="可重入锁种类"><a href="#可重入锁种类" class="headerlink" title="可重入锁种类"></a>可重入锁种类</h2><h3 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h3><blockquote><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁</p></blockquote><p>同步块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 可重入锁:可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。</span></span><br><span class="line"><span class="comment"> * 在一个synchronized修饰的方法或代码块的内部</span></span><br><span class="line"><span class="comment"> * 调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 10:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">static</span> Object objectLockA = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLockA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------外层调用&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectLockA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------中层调用&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (objectLockA) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;------内层调用&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181425.png"></p><hr><p>同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 10:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLock2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====外层&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====中层&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====内层&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReEnterLock2().m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181426.png"></p><hr><h4 id="Synchronized的重入的实现机理"><a href="#Synchronized的重入的实现机理" class="headerlink" title="Synchronized的重入的实现机理"></a>Synchronized的重入的实现机理</h4><blockquote><p>每个锁对象拥有一个<code>锁计数器</code>和一个指向<code>持有该锁的线程</code>的指针</p></blockquote><p>当执行<code>monitorenter</code>时,如果目标锁对象的计数器为零,那么说明它没有被其他线程持有,Java虚拟机会将该锁对象</p><p>的持有线程设置为当前线程,并且将其计数器加1,否则需要等待,直至持有线程释放该锁</p><p>当执行<code>monitorexit</code>时,Java虚拟机则锁对象的计数器减1。计数器为零代表锁已经被释放</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181427.png"></p><p>说明：第一个<code>monitorexit</code>是在方法执行完成时使用，第二个<code>monitorexit</code>是在发生异常时，能够保证锁的自动释放。</p><hr><h3 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h3><blockquote><p>显式锁（即Lock）也有ReentrantLock这样的可重入锁。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 10:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLock3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=======外层&quot;</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;=======内层&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181428.png"></p><p>发现，同一个线程可以再次获取、释放同一把锁。</p><hr><p>那如果现在加锁释放锁的次数不匹配：加锁两次，释放一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aqs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-25 10:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReEnterLock3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//加锁两次</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=======外层&quot;</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;=======内层&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//只释放一次</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 thread----外层调用lock&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217181429.png"></p><p>由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。</p><p><font color='orange'>正常情况，加锁几次就要解锁几次</font></p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第三季_周阳老师 </category>
          
          <category> AQS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可重入锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github学习</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Github%20%E5%AD%A6%E4%B9%A0/Github%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Github%20%E5%AD%A6%E4%B9%A0/Github%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Github学习"><a href="#Github学习" class="headerlink" title="Github学习"></a>Github学习</h1><p>​    使用 Github 优秀框架 + 源码 提升自己</p><h2 id="常用词含义"><a href="#常用词含义" class="headerlink" title="常用词含义"></a>常用词含义</h2><ul><li>watch：会持续收到该项目的动态</li><li>fork：复制某个仓库到自己的 Github 仓库中</li><li>star：可以理解为点赞</li><li>clone：将项目下载至本地 [ git clone xxxx]</li><li>follow：关注你感兴趣的作者，会收到他们的动态</li></ul><hr><h2 id="in-关键字限制搜索范围"><a href="#in-关键字限制搜索范围" class="headerlink" title="in 关键字限制搜索范围"></a>in 关键字限制搜索范围</h2><p><strong>公式：</strong><code>XXX关键字 in:name 或 description 或 readme</code></p><ul><li>xxx in:name [ 项目名称 ] 含有XXX的</li><li>xxx in:description [ 项目描述 ] 含有XXX的</li><li>xxx in:readme [ 项目的readme文件 ] 中包含XXX的</li><li>组合使用<ul><li>xxx in:name,readme 项目的名称和 readme 中包含 xxx 的</li></ul></li></ul><hr><h2 id="stars-或-fork-数量关键字查找"><a href="#stars-或-fork-数量关键字查找" class="headerlink" title="stars 或 fork 数量关键字查找"></a>stars 或 fork 数量关键字查找</h2><p><strong>公式：</strong></p><ul><li><code>xxx关键字 stars 通配符</code> :&gt; 或者 :&gt;=</li><li>区间范围数字： <code>stars:数字1..数字2</code></li></ul><p><strong>案例:</strong></p><ul><li><p>查找 stars 数大于等于 5000 的 Springboot 项目：springboot stars:&gt;=5000</p></li><li><p>查找 forks 数在 1000~2000 之间的 springboot 项目：springboot forks:1000..5000</p></li><li><p>组合使用</p><ul><li>查找 star 大于1000，fork 数在 500 到 1000：<code>springboot stars:&gt;1000 forks:500..1000</code></li></ul></li></ul><hr><h2 id="awesome-加强搜索"><a href="#awesome-加强搜索" class="headerlink" title="awesome 加强搜索"></a>awesome 加强搜索</h2><p><strong>公式：</strong> <code>awesome 关键字</code>：</p><p>awesome 系列，一般用来收集 [ 学习、工具、书籍类相关的项目 ]</p><ul><li>搜索优秀的 redis 相关的项目，包括框架，教程等 awesome redis</li></ul><hr><h2 id="高亮显示某行代码"><a href="#高亮显示某行代码" class="headerlink" title="高亮显示某行代码"></a>高亮显示某行代码</h2><ul><li>一行：地址后面紧跟 #L10<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13</code></li></ul></li><li>多行：地址后面紧跟 #Lx - #Ln<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13-L30</code></li></ul></li></ul><hr><h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><ul><li>使用英文字母 <code>t</code> ,开启项目内搜索</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217142128.png"></p><hr><h2 id="搜索某个地区内的大佬"><a href="#搜索某个地区内的大佬" class="headerlink" title="搜索某个地区内的大佬"></a>搜索某个地区内的大佬</h2><ul><li>location：地区</li><li>language：语言</li><li>例如：<code>location:beijing language:java</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11_死锁编码及快速定位</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/11-%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/11-%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="11-死锁编码及快速定位"><a href="#11-死锁编码及快速定位" class="headerlink" title="11_死锁编码及快速定位"></a>11_死锁编码及快速定位</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141338.png"></p><h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><ul><li>系统资源不足</li><li>进程运行推进的顺序不对</li><li>资源分配不当</li></ul><h2 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h2><ul><li>互斥<ul><li>解决方法：把互斥的共享资源封装成可同时访问</li></ul></li><li>占有且等待<ul><li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li></ul></li><li>非抢占式<ul><li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li></ul></li><li>循环等待<ul><li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li></ul></li></ul><h2 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************** 资源类 **************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有锁：&quot;</span> + lockA);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 等待获取锁&quot;</span> + lockB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 已获得锁&quot;</span> + lockB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************** 测试类 ****************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA,lockB),<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB,lockA),<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，main线程无法结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t2 自己持有锁：lockB</span><br><span class="line">t1 自己持有锁：lockA</span><br><span class="line">t1 等待获取锁lockB</span><br><span class="line">t2 等待获取锁lockA</span><br></pre></td></tr></table></figure><hr><h2 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用 jps 命令查看运行的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141339.png"></p><p>在使用 jstack 查看堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack  7560   # 后面参数是 jps输出的该类的pid</span><br></pre></td></tr></table></figure><p>得到的结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141340.png"></p><p>通过查看最后一行，我们看到 Found 1 deadlock，即存在一个死锁</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10_线程池</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/10-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/10-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10_线程池"></a>10_线程池</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现 Callable 接口</p><ul><li>实现 Runnable 接口</li><li>实现 Callable 接口</li><li>实例化 Thread 类</li><li>使用 线程池 获取</li></ul><hr><h2 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h2><blockquote><p>Callable 接口，是一种让线程执行完成后，<code>[ 能够返回结果的 ]</code></p></blockquote><p>在说到 Callable 接口的时候，我们不得不提到 Runnable 接口 [  两种写法 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 实现Runnable接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***** 实现 Runnable 接口*******&#x2F;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(&quot;线程方法体&quot;);</span><br><span class="line">&#125;,&quot;t1&quot;).start();</span><br></pre></td></tr></table></figure><p>实现 Runnable 接口的时候，需要重写 run 方法，也就是线程在启动的时候，会自动调用的方法</p><hr><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>同理，我们实现 Callable 接口，也需要实现 call 方法，但是这个时候我们还需要有返回值，<font color='red'>这个Callable 接口的应用场景一般就在于批处理业务，比如 [ 转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败 ]</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Callable有返回值</span><br><span class="line"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyThread2 implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;come in Callable&quot;);</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要做的就是通过 Thread 线程， 将 MyThread2 实现 Callable 接口的类包装起来</p><hr><p>这里需要用到的是 FutureTask 类，他实现了 Runnable 接口，并且还需要传递一个实现 Callable 接口的类作为构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span><br><span class="line">&#x2F;&#x2F; 这里通过了FutureTask接触了Callable接口</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br></pre></td></tr></table></figure><p>然后在用 Thread 进行实例化，传入实现 Runnabnle 接口的 FutureTask 的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 &#x3D; new Thread(futureTask, &quot;aaa&quot;);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>最后通过 utureTask.get() 获取到返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出FutureTask的返回值</span><br><span class="line">System.out.println(&quot;result FutureTask &quot; + futureTask.get());</span><br></pre></td></tr></table></figure><hr><p>这就相当于原来我们的方式是 main 方法一条龙之心，后面在引入 Callable 后，对于执行比较久的线程，可以单独新开一个线程进行执行，最后在进行汇总输出</p><p>最后需要注意的是： 最后获得 Callable 线程的计算结果，如果没有计算完成就要去强求获得，会导致阻塞，直到计算完成</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141226.png"></p><p>就是说： <font color='red'>[  futureTask.get() 需要放在最后执行，这样不会导致主线程阻塞  ]</font></p><hr><p>也可以使用下面算法，使用类似于 [ 自旋锁 ] 的方式来进行判断是否运行完毕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断futureTask是否计算完成</span><br><span class="line">while(!futureTask.isDone()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result FutureTask &quot; + futureTask.get());</span><br></pre></td></tr></table></figure><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个 FutureTask 的时候，只会计算一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启两个线程计算futureTask</span><br><span class="line">new Thread(futureTask, &quot;AAA&quot;).start();</span><br><span class="line">new Thread(futureTask, &quot;BBB&quot;).start();</span><br></pre></td></tr></table></figure><p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要定义两个 futureTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask2 &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启两个线程计算futureTask</span><br><span class="line">new Thread(futureTask, &quot;AAA&quot;).start();</span><br><span class="line"></span><br><span class="line">new Thread(futureTask2, &quot;BBB&quot;).start();</span><br></pre></td></tr></table></figure><hr><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：[ 线程复用、控制最大并发数、管理线程 ]</p><p>线程池中的任务是放入到阻塞队列中的</p><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>多核处理的好处是：[ 省略的上下文的切换开销 ]</p><p>原来我们实例化对象的时候，是使用 new 关键字进行创建，到了 Spring 后，我们学了 IOC 依赖注入，发现Spring 帮我们将对象已经加载到了 Spring 容器中，只需要通过 @Autowrite 注解，就能够自动注入，从而使用</p><p>因此使用多线程有下列的好处</p><ul><li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就立即执行</li><li>提高线程的可管理性。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java 中线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor 这几个类。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141227.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141228.png"></p><hr><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul><li>Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池<ul><li>执行长期的任务，性能好很多</li><li>创建一个 [ 定长线程池 ]，可控制线程数最大并发数，超出的线程会在队列中等待</li></ul></li><li>Executors.newSingleThreadExecutor：创建一个只有 1 个线程的 [ 单线程池 ]<ul><li>一个任务一个任务执行的场景</li><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul></li><li>Executors.newCacheThreadPool(); 创建一个 [ 可扩容的线程池 ]<ul><li>执行很多短期异步的小程序或者负载教轻的服务器</li><li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li></ul></li><li>Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li></ul><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>首先我们需要使用  [ Executors 工具类 ]，进行创建线程池，这里创建了一个拥有 5 个线程的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一池5个处理线程 [ 用池化技术，一定要记得关闭 ]</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个只有一个线程的线程池</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newCacheThreadPool();</span><br></pre></td></tr></table></figure><p>然后我们执行下面的的应用场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br></pre></td></tr></table></figure><p>我们需要使用 [ threadPool.execute  ] 执行业务，execute 需要传入一个实现了 Runnable 接口的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t 给用户办理业务&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们使用完毕后关闭线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Array  Arrays(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Collection Collections(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Executor Executors(辅助工具类)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-5 给用户:4 办理业务</span><br><span class="line">pool-1-thread-1 给用户:5 办理业务</span><br><span class="line">pool-1-thread-4 给用户:3 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-3 给用户:2 办理业务</span><br><span class="line">pool-1-thread-2 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:8 办理业务</span><br><span class="line">pool-1-thread-1 给用户:7 办理业务</span><br><span class="line">pool-1-thread-5 给用户:6 办理业务</span><br></pre></td></tr></table></figure><p>我们能够看到，一共有 5 个线程，在给 10 个用户办理业务</p><hr><h5 id="创建周期性执行任务的线程池"><a href="#创建周期性执行任务的线程池" class="headerlink" title="创建周期性执行任务的线程池"></a>创建周期性执行任务的线程池</h5><p>Executors.newScheduledThreadPool(int corePoolSize)：</p><p><strong>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</strong></p><p>底层使用 ScheduledThreadPoolExecutor 来实现 ScheduledThreadPoolExecutor 为ThreadPoolExecutor子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* delay：延时执行任务的时间</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                     long delay,</span><br><span class="line">                                     TimeUnit unit)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws IllegalArgumentException   &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* initialDelay 第一次执行任务延迟时间</span><br><span class="line">* period 连续执行任务之间的周期，从上一个任务开始执行时计算延迟多少开始执行下一个任务，但是还会等上一个任务结束之后。</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                long initialDelay,</span><br><span class="line">                                                long period,</span><br><span class="line">                                                TimeUnit unit)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">   * @throws IllegalArgumentException   &#123;@inheritDoc&#125;</span><br><span class="line">   * command：执行的任务 Callable或Runnable接口实现类</span><br><span class="line">* initialDelay 第一次执行任务延迟时间</span><br><span class="line">* delay：连续执行任务之间的周期，从上一个任务全部执行完成时计算延迟多少开始执行下一个任务</span><br><span class="line">* unit：延迟时间单位</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                   long initialDelay,</span><br><span class="line">                                                   long delay,</span><br><span class="line">                                                   TimeUnit unit)</span><br></pre></td></tr></table></figure><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>我们通过查看源码，点击了 Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool 能够发现底层都是使用了 ThreadPoolExecutor</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141229.png"></p><p>我们可以看到线程池的内部，还使用到了 LinkedBlockingQueue 链表阻塞队列</p><p>同时在查看 Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue 阻塞队列</p><p>最后查看一下，完整的三个创建线程的方法</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141230.png"></p><h4 id="线程池的重要参数"><a href="#线程池的重要参数" class="headerlink" title="线程池的重要参数"></a>线程池的重要参数</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141231.png"></p><p>线程池在创建的时候，一共有7大参数</p><ul><li>corePoolSize：[ 核心线程数 ]，线程池中的常驻核心线程数<ul><li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li><li>当线程池中的线程数目达到 corePoolSize 后，就会把到达的队列放到缓存队列中</li></ul></li><li>maximumPoolSize：线程池能够容纳同时执行的 [ 最大线程数 ]，此值必须大于等于1、<ul><li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li></ul></li><li>keepAliveTime：多余的 [ 空闲线程存活时间 ]<ul><li>当线程池数量超过 corePoolSiz e时，当空闲时间达到 keepAliveTime 值时，多余的空闲线程会被销毁，直到只剩下 corePoolSize 个线程为止</li><li>默认情况下，只有当线程池中的线程数大于 corePoolSize 时，keepAliveTime 才会起作用</li></ul></li><li>unit：keepAliveTime 的单位</li><li>workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）<ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul></li><li>threadFactory：表示生成线程池中工作线程的 [ 线程工厂  ]，用于创建线程池 一般用默认即可</li><li>handler：[ 拒绝策略 ] ，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的 Runnable 的策略</li></ul><p>今日值班窗口有 2 个，现在 2 个窗口都有人在办理业余，此时又进来 3 个客人需要办理业务，他们就需要去等待区 [ 阻塞队列 ]等待</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141232.png"></p><p>此时，又进来 3 个客人需要办理业务，但当值窗口已满，等待区已满，就需要 加班窗口 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141233.png"></p><p>今天 人特别多，不知为何，又来了 2 个人，课堂经理就需要到门口，对来的进行阻拦了，因为此时网点已容不下更多人</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141234.png"></p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>以下所有拒绝策略都实现了 RejectedExecutionHandle r接口</p><ul><li>AbortPolicy：默认，直接抛出 RejectedExcutionException 异常，阻止系统正常运行</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><hr><h4 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h4><h5 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141235.png"></p><p><strong>文字说明：</strong></p><ol><li>在创建了线程池后，等待提交过来的任务请求</li><li>当调用 execute() 方法添加一个请求任务时，线程池会做出如下判断<ol><li>如果正在运行的线程池数量小于 corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入 [ 阻塞队列 ]</li><li>如果这时候队列满了，并且正在运行的线程数量还小于 maximumPoolSize，那么还是创建非核心线程 like 运行这个任务；</li><li>如果队列满了并且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和 [ 拒绝策略 ]来执行</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做操作一定的时间 (keepAliveTime) 时，线程池会判断：<ol><li>如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉</li><li>所以线程池的所有任务完成后，它会最终收缩到 corePoolSize 的大小</li></ol></li></ol><p><strong>[ 以顾客去银行办理业务为例，谈谈线程池的底层工作原理：]</strong></p><ol><li>最开始假设来了两个顾客，因为 corePoolSize为 2，因此这两个顾客直接能够去窗口办理</li><li>后面又来了三个顾客，因为 corePool 已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li><li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li><li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li></ol><h4 id="为什么不用默认创建的线程池？"><a href="#为什么不用默认创建的线程池？" class="headerlink" title="为什么不用默认创建的线程池？"></a>为什么不用默认创建的线程池？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程池创建的方法有：[ 固定数的，单一的，可变的 ] ，那么在实际开发中，应该使用哪个？</span><br><span class="line"></span><br><span class="line">答：我们一个都不用，在生产环境中是使用自己自定义的</span><br><span class="line"></span><br><span class="line">为什么不用Executors中JDK提供的？</span><br></pre></td></tr></table></figure><p>根据阿里巴巴手册：并发控制这章</p><ul><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程<ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li></ul></li><li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutors 的方式，这样的处理方式让写的同学 [ 更加明确线程池的运行规则，规避资源耗尽的风险 ]<ul><li>Executors 返回的线程池对象弊端如下：<ul><li>FixedThreadPool 和 SingleThreadPool：<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</li></ul></li><li>CacheThreadPool 和 ScheduledThreadPool<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li></ul></li></ul></li></ul></li></ul><hr><h3 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h3><h4 id="采用默认拒绝策略"><a href="#采用默认拒绝策略" class="headerlink" title="采用默认拒绝策略"></a>采用默认拒绝策略</h4><p>从上面我们知道，因为默认的 Executors 创建的线程池，底层都是使用 LinkBlockingQueue 作为阻塞队列的，而LinkBlockingQueue 虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有 20 多亿，可以相当是无界的了，因此我们要使用 ThreadPoolExecutor 自己手动创建线程池，然后指定阻塞队列的大小</p><p>下面我们创建了一个 核心线程数为 2，最大线程数为 5，并且阻塞队列数为 3 的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写线程池</span></span><br><span class="line"><span class="keyword">final</span> Integer corePoolSize = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> Integer maximumPoolSize = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">final</span> Long keepAliveTime = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span></span><br><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    corePoolSize,</span><br><span class="line">    maximumPoolSize,</span><br><span class="line">    keepAliveTime,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure><p>然后使用 for 循环，模拟 10 个用户来进行请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 循环十次，模拟业务办理，让5个线程处理这10个请求</span><br><span class="line">      for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">          final int tempInt &#x3D; i;</span><br><span class="line">          executorService.execute(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + &quot;\t 给用户:&quot; + tempInt + &quot; 办理业务&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">      executorService.shutdown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是在用户执行到第 9 个的时候，触发了异常，程序中断 [ 最大只能运行 8 个 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task threadPoll.MyThreadPoolExecutorsDemo$$Lambda$14&#x2F;0x0000000840064c40@5b6f7412 rejected from java.util.concurrent.ThreadPoolExecutor@27973e9b[Running, pool size &#x3D; 5, active threads &#x3D; 5, queued tasks &#x3D; 3, completed tasks &#x3D; 0]</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)</span><br><span class="line">at threadPoll.MyThreadPoolExecutorsDemo.main(MyThreadPoolExecutorsDemo.java:32)</span><br><span class="line">pool-1-thread-5 给用户:8 办理业务</span><br><span class="line">pool-1-thread-3 给用户:6 办理业务</span><br><span class="line">pool-1-thread-1 给用户:1 办理业务</span><br><span class="line">pool-1-thread-2 给用户:2 办理业务</span><br><span class="line">pool-1-thread-4 给用户:7 办理业务</span><br><span class="line">pool-1-thread-2 给用户:5 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:3 办理业务</span><br></pre></td></tr></table></figure><p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的 AbortPolicy，也就是抛异常的</p><p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 = 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p><h4 id="采用CallerRunsPolicy拒绝策略"><a href="#采用CallerRunsPolicy拒绝策略" class="headerlink" title="采用CallerRunsPolicy拒绝策略"></a>采用CallerRunsPolicy拒绝策略</h4><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">main 给用户:8 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-3 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:3 办理业务</span><br><span class="line">pool-1-thread-1 给用户:2 办理业务</span><br></pre></td></tr></table></figure><p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p><h4 id="采用-DiscardPolicy-拒绝策略"><a href="#采用-DiscardPolicy-拒绝策略" class="headerlink" title="采用 DiscardPolicy 拒绝策略"></a>采用 DiscardPolicy 拒绝策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-1 给用户:2 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-3 给用户:3 办理业务</span><br></pre></td></tr></table></figure><p>采用 DiscardPolicy 拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p><h4 id="采用DiscardOldestPolicy拒绝策略"><a href="#采用DiscardOldestPolicy拒绝策略" class="headerlink" title="采用DiscardOldestPolicy拒绝策略"></a>采用DiscardOldestPolicy拒绝策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-1 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:8 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br></pre></td></tr></table></figure><p>这个策略和刚刚差不多，会把最久的队列中的任务替换掉</p><hr><h3 id="线程池的合理参数"><a href="#线程池的合理参数" class="headerlink" title="线程池的合理参数"></a>线程池的合理参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产环境中如何配置 corePoolSize 和 maximumPoolSize</span><br></pre></td></tr></table></figure><p>这个是根据具体业务来配置的，分为 CPU 密集型和 IO 密集型</p><ul><li>CPU密集型</li></ul><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p><p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p><p>CPU密集型任务 [ 配置尽可能少的线程数量 ] ：</p><p><strong>一般公式：</strong>CPU核数 + 1个线程数</p><ul><li>IO密集型</li></ul><p>由于 IO 密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p><p>IO 密集型，即该任务需要大量的 IO 操作，即大量的阻塞</p><p>在单线程上运行 IO 密集型的任务会导致浪费大量的 CPU 运算能力花费在等待上</p><p>所以 IO 密集型任务中使用多线程可以大大的加速程序的运行，即使在单核 CPU 上，这种加速主要就是利用了被浪费掉的阻塞时间。</p><p>IO密集时，大部分线程都被阻塞，故需要 [ 多配置线程数 ]：</p><p>参考公式：CPU核数 / (1 - 阻塞系数)   [ 阻塞系数在0.8 ~ 0.9左右 ] </p><p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9_Synchronized 和 Lock 的区别与好处</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/9-Synchronized-%E5%92%8C-Lock-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/9-Synchronized-%E5%92%8C-Lock-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h1 id="9-Synchronized-和-Lock-的区别与好处"><a href="#9-Synchronized-和-Lock-的区别与好处" class="headerlink" title="9_Synchronized 和 Lock 的区别与好处"></a>9_Synchronized 和 Lock 的区别与好处</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早期的时候我们解决  [ 生产者消费者问题  ]对线程的主要操作为：</p><ul><li>synchronized  👉   [ wait ]  [ notify / notifyAll ]</li></ul><p>然后后面出现了替代方案</p><ul><li>lock   👉  [ await ]  [ singal / singalAll ]</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141037.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="synchronized-和-lock-有什么区别？用新的-lock-有什么好处？举例说明"><a href="#synchronized-和-lock-有什么区别？用新的-lock-有什么好处？举例说明" class="headerlink" title="synchronized  和  lock 有什么区别？用新的 lock 有什么好处？举例说明"></a>synchronized  和  lock 有什么区别？用新的 lock 有什么好处？举例说明</h3><p>1）synchronized 属于JVM 层面，属于 java 的关键字</p><ul><li> monitorenter（底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象 只能在同步块或者方法中才能调用 wait/ notify 等方法）</li><li> Lock 是具体类（java.util.concurrent.locks.Lock）是 api 层面的锁</li></ul><p>2）使用方法：</p><ul><li>synchronized：不需要用户去手动释放锁，当 synchronized 代码执行后，系统会自动让线程释放对锁的占用</li><li>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要 lock() 和 unlock() 配置 try catch / finally语句来完成</li></ul><p>3）等待是否中断</p><ul><li>synchronized：不可中断，除非抛出异常或者正常运行完成</li><li>ReentrantLock：可中断，可以设置超时方法<ul><li>设置超时方法，trylock(long timeout, TimeUnit unit)</li><li>通过 lock.lockInterruptibly() 可以实现中断</li></ul></li></ul><p>4）加锁是否公平</p><ul><li>synchronized：非公平锁</li><li>ReentrantLock：默认非公平锁，构造函数可以传递 boolean 值，true 为公平锁，false 为非公平锁</li></ul><p>5）锁绑定多个条件 Condition</p><ul><li>synchronized：没有，要么随机，要么全部唤醒</li><li>ReentrantLock：用来实现 [ 分组唤醒需要唤醒的线程 ]，可以精确唤醒，而不是像 synchronized 那样，要么随机，要么全部唤醒</li></ul><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>针对刚刚提到的区别的第 5 条，我们有下面这样的一个场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目：多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br><span class="line">紧接着</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br><span class="line">..</span><br><span class="line">来10轮</span><br></pre></td></tr></table></figure><p>我们会发现，这样的场景在使用 synchronized 来完成的话，会非常的困难，但是使用 lock 就非常方便了</p><p>也就是我们需要实现一个链式唤醒的操作</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217141052.png"></p><p>当 A 线程执行完后，B 线程才能执行，然后 B 线程执行完成后，C 线程才执行</p><p>首先我们需要创建一个重入锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个重入锁</span><br><span class="line">private Lock lock &#x3D; new ReentrantLock();</span><br></pre></td></tr></table></figure><p>然后定义三个条件，也可以称为 [ 锁的钥匙 ]，通过它就可以获取到锁，进入到方法里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这三个相当于备用钥匙</span><br><span class="line">private Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line">private Condition condition2 &#x3D; lock.newCondition();</span><br><span class="line">private Condition condition3 &#x3D; lock.newCondition();</span><br></pre></td></tr></table></figure><p>然后开始记住锁的三部曲： [ 判断 干活 唤醒 ]</p><p>这里的判断，为了 [ 避免虚假唤醒，一定要采用 while ]</p><p>干活就是把需要的内容，打印出来</p><p>唤醒的话，就是修改资源类的值，然后精准唤醒线程进行干活：这里A 唤醒B， B唤醒C，C又唤醒A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知B线程执行）</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************* 资源类 *******************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A 1   B 2   c 3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建一个重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这三个相当于备用钥匙</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知B线程执行）</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知C线程执行）</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">// 通知2号去干活了</span></span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 不等于1，需要等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 （干完活后，需要通知C线程执行）</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通知1号去干活了</span></span><br><span class="line">            condition1.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************* 测试类 *******************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    shareResource.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">A 10</span><br><span class="line">A 11</span><br><span class="line">A 12</span><br><span class="line">A 13</span><br><span class="line">A 14</span><br><span class="line">B 20</span><br><span class="line">B 21</span><br><span class="line">B 22</span><br><span class="line">B 23</span><br><span class="line">B 24</span><br><span class="line">B 25</span><br><span class="line">B 26</span><br><span class="line">B 27</span><br><span class="line">B 28</span><br><span class="line">B 29</span><br><span class="line">C 30</span><br><span class="line">C 31</span><br><span class="line">C 32</span><br><span class="line">C 33</span><br><span class="line">C 34</span><br><span class="line">C 35</span><br><span class="line">C 36</span><br><span class="line">C 37</span><br><span class="line">C 38</span><br><span class="line">C 39</span><br><span class="line">C 310</span><br><span class="line">C 311</span><br><span class="line">C 312</span><br><span class="line">C 313</span><br><span class="line">C 314</span><br><span class="line">.....</span><br><span class="line">执行 10 轮</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8_ 阻塞队列</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/8-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/8-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="8-阻塞队列"><a href="#8-阻塞队列" class="headerlink" title="8_ 阻塞队列"></a>8_ 阻塞队列</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭 [ FIFO ]</p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>BlockingQueue 阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140908.png"></p><p>线程1 通过 Put 往阻塞队列中添加元素，而线程 2 通过 Take 从阻塞队列中移除元素：</p><ul><li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</li><li>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</li></ul><p>[  类比 1 ]：</p><ul><li>当蛋糕店的柜子空的时候，无法从柜子里面获取蛋糕</li><li>当蛋糕店的柜子满的时候，无法继续向柜子里面添加蛋糕了</li></ul><p>[  即 ]：</p><ul><li>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</li><li>试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</li></ul><hr><h3 id="为什么要用-？"><a href="#为什么要用-？" class="headerlink" title="为什么要用 ？"></a>为什么要用 ？</h3><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p><p>在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</p><h4 id="为什么需要-BlockingQueue"><a href="#为什么需要-BlockingQueue" class="headerlink" title="为什么需要 BlockingQueue"></a>为什么需要 BlockingQueue</h4><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都帮你一手包办了</p><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度 [ 减少程序员的负担 ：不需要手动阻塞或者唤醒 ] 。</p><hr><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ 面试 ]</span><br><span class="line">&#x2F;&#x2F; 你用过List集合类</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ArrayList集合类熟悉么？</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 还用过 CopyOnWriteList  和 BlockingQueue</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140924.png"></p><p>BlockingQueue 阻塞队列是属于一个接口，底下有七个实现类：</p><ul><li><strong>ArrayBlockQueue：</strong>由数组结构组成的有界阻塞队列</li><li><strong>LinkedBlockingQueue：</strong>由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<ul><li>[ 有界，但是界限非常大，相当于无界，可以当成无界 ]</li></ul></li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li><strong>SynchronousQueue：</strong>不存储元素的阻塞队列，也即单个元素的队列<ul><li>[ 生产一个，消费一个，不存储元素，不消费不生产 ]</li></ul></li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul><p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p><hr><h3 id="BlockingQueue-核心方法"><a href="#BlockingQueue-核心方法" class="headerlink" title="BlockingQueue 核心方法"></a>BlockingQueue 核心方法</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140931.png"></p><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException：Queue full                             当阻塞队列空时：再往队列中 remove 移除元素，会抛出： NoSuchException</th></tr></thead><tbody><tr><td>特殊性</td><td>插入方法，成功 true，失败 false 移除方法：成功返回出队列元素，队列没有就返回空</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到 put 数据 or 响应中断退出， 当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列可用。</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h5 id="抛出异常组"><a href="#抛出异常组" class="headerlink" title="抛出异常组"></a>抛出异常组</h5><p>但执行 add 方法，向已经满的 ArrayBlockingQueue 中添加元素时候，会抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻塞队列，[ 需要填入默认值 ]</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.add(&quot;XXX&quot;));</span><br></pre></td></tr></table></figure><p>运行后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span><br><span class="line">at java.util.AbstractQueue.add(AbstractQueue.java:98)</span><br><span class="line">at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)</span><br><span class="line">at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:25)</span><br></pre></td></tr></table></figure><p>同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了 3 个值，但是取的时候，取了 4 次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻塞队列，[ 需要填入默认值 ]</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;此时队列为空</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br></pre></td></tr></table></figure><p>那么出现异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br><span class="line">at java.util.AbstractQueue.remove(AbstractQueue.java:117)</span><br><span class="line">at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:30)</span><br></pre></td></tr></table></figure><h5 id="布尔类型组"><a href="#布尔类型组" class="headerlink" title="布尔类型组"></a>布尔类型组</h5><p>我们使用 offer 的方法，添加元素时候，如果阻塞队列满了后，会返回 false ，否者返回 true</p><p>同时在取的时候，如果队列已空，那么会返回 null  [ 避免了产生异常，叫停程序 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue blockingQueue &#x3D; new ArrayBlockingQueue(3);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">&#x2F;&#x2F;队列已满</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">&#x2F;&#x2F;队列已空</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h5 id="阻塞队列组"><a href="#阻塞队列组" class="headerlink" title="阻塞队列组"></a>阻塞队列组</h5><p>我们使用 put 的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒</p><p>一般在消息中间件，比如 RabbitMQ 中会使用到，因为需要 [ 保证消息百分百不丢失，因此只有让它阻塞 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">blockingQueue.put(&quot;a&quot;);</span><br><span class="line">blockingQueue.put(&quot;b&quot;);</span><br><span class="line">blockingQueue.put(&quot;c&quot;);</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br><span class="line"></span><br><span class="line">blockingQueue.take();</span><br></pre></td></tr></table></figure><p>同时使用 take 取消息的时候，如果内容不存在的时候，也会被阻塞，直到队列有元素时，才唤醒</p><p>[ 如果一直队列一直没有元素呢 ，让它一直阻塞吗 ？ ]</p><h5 id="不见不散组"><a href="#不见不散组" class="headerlink" title="不见不散组"></a>不见不散组</h5><p>在 offer( ) ， poll 的基础上 [  加时间  ]</p><p>使用 offer 插入的时候，需要指定时间，如果 2 秒还没有插入，那么就放弃插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;a&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;b&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;c&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">&#x2F;&#x2F;尝试加入元素，如果 2s 都没有成功，放弃，返回 false</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;d&quot;, 2L, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>同时 poll 取的时候也进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">&#x2F;&#x2F;尝试取元素,如果 2s 都未取到,返回 null</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>如果 2 秒内取不出来，那么就返回 null</p><p>[ 这组方法就更加灵活，使用较多 ]</p><hr><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 没有容量，与其他 BlockingQueue 不同，SynchronousQueue 是一个不存储元素的 BlockingQueue，每一个 put 操作必须等待一个 take 操作，否者不能继续添加元素</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p><p>生产的线程分别 put 了 A、B、C这三个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个[不储存元素的]阻塞队列</span><br><span class="line">BlockingQueue&lt;String&gt; synchronousQueue &#x3D; new SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put A&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;A&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put B&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put C&quot;);</span><br><span class="line">        synchronousQueue.put(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;t1&quot;).start();</span><br></pre></td></tr></table></figure><p>消费线程使用 take，消费阻塞队列中的内容，并且每次消费前，都等待 5 秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">           </span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take A&quot;);</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take B&quot;);</span><br><span class="line"></span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F;睡眠5s</span><br><span class="line">                   TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               synchronousQueue.take();</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;\t take C&quot;);</span><br><span class="line"></span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;, &quot;t2&quot;).start();</span><br></pre></td></tr></table></figure><p>最后结果输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">t1 put A </span><br><span class="line">5秒后...</span><br><span class="line">t2 take A </span><br><span class="line"></span><br><span class="line">t1 put B </span><br><span class="line">5秒后...</span><br><span class="line">t2 take B </span><br><span class="line"></span><br><span class="line">t1 put C </span><br><span class="line">5秒后...</span><br><span class="line">t2 take C </span><br></pre></td></tr></table></figure><p>我们从最后的运行结果可以看出，每次 t1 线程向队列中添加阻塞队列添加元素后，t1 输入线程就会等待 t2 消费线程，t2 消费后，t2 处于挂起状态，等待 t1 在 存入，从而周而复始，形成 一存一取的状态 。</p><p>完整版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: SynchronousQueue使用演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-11-13 13:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个[不储存元素的]阻塞队列</span></span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put A&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put B&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put C&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take A&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//睡眠5s</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronousQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take C&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h3><h4 id="生产者消费者模式-2-0"><a href="#生产者消费者模式-2-0" class="headerlink" title="生产者消费者模式 2.0"></a>生产者消费者模式 2.0</h4><p>一个初始值为 0 的变量，两个线程对其交替操作，一个加 1，一个减 1，来 5 轮</p><p>关于多线程的操作，我们需要记住下面几句</p><ul><li>线程 操作 资源类</li><li>判断 干活 通知</li><li>防止虚假唤醒机制</li></ul><p>我们下面实现一个简单的生产者消费者模式，首先有资源类 ShareData</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package blockingQueue;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: xj0927</span><br><span class="line"> * @Description: 资源类 [高内聚，低耦合：内聚指的是，一个空调，自身带有调节温度高低的方法]</span><br><span class="line"> * @Date Created in 2020-11-13 14:13</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ShareData &#123;</span><br><span class="line"></span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void increment()&#123;</span><br><span class="line">        &#x2F;&#x2F;同步代码块：加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;判断</span><br><span class="line">            while (number !&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F;等待：不能生产</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;干活</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通知：唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            &#x2F;&#x2F;释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void decrement()&#123;</span><br><span class="line">        &#x2F;&#x2F;同步代码块：加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;判断</span><br><span class="line">            while (number &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F;等待：不能消费</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;干活</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通知:唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有一个 number 变量，同时提供了 increment  和 decrement 的方法，分别让 number 加 1 和减 1</p><p>但是我们在进行判断的时候，为了 [ 防止出现虚假唤醒机制 ]，不能使用 if 来进行判断，而应该使用 while 判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断</span><br><span class="line">while(number !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 等待不能生产</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能使用 if判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断</span><br><span class="line">if(number !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 等待不能生产</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 资源类 [高内聚，低耦合：内聚指的是，一个空调，自身带有调节温度高低的方法]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-11-13 14:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/********************* 资源类 *************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待：不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知：唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//同步代码块：加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待：不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知:唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************* 测试 *************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//t1线程：生产</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">                shareData.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//t2线程：消费</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">                shareData.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后运行成功后，我们一个进行生产，一个进行消费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br></pre></td></tr></table></figure><hr><h4 id="生成者和消费者-3-0"><a href="#生成者和消费者-3-0" class="headerlink" title="生成者和消费者 3.0"></a>生成者和消费者 3.0</h4><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度 。</p><p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************** 资源类 *******************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认开启，进行生产消费</span></span><br><span class="line">    <span class="comment">// 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子包装类，而不用 number++ [ 不用担心原子操作]</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue [ 进行抽象]</span></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而应该采用依赖注入里面的，构造注入方法传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        <span class="comment">// 查询出传入的class是什么</span></span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，[ 防止出现虚假唤醒 ]</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列:&quot;</span> + data  + <span class="string">&quot;成功&quot;</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//[一旦 FLAG 为true 就停止生产]</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列:&quot;</span> + data  + <span class="string">&quot;失败&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 停止生产，表示FLAG=false，生产结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue != <span class="keyword">null</span> &amp;&amp; retValue != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="string">&quot;成功&quot;</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 退出消费队列 [不要忘记了]</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止生产的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 测试类 *******************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerBlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> SynchronousQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 生产线程启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myProd();</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;prod&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费线程启动&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5秒后，停止生产和消费</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5秒钟后，生产和消费线程停止，线程结束&quot;</span>);</span><br><span class="line">        myResource.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">prod 生产线程启动</span><br><span class="line">consumer 消费线程启动</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">consumer 消费队列：1成功</span><br><span class="line">prod 插入队列：1成功</span><br><span class="line">prod 插入队列：2成功</span><br><span class="line">consumer 消费队列：2成功</span><br><span class="line">prod 插入队列：3成功</span><br><span class="line">consumer 消费队列：3成功</span><br><span class="line">prod 插入队列：4成功</span><br><span class="line">consumer 消费队列：4成功</span><br><span class="line">prod 插入队列：5成功</span><br><span class="line">consumer 消费队列：5成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5秒钟后，生产和消费线程停止，线程结束</span><br><span class="line">prod 停止生产,表示FLAG &#x3D; false,生产结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer 消费失败,队列中已为空，退出</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7_CountDownLatch_CyclicBarrier_Semaphore使用</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/7-CountDownLatch-CyclicBarrier-Semaphore%E4%BD%BF%E7%94%A8/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/7-CountDownLatch-CyclicBarrier-Semaphore%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="7-CountDownLatch-CyclicBarrier-Semaphore使用"><a href="#7-CountDownLatch-CyclicBarrier-Semaphore使用" class="headerlink" title="7_CountDownLatch_CyclicBarrier_Semaphore使用"></a>7_CountDownLatch_CyclicBarrier_Semaphore使用</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p><p>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，调用线程就会被阻塞。其它线程调用 CountDown 方法会将计数器减 1（调用 CountDown 方法的线程不会被阻塞），当计数器的值变成零时，因调用 await 方法被阻塞的线程会被唤醒，继续执行 。</p><h3 id="场景：班长关门"><a href="#场景：班长关门" class="headerlink" title="场景：班长关门"></a>场景：班长关门</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个时候就用到了 CountDownLatch，计数器了。我们一共创建 6 个线程，然后计数器的值也设置成 6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数器</span><br><span class="line">CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);</span><br></pre></td></tr></table></figure><p>然后每次学生线程执行完，就让计数器的值<strong>减 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 上完自习，离开教室&quot;);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是<strong>一道墙</strong>，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t 班长最后关门&quot;);</span><br></pre></td></tr></table></figure><p>不加 CountDownLatch 的执行结果，我们发现 main 线程提前已经执行完成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 上完自习，离开教室</span><br><span class="line">0 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br></pre></td></tr></table></figure><p>引入CountDownLatch后的执行结果，我们能够控制住 main 方法的执行，这样能够保证前提任务的执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 上完自习，离开教室</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">1 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moxi.interview.study.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 上完自习，离开教室&quot;</span>);</span><br><span class="line">                <span class="comment">//计数器 -1 </span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置屏障</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 班长最后关门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>和 CountDownLatch 相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行 。</p><p>CyclicBarrier 的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的 await 方法 。</p><h3 id="案例：七龙珠"><a href="#案例：七龙珠" class="headerlink" title="案例：七龙珠"></a>案例：七龙珠</h3><p>集齐 7 个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法[Runnable 接口]</span><br><span class="line">*&#x2F;</span><br><span class="line">CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(7, () -&gt; &#123;</span><br><span class="line">System.out.println(&quot;召唤神龙&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行 await 方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Semaphore：信号量"><a href="#Semaphore：信号量" class="headerlink" title="Semaphore：信号量"></a>Semaphore：信号量</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>信号量主要用于两个目的</p><ul><li>一个是用于共享资源的互斥使用</li><li>另一个用于并发线程数的控制</li></ul><p>通过 acquire() 和 release() 实现 。</p><h3 id="案例：抢车位"><a href="#案例：抢车位" class="headerlink" title="案例：抢车位"></a>案例：抢车位</h3><p>我们模拟一个抢车位的场景，假设一共有6个车，3个停车位</p><p>那么我们首先需要定义信号量为3，也就是3个停车位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span><br><span class="line">*&#x2F;</span><br><span class="line">Semaphore semaphore &#x3D; new Semaphore(3, false);</span><br></pre></td></tr></table></figure><p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后，信号量需要减1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代表一辆车，已经占用了该车位</span><br><span class="line">semaphore.acquire(); &#x2F;&#x2F; 抢占</span><br></pre></td></tr></table></figure><p>同时车辆假设需要等待3秒后，释放信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每个车停3秒</span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(3);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后车辆离开，释放信号量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 释放停车位</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟6部车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 代表一辆车，已经占用了该车位</span></span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 抢占</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 抢到车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每个车停3秒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 离开车位&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0 抢到车位</span><br><span class="line">2 抢到车位</span><br><span class="line">1 抢到车位</span><br><span class="line">2 离开车位</span><br><span class="line">1 离开车位</span><br><span class="line">3 抢到车位</span><br><span class="line">0 离开车位</span><br><span class="line">4 抢到车位</span><br><span class="line">5 抢到车位</span><br><span class="line">4 离开车位</span><br><span class="line">3 离开车位</span><br><span class="line">5 离开车位</span><br></pre></td></tr></table></figure><p>看运行结果能够发现，0 2 1 车辆首先抢占到了停车位，然后等待3秒后，离开，然后后面 3 4 5 又抢到了车位 。</p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6_Java 的锁</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/6-Java-%E7%9A%84%E9%94%81/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/6-Java-%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="6-Java-的锁"><a href="#6-Java-的锁" class="headerlink" title="6_Java 的锁"></a>6_Java 的锁</h1><h2 id="Java-锁之-公平锁-和-非公平锁"><a href="#Java-锁之-公平锁-和-非公平锁" class="headerlink" title="Java 锁之 公平锁 和 非公平锁"></a>Java 锁之 公平锁 和 非公平锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序 [ 随机抢占 ]，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p><h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><p>synchronized 只能是非公平锁 。</p><p>并发包中 ReentrantLock 的创建可以指定析构函数的 boolean 类型来得到公平锁或者非公平锁，默认是非公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span><br><span class="line">*&#x2F;</span><br><span class="line">Lock lock &#x3D; new ReentrantLock(true);</span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后按照 FIFO 的规则从队列中取到自己</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>Java ReenttrantLock 通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，<code>对于synchronized 而言，也是一种非公平锁 </code>。</p><hr><h2 id="可重入锁-和-递归锁-ReentrantLock"><a href="#可重入锁-和-递归锁-ReentrantLock" class="headerlink" title="可重入锁 和 递归锁 ReentrantLock"></a>可重入锁 和 递归锁 ReentrantLock</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>理念：</strong> [ 可重入锁就是递归锁 ！！！] 指的是 <strong>同一线程</strong> 外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 。也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p><p>⽐如⼀个线程获得了某个对象的锁 [ 第一层方法 ]，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的 [ 第二层方法 ]</p><p><strong>实现：</strong> ReentrantLock / Synchronized  就是一个典型的可重入锁</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>可重入锁就是，在一个 method1 方法中加入一把锁，方法 2 也加锁了，那么他们拥有的是同一把锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method1() &#123;</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void method2() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们只需要进入 method1 后，那么它也能直接进入method2 方法，因为他们所拥有的锁，是同一把 。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>可重入锁的最大作用就是避免死锁</p><h3 id="可重入锁验证"><a href="#可重入锁验证" class="headerlink" title="可重入锁验证"></a>可重入锁验证</h3><h4 id="证明-Synchronized"><a href="#证明-Synchronized" class="headerlink" title="证明 Synchronized"></a>证明 Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送短信</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoked sendSMS()&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在同步方法中，调用另外一个同步方法</span></span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot;\t invoked sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个线程操作资源列</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们编写了一个资源类 phone，拥有两个加了 synchronized 的同步方法，分别是 sendSMS 和 sendEmail，我们在 sendSMS 方法中，调用 sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()</span><br><span class="line">t1 invoked sendEmail()</span><br><span class="line">t2 invoked sendSMS()</span><br><span class="line">t2 invoked sendEmail()</span><br></pre></td></tr></table></figure><p>这就说明当 t1 线程进入sendSMS 的时候，拥有了一把锁，同时 t2 线程无法进入，直到 t1 线程拿着锁，执行了sendEmail 方法后，才释放锁，这样 t2 才能够进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()      t1线程在外层方法获取锁的时候</span><br><span class="line">t1 invoked sendEmail()    t1在进入内层方法会自动获取锁</span><br><span class="line"></span><br><span class="line">t2 invoked sendSMS()      t2线程在外层方法获取锁的时候</span><br><span class="line">t2 invoked sendEmail()    t2在进入内层方法会自动获取锁</span><br></pre></td></tr></table></figure><h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set 进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">            setLock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t set Lock&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenterLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为Phone实现了Runnable接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们使用 ReentrantLock 进行验证，首先资源类实现了 Runnable 接口，重写 Run 方法，里面调用 get 方法，get 方法在进入的时候，就加了锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在方法里面，又调用另外一个加了锁的 setLock 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t set Lock&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果我们能发现，结果和加 synchronized 方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br></pre></td></tr></table></figure><p><strong>注意 1：</strong> 当我们在 getLock 方法加两把锁会是什么情况呢？(阿里面试)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">            setLock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是<strong>同一把锁</strong>，也就是说用同一个钥匙都能够打开 。</p><p><strong>注意 2：</strong> 当我们在 getLock 方法加两把锁，但是只解一把锁会出现什么情况呢 ？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void getLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br></pre></td></tr></table></figure><p>也就是说程序直接卡死，线程不能出来，也就说明我们<strong>申请几把锁，最后需要解除几把锁</strong></p><p><strong>注意 3：</strong> 当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢 ？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，运行程序会直接报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br><span class="line">Exception in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><hr><h2 id="Java-锁之-自旋锁"><a href="#Java-锁之-自旋锁" class="headerlink" title="Java 锁之 自旋锁"></a>Java 锁之 自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗 [ 避免用户态与内核态之间的转换 ]，缺点是循环会消耗CPU 。</p><p>原来提到的 CAS 比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140615.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>**优点： **循环比较获取直到成功为止，没有类似于 wait 的阻塞</p><p>**缺点： **当不断自旋的线程越来越多的时候，会因为执行 while 循环不断的消耗 CPU 资源</p><h3 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h3><p>通过 CAS 操作完成自旋锁，A线程先进来调用 myLock 方法自己持有锁 5 秒，B 随后进来发现当前有线程持有锁，不是 null，所以只能通过自旋等待，直到 A 释放锁后 B 随后抢到 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在的泛型装的是[Thread]，原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt;  atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前进来的线程</span></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋</span></span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前进来的线程</span></span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己用完了后，把atomicReference变成null</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoked myUnlock()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动t1线程，开始操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始占有锁</span></span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始释放锁</span></span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让main线程暂停1秒，使得t1线程，先执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1秒后，启动t2线程，开始占用这个锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始占有锁</span></span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="comment">// 开始释放锁</span></span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 come in </span><br><span class="line">.....五秒后.....</span><br><span class="line">t1 invoked myUnlock()</span><br><span class="line">t2 come in </span><br><span class="line">t2 invoked myUnlock()</span><br></pre></td></tr></table></figure><p>首先输出的是 t1 come in</p><p>然后1秒后，t2线程启动，发现锁被 t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到 t1释放锁后，也就是 5 秒后，t2 成功获取到锁，然后释放 。</p><hr><h2 id="独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="独占锁（写锁） / 共享锁（读锁） / 互斥锁"></a>独占锁（写锁） / 共享锁（读锁） / 互斥锁</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>**独占锁： **指该锁一次只能被一个线程所持有。对 ReentrantLock 和 Synchronized 而言都是独占锁</p><p><strong>共享锁：</strong> 指该锁可以被多个线程锁持有 。</p><p>对 ReentrantReadWriteLock 其读锁是共享，其写锁是独占；写的时候只能一个人写，但是读的时候，可以多个人同时读 。</p><h3 id="为什么会有写锁和读锁"><a href="#为什么会有写锁和读锁" class="headerlink" title="为什么会有写锁和读锁"></a>为什么会有写锁和读锁</h3><p>原来我们使用 ReentrantLock 创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读 。</p><p>多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写 。</p><ul><li>读-读：能共存</li><li>读-写：不能共存</li><li>写-写：不能共存</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// private Lock lock = null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义写操作</span></span><br><span class="line"><span class="comment">     * 满足：原子 + 独占</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取:&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object value = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">// 线程操作资源类，5个线程写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt +  <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程操作资源类， 5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别创建5个线程写入缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程操作资源类，5个线程写</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">    final int tempInt &#x3D; i;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5个线程读取缓存，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程操作资源类， 5个线程读</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">    final int tempInt &#x3D; i;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        myCache.get(tempInt + &quot;&quot;);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 正在写入：0</span><br><span class="line">4 正在写入：4</span><br><span class="line">3 正在写入：3</span><br><span class="line">1 正在写入：1</span><br><span class="line">2 正在写入：2</span><br><span class="line">0 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">2 写入完成</span><br><span class="line">4 写入完成</span><br><span class="line">4 读取完成：null</span><br><span class="line">0 写入完成</span><br><span class="line">3 读取完成：null</span><br><span class="line">0 读取完成：null</span><br><span class="line">1 写入完成</span><br><span class="line">3 写入完成</span><br><span class="line">1 读取完成：null</span><br><span class="line">2 读取完成：null</span><br></pre></td></tr></table></figure><p>我们可以看到，在写入的时候，写操作都没其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致！！！</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 创建一个读写锁</span><br><span class="line">* 它是一个读写融为一体的锁，在使用的时候，需要转换</span><br><span class="line">*&#x2F;</span><br><span class="line">private ReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();</span><br></pre></td></tr></table></figure><p>当我们在进行写操作的时候，就需要转换成写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个写锁</span><br><span class="line">rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写锁 释放</span><br><span class="line">rwLock.writeLock().unlock();</span><br></pre></td></tr></table></figure><p>当们在进行读操作的时候，在转换成读锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个读锁</span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读锁 释放</span><br><span class="line">rwLock.readLock().unlock();</span><br></pre></td></tr></table></figure><p>这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个读写锁</span></span><br><span class="line"><span class="comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义写操作</span></span><br><span class="line"><span class="comment">     * 满足：原子 + 独占</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            map.put(key, value);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 写锁 释放</span></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟网络拥堵，延迟0.3秒</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object value = map.get(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 读锁释放</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程操作资源类，5个线程写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt +  <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程操作资源类， 5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式内部必须是final</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 正在写入：1</span><br><span class="line">1 写入完成</span><br><span class="line">2 正在写入：2</span><br><span class="line">2 写入完成</span><br><span class="line">3 正在写入：3</span><br><span class="line">3 写入完成</span><br><span class="line">4 正在写入：4</span><br><span class="line">4 写入完成</span><br><span class="line">5 正在写入：5</span><br><span class="line">5 写入完成</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">5 正在读取:</span><br><span class="line">2 读取完成：2</span><br><span class="line">1 读取完成：1</span><br><span class="line">4 读取完成：4</span><br><span class="line">3 读取完成：3</span><br><span class="line">5 读取完成：5</span><br></pre></td></tr></table></figure><p>从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作 。</p><hr><p><strong>补充：</strong></p><h2 id="为什么Synchronized无法禁止指令重排，却能保证有序性"><a href="#为什么Synchronized无法禁止指令重排，却能保证有序性" class="headerlink" title="为什么Synchronized无法禁止指令重排，却能保证有序性"></a>为什么Synchronized无法禁止指令重排，却能保证有序性</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p><ul><li>Java内存模型</li><li>并发编程有序性问题</li><li>指令重排</li><li>synchronized锁</li><li>可重入锁</li><li>排它锁</li><li>as-if-serial语义</li><li>单线程&amp;多线程</li></ul><h4 id="标准解答"><a href="#标准解答" class="headerlink" title="标准解答"></a>标准解答</h4><p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p><blockquote><p>先解释什么是有序性问题，也知道是什么原因导致的有序性问题</p></blockquote><p>我们也知道，最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样。</p><blockquote><p>表明你知道啥是指令重排，也知道他的实现原理</p></blockquote><p>但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义。</p><p>as-if-serial语义把<strong>单线程</strong>程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p><blockquote><p>重点！解释下什么是as-if-serial语义，因为这是这道题的第一个关键词，答上来就对了一半了</p></blockquote><p>再说下synchronized，他是Java提供的锁，可以通过他对Java中的对象加锁，并且他是一种排他的、可重入的锁。</p><p>所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p><blockquote><p>介绍synchronized的原理，这是本题的第二个关键点，到这里基本就可以拿满分了。</p></blockquote><p>synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是<strong>单线程</strong>，因为有as-if-serial语义保证，单线程的有序性就天然存在了。</p><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p><a href="https://mp.weixin.qq.com/s/Pd6dOXaMQFUHfAUnOhnwtw">https://mp.weixin.qq.com/s/Pd6dOXaMQFUHfAUnOhnwtw</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_TransferValue 是什么</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/5-TransferValue-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/5-TransferValue-%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="5-TransferValue-是什么"><a href="#5-TransferValue-是什么" class="headerlink" title="5_TransferValue 是什么"></a>5_TransferValue 是什么</h1><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><h3 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String personName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personName = personName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferValueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.setPersonName(<span class="string">&quot;XXXX&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;XXX&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TransferValueDemo test = <span class="keyword">new</span> TransferValueDemo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义基本数据类型</span></span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        test.changeValue1(age);</span><br><span class="line">        System.out.println(<span class="string">&quot;age ----&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化person类</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        test.changeValue2(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;personName-----&quot;</span> + person.getPersonName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String</span></span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        test.changeValue3(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;string-----&quot;</span> + str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age ----20</span><br><span class="line">personName-----XXXX</span><br><span class="line">string-----abc</span><br></pre></td></tr></table></figure><h3 id="changeValue1-的执行过程"><a href="#changeValue1-的执行过程" class="headerlink" title="changeValue1 的执行过程"></a>changeValue1 的执行过程</h3><p>八种基本数据类型，在栈里面分配内存，属于值传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈管运行，堆管存储</span><br></pre></td></tr></table></figure><p>当们执行 changeValue1 的时候，因为 int 是基本数据类型，所以传递的是 int = 20 这个值，相当于传递的是一个副本，main 方法里面的 age 并没有改变，因此输出的结果  age 还是20，属于值传递 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140405.png"></p><h3 id="changeValue2-的执行过程"><a href="#changeValue2-的执行过程" class="headerlink" title="changeValue2 的执行过程"></a>changeValue2 的执行过程</h3><p>因为 Person 是属于对象，传递的是<strong>内存地址</strong>，当执行changeValue2的时候，会改变内存中的 Person 的值，属于引用传递，两个指针都是指向同一个地址 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140358.png"></p><h3 id="changeValue3-的执行过程"><a href="#changeValue3-的执行过程" class="headerlink" title="changeValue3 的执行过程"></a>changeValue3 的执行过程</h3><p>String 不属于基本数据类型，但是为什么执行完成后，还是 abc 呢？</p><p>这是因为 String 的特殊性，当我们执行 String str = “abc” 的时候，它会把 <code>abc</code> 放入常量池中</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140411.png"></p><p>当我们执行 changeValue3 的时候，会重新新建一个 xxx，并没有销毁 abc，然后指向xxx，然后最后我们输出的是 main 中的引用，还是指向的 abc，因此最后输出结果还是abc 。</p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 值传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_ Collection 线程不安全的举例</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/4-Collection-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/4-Collection-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Collection-线程不安全的举例"><a href="#4-Collection-线程不安全的举例" class="headerlink" title="4_ Collection 线程不安全的举例"></a>4_ Collection 线程不安全的举例</h1><h2 id="单线程环境下"><a href="#单线程环境下" class="headerlink" title="单线程环境下"></a>单线程环境下</h2><p>单线程环境的 ArrayList 是不会有问题的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListNotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String element : list) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>为什么 ArrayList 是线程不安全的 ？因为在进行写操作的时候，方法上为了保证并发性，是没有添加 synchronized 修饰，所以并发写的时候，就会出现问题 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140149.png"></p><hr><h2 id="ArrayList-不安全的案列"><a href="#ArrayList-不安全的案列" class="headerlink" title="ArrayList 不安全的案列"></a>ArrayList 不安全的案列</h2><p>当我们同时启动 100个线程去操作 List 的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">![Snipaste_2020-<span class="number">11</span>-<span class="number">12_17</span>-<span class="number">53</span>-<span class="number">21</span>](../../../../../myBlog/source/_posts/大厂面试第二季_周阳老师/JUC/4_ArrayList 为什么线程不安全/images/Snipaste_2020-<span class="number">11</span>-<span class="number">12_17</span>-<span class="number">53</span>-<span class="number">21.</span>png)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="comment">//往集合中添加元素【add 方法并未 synchronized 修饰】</span></span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候出现了错误，也就是<code>java.util.ConcurrentModificationException</code>[ 并发修改的异常 ]</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140157.png"></p><h4 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h4><p>并发修改导致：一个人正在写入，另一个人过来抢夺，导致数据不一致异常 ！</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：Vector"><a href="#方案一：Vector" class="headerlink" title="方案一：Vector"></a>方案一：Vector</h5><p>第一种方法，就是不用 ArrayList 这种不安全的 List 实现类，而采用 Vector，线程安全的</p><p>关于 Vector 如何实现线程安全的，而是在方法上加了锁，即 synchronized </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140202.png"></p><p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致并发性下降 。</p><h5 id="方案二：Collections-synchronizedList"><a href="#方案二：Collections-synchronizedList" class="headerlink" title="方案二：Collections.synchronizedList()"></a>方案二：Collections.synchronizedList()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>采用 Collections 集合工具类，在 ArrayList 外面包装一层 同步 机制 。</p><h5 id="方案三：使用-JUC-工具类中的-CopyOnWriteArrayList-类"><a href="#方案三：使用-JUC-工具类中的-CopyOnWriteArrayList-类" class="headerlink" title="方案三：使用 JUC 工具类中的 CopyOnWriteArrayList 类"></a>方案三：使用 JUC 工具类中的 CopyOnWriteArrayList 类</h5><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p><p>CopyOnWrite 容器即写时复制的容器。往一个容器添加元素的时候，不会直接往当前容器添加，而是现将当前容器 Object [ ] 进行 Copy ，复制出一个新的容器 Object [ ] ，然后再往新的容器中添加元素，添加完元素后，再将原容器的引用指向新的容器；这样做的好处是可以对 CopyOnWrite 容器进行并发读，而不需要加锁，因为当前容器并不需要添加元素。所以 CopyOnWrite 容器也是一种读写分离的思想！</p><p>就是写的时候，把 ArrayList 扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList 的引用指向扩容后的</p><p><strong>查看底层 add 方法源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Object[] elements = getArray();</span><br><span class="line">          <span class="keyword">int</span> len = elements.length;</span><br><span class="line">          Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">          newElements[len] = e;</span><br><span class="line">          setArray(newElements);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先需要加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure><p>然后在末尾扩容一个单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] elements &#x3D; getArray();</span><br><span class="line">int len &#x3D; elements.length;</span><br><span class="line">Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br></pre></td></tr></table></figure><p>然后在把扩容后的空间，填写上需要 add 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newElements[len] &#x3D; e;</span><br></pre></td></tr></table></figure><p>最后把内容 set 到 Array 中</p><hr><h2 id="HashSet-线程不安全"><a href="#HashSet-线程不安全" class="headerlink" title="HashSet 线程不安全"></a>HashSet 线程不安全</h2><h4 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h4><p> 线程不安全。并发情况下也会发生 <code>ConcurrentModificationException</code> 异常；</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：Collections-synchronizedSet-new-HashSet-lt-gt"><a href="#方案一：Collections-synchronizedSet-new-HashSet-lt-gt" class="headerlink" title="方案一：Collections.synchronizedSet(new HashSet&lt;&gt;())"></a>方案一：<code>Collections.synchronizedSet(new HashSet&lt;&gt;())</code></h5><h5 id="方案二：使用-JUC-工具类中的-CopyOnWriteArraySet-类"><a href="#方案二：使用-JUC-工具类中的-CopyOnWriteArraySet-类" class="headerlink" title="方案二：使用 JUC 工具类中的 CopyOnWriteArraySet 类"></a>方案二：使用 JUC 工具类中的 CopyOnWriteArraySet 类</h5><p>底层还是使用 CopyOnWriteArrayList 进行实例化</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140209.png"></p><p><strong>补充：</strong></p><p>同理 HashSet 的底层结构就是 HashMap</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140214.png"></p><p><strong>思考：</strong> 但是为什么我调用 HashSet.add() 的方法，只需要传递一个元素，而 HashMap 是需要传递 key-value 键值对 ？</p><p>首先我们查看 hashSet 的 add 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们能发现但我们调用 add 的时候，存储一个值进入map中，只是作为key进行存储，而 value 存储的是一个Object 类型的常量，也就是说 HashSet 只关心key，而不关心 value 。</p><hr><h2 id="HashMap-线程不安全案列"><a href="#HashMap-线程不安全案列" class="headerlink" title="HashMap 线程不安全案列"></a>HashMap 线程不安全案列</h2><p>同理 HashMap 在多线程环境下，也是不安全的，并发情况下也会发生 <code>ConcurrentModificationException</code> 异常；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="方案一：使用-HashTable"><a href="#方案一：使用-HashTable" class="headerlink" title="方案一：使用 HashTable"></a>方案一：使用 HashTable</h5><p>与 Vector 类似，属于 HashMap 线程安全的实现类，里面方面同样加了 <code>synchronized</code>修饰，效率较低 。</p><h5 id="方案二：Collections-synchronizedMap-new-HashMap-lt-gt"><a href="#方案二：Collections-synchronizedMap-new-HashMap-lt-gt" class="headerlink" title="方案二：Collections.synchronizedMap(new HashMap&lt;&gt; ())"></a>方案二：Collections.synchronizedMap(new HashMap&lt;&gt; ())</h5><h5 id="方案三：使用-JUC-工具类下的-ConcurrentHashMap"><a href="#方案三：使用-JUC-工具类下的-ConcurrentHashMap" class="headerlink" title="方案三：使用 JUC 工具类下的  ConcurrentHashMap"></a>方案三：使用 JUC 工具类下的  ConcurrentHashMap</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_谈谈原子类的ABA问题</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/3-%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/3-%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="3-谈谈原子类的ABA问题"><a href="#3-谈谈原子类的ABA问题" class="headerlink" title="3_谈谈原子类的ABA问题"></a>3_谈谈原子类的ABA问题</h1><h2 id="原子类-AtomicInteger-的ABA问题"><a href="#原子类-AtomicInteger-的ABA问题" class="headerlink" title="原子类 AtomicInteger 的ABA问题"></a>原子类 AtomicInteger 的ABA问题</h2><h3 id="连环套路"><a href="#连环套路" class="headerlink" title="连环套路"></a>连环套路</h3><p>从 AtomicInteger 引出下面的问题：</p><p>CAS -&gt; Unsafe -&gt; CAS 底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避 ABA 问题</p><hr><h3 id="ABA-问题是什么"><a href="#ABA-问题是什么" class="headerlink" title="ABA 问题是什么"></a>ABA 问题是什么</h3><p>假设现在有两个线程，分别是 T1 和 T2，然后 T1 执行某个操作的时间为10 秒，T2 执行某个时间的操作是 2 秒，最开始 AB 两个线程，分别从主内存中获取 A 值，但是因为 B 的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105629.png"></p><p>所以 ABA 问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了 N 次，但是最终又改成原来的值了 。</p><h3 id="CAS-导致-ABA-问题"><a href="#CAS-导致-ABA-问题" class="headerlink" title="CAS 导致 ABA 问题"></a>CAS 导致 ABA 问题</h3><p>CAS 算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p><p>比如说一个线程 one 从内存位置 V 中取出A，这时候另外一个线程 two 也从内存中取出 A，并且线程 two进行了一些操作将值变成了B，然后线程 two 又将 V 位置的数据变成 A，这时候线程 one 进行CAS操作发现内存中仍然是 A，然后线程 one 操作成功 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的！！！</span><br></pre></td></tr></table></figure><hr><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>原子引用其实和原子包装类是差不多的概念，就是将一个 java 类，用原子引用类进行包装起来，那么这个类就具备了原子性 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User z3 = <span class="keyword">new</span> User(<span class="string">&quot;z3&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        User l4 = <span class="keyword">new</span> User(<span class="string">&quot;l4&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在主物理内存的共享变量，为z3</span></span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于原子引用的-ABA-问题"><a href="#基于原子引用的-ABA-问题" class="headerlink" title="基于原子引用的 ABA 问题"></a>基于原子引用的 ABA 问题</h4><p>我们首先创建了两个线程，然后 T1 线程，执行一次 ABA 的操作，T2 线程在一秒后修改主内存的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的原子引用包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，它能够成功的修改，这就是 ABA 问题</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105647.png"></p><hr><h3 id="解决-ABA-问题"><a href="#解决-ABA-问题" class="headerlink" title="解决 ABA 问题"></a>解决 ABA 问题</h3><p><strong>思路如下：</strong></p><p>新增一种机制，也就是修改版本号，类似于[ 时间戳 ]的概念</p><p>T1： 100 1 2019 2</p><p>T2： 100 1 101 2 100 3</p><p>如果 T1 修改的时候，版本号为 2，落后于现在的版本号 3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路 。</p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通的原子引用包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递两个值，一个是初始值，一个是初始版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的产生==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把100 改成 101 然后在改成100，也就是ABA</span></span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t3一秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否：&quot;</span> + result + <span class="string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能够发现，线程 t3，在进行 ABA 操作后，版本号变更成了 3，而线程 t4 在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样 。</p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_CAS 底层原理</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/2-CAS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/2-CAS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="2-CAS-底层原理"><a href="#2-CAS-底层原理" class="headerlink" title="2_CAS 底层原理"></a>2_CAS 底层原理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CAS 的全称是 Compare-And-Swap，它是 CPU 并发原语</p><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p><p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法。调用UnSafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于 CAS 是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，不会造成所谓的数据不一致的问题，也就是说 CAS 是线程安全的 。</p><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个原子类</span></span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span></span><br><span class="line"><span class="comment">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217140025.png"></p><p>首先调用 AtomicInteger 创建了一个实例， 并初始化为 5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger(5);</span><br></pre></td></tr></table></figure><p>然后调用 CAS 方法，企图更新成 2019，这里有两个参数，一个是 5，表示期望值，第二个就是我们要更新的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(5, 2019)</span><br></pre></td></tr></table></figure><p>然后再次使用了一个方法，同样将值改成 1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(5, 1024)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了 2019，不满足期望值，因此返回了 false，本次写入失败！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135811.png"></p><hr><h2 id="CAS-底层原理"><a href="#CAS-底层原理" class="headerlink" title="CAS 底层原理"></a>CAS 底层原理</h2><p>首先我们先看看 atomicInteger.getAndIncrement() 方法的源码</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135820.png"></p><p>从这里能够看到，底层又调用了一个 unsafe 类的 getAndAddInt 方法</p><h3 id="1、unsafe-类"><a href="#1、unsafe-类" class="headerlink" title="1、unsafe 类"></a>1、unsafe 类</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135829.png"></p><p>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe 相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe 类存在sun.misc 包中，其内部方法操作可以像 C 的指针一样直接操作内存，因为 Java 中的 CAS 操作的执行依赖于 Unsafe 类的方法。</p><blockquote><p>注意 Unsafe 类的所有方法都是 native 修饰的，也就是说 unsafe 类中的方法都直接调用操作系统底层资源执行相应的任务！！！</p></blockquote><p>为什么 Atomic 修饰的包装类，能够保证原子性，依靠的就是底层的 unsafe 类</p><h3 id="2、变量-valueOffset"><a href="#2、变量-valueOffset" class="headerlink" title="2、变量 valueOffset"></a>2、变量 valueOffset</h3><p>表示该变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135835.png"></p><p>从这里我们能够看到，通过 valueOffset，直接通过内存地址，获取到值，然后进行加 1 的操作</p><h3 id="3、变量-value-用-volatile-修饰"><a href="#3、变量-value-用-volatile-修饰" class="headerlink" title="3、变量 value 用 volatile 修饰"></a>3、变量 value 用 volatile 修饰</h3><p>保证了多线程之间的内存可见性</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217135844.png"></p><p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行 compareAndSwapInt() 在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p><p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p><p>假设执行 compareAndSwapInt 返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用 synchronized，而用 CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的 do while 循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作 。</p><p>假设线程 A 和线程 B 同时执行 getAndInt 操作（分别跑在不同的 CPU 上）</p><ol><li>AtomicInteger 里面的 value 原始值为 3，即主内存中 AtomicInteger 的 value 为 3，根据JMM 模型，线程 A 和线程 B 各自持有一份价值为 3 的副本，分别存储在各自的工作内存</li><li>线程 A 通过 getIntVolatile(var1 , var2)  拿到 value 值3，这是线程 A 被挂起（该线程失去 CPU 执行权）</li><li>线程 B 也通过 getIntVolatile(var1, var2) 方法获取到 value 值也是3，此时刚好线程 B 没有被挂起，并执行了compareAndSwapInt 方法，比较内存的值也是 3，成功修改内存值为 4，线程B打完收工，一切OK</li><li>这是线程 A 恢复，执行 CAS 方法，比较发现自己手里的数字 3 和主内存中的数字 4 不一致，说明该值已经被其它线程抢先一步修改过了，那么 A 线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行 do while</li><li>线程 A 重新获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总能够看到，线程 A 继续执行 compareAndSwapInt 进行比较替换，直到成功。</li></ol><p>Unsafe 类 + CAS 思想： 也就是自旋，自我旋转！！！</p><p><strong>补充：</strong>上面说到的 Unsafe 类中的 compareAndSwapInt 是一个本地方法，该方法的实现位于unsafe.cpp 中</p><ul><li>先想办法拿到变量 value 在内存中的地址</li><li>通过 Atomic::cmpxchg 实现比较替换，其中参数 X 是即将更新的值，参数 e 是原内存的值</li></ul><hr><h2 id="CAS-存在的问题"><a href="#CAS-存在的问题" class="headerlink" title="CAS 存在的问题"></a>CAS 存在的问题</h2><p>CAS 是一种乐观锁，它避免了悲观锁独占锁对象的情况，同时也提高了并发性能</p><p>存在问题如下：</p><ul><li><p>乐观锁只能保证一个共享变量的原子操作。如果存在多个变量，乐观锁将显得力不从心【但互斥锁能轻易解决，不管对象数量的多少级对象颗粒的大小】</p></li><li><p><strong>长时间自旋可能导致开销大。</strong>加入 CAS 长时间操作不成功一直自旋，会给 CPU带来很大的开销。</p></li><li><p>*<em>ABA 问题  <em>。</em></em>CAS 的核心思想是通过比较内存值和预期值是否一样而判断内存值是否被更改过，但此判断逻辑不严谨，假如内存值为 A，后来一条线程修改为 B，最后又被另一个线程改成了 A，则 CAS 认为内存值并没有发生过改变，但实际情况是有被其他线程修改，这种情况对依赖过程值的情景的运算结果影响很大。</p><p>解决办法：<strong>引入版本号</strong>，每次变量更新都把版本号【时间戳】加一。</p></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的更新值 B。</p><p>CAS 是 compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止 ！！</p>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_谈谈volatile</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/1-%E8%B0%88%E8%B0%88volatile/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JUC/1-%E8%B0%88%E8%B0%88volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="1-谈谈Volatile"><a href="#1-谈谈Volatile" class="headerlink" title="1_谈谈Volatile"></a>1_谈谈Volatile</h1><h2 id="1-Volatile-和-JMM-内存模型的可见性"><a href="#1-Volatile-和-JMM-内存模型的可见性" class="headerlink" title="1_Volatile 和 JMM 内存模型的可见性"></a>1_Volatile 和 JMM 内存模型的可见性</h2><ul><li>JUC（java.util.concurrent）<ul><li>进程和线程<ul><li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li><li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li></ul></li><li>并发和并行<ul><li>并发：同时访问某个东西，就是并发</li><li>并行：一起做某些事情，就是并行</li></ul></li></ul></li><li>JUC 下的三个包<ul><li>java.util.concurrent<ul><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul></li></ul></li></ul><h3 id="谈谈你对-Volatile-的理解"><a href="#谈谈你对-Volatile-的理解" class="headerlink" title="谈谈你对 Volatile 的理解"></a>谈谈你对 Volatile 的理解</h3><p>volatile 在日常的单线程环境是应用不到的</p><p>volatile 是 Java 虚拟机提供的 <strong>轻量级</strong> 【乞丐版 synchronized】的同步机制。</p><p>volatile 修饰的变量具有三种特性：</p><ol><li>保证可见性</li><li><strong>不保证原子性</strong>【原子性：完整性，不可缺性，中间不可以被分割，要么成功，要么失败】</li><li>禁止指令重排序【计算机底层实现是：会在其前后加内存屏障，禁止内存屏障前后的指令进行重排序优化】</li></ol><h4 id="那你能否写一个-Demo-验证一下可见性-？"><a href="#那你能否写一个-Demo-验证一下可见性-？" class="headerlink" title="那你能否写一个 Demo 验证一下可见性 ？"></a>那你能否写一个 Demo 验证一下可见性 ？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始执行&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 线程睡眠3秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                date.setNumber();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟线程B：一直在这里等待循环，直到 number 的值不等于零</span></span><br><span class="line">        <span class="keyword">while</span> (date.number == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要变量的值被修改，就会执行下面的语句</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    <span class="comment">//volatile 保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程就是：</p><ul><li>线程 a 从主内存读取 共享变量 到对应的工作内存</li><li>对共享变量进行更改</li><li>线程 b 读取共享变量的值到对应的工作内存</li><li>线程 a 将修改后的值刷新到主内存，失效其他线程对 共享变量的副本</li><li>线程 b 对共享变量进行操作时，发现已经失效，重新从主内存读取最新值，放入到对应工作内存。</li></ul><h4 id="你能否写个-Demo-验证一下-不保证原子性？"><a href="#你能否写个-Demo-验证一下-不保证原子性？" class="headerlink" title="你能否写个 Demo 验证一下 不保证原子性？"></a>你能否写个 Demo 验证一下 不保证原子性？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Date2 date2 = <span class="keyword">new</span> Date2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启20个线程</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//每个线程执行1000次++操作</span></span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">0</span>;j &lt; <span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    date2.setNumberPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="built_in">String</span>.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让20个线程全部执行完</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123; <span class="comment">//main + GC</span></span><br><span class="line">            <span class="comment">//礼让线程</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看最终结果</span></span><br><span class="line">        System.out.println(date2.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date2</span></span>&#123;</span><br><span class="line">    volatile int number;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">setNumberPlus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//让其自增</span></span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细过程是：</p><ul><li><p>假设现在共享变量的值是 100 ，线程 A 需要对变量进行自增 1，首先它从主内存中读取变量值，由于 CPU 切换关系，此时切换到 B线程；  </p></li><li><p>B 线程也从主内存中读取变量值，此时读取到的变量值还是 100，然后在自己的工作内存中进行了 + 1 操作，但是还未刷新回主内存；</p></li><li><p>此时，CPU 又切换到了 A线程，由于 B 线程还未将工作内存中的值刷新回主内存，因此 A 线程中的值还是 100，A 线程对工作内存中的变量进行 + 1 操作；</p></li><li><p>线程 B 刷新 新的值 101 到主内存 ；</p></li><li><p>线程 A 刷新 新的值 101 到主内存；</p><p>结果就是：两次 +1 操作，却只进行了 1 次修改</p></li></ul><h4 id="那如何才能保证原子性呢-？"><a href="#那如何才能保证原子性呢-？" class="headerlink" title="那如何才能保证原子性呢 ？"></a>那如何才能保证原子性呢 ？</h4><p>方式1：使用 synchronized 【大材小用】</p><p>方式2：使用 JUC 下的 AtomicInteger 原子类【底层是基于 CAS】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Date3 date3 = <span class="keyword">new</span> Date3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启20个线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//每个线程执行1000次++操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    date3.setAtomic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让20个线程全部执行完</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123; <span class="comment">//主线程 + GC</span></span><br><span class="line">            Thread.yield();<span class="comment">//礼让线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看最终结果</span></span><br><span class="line">        System.out.println(date3.number); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date3</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个原子 Integer 包装类，默认为0</span></span><br><span class="line">    AtomicInteger number = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtomic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//相当于 atomicInter ++</span></span><br><span class="line">        number.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的-Demo-？"><a href="#什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的-Demo-？" class="headerlink" title="什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的 Demo ？"></a>什么是指令重排序？如果不重排会有什么问题？你能否写一个禁止指令重排序的 Demo ？</h4><p>为了提高性能，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105309.png"></p><p>单线程环境里面确保最终执行结果和代码顺序的结果一致 。</p><blockquote><p>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></p></blockquote><p>但是，当多线程交替执行时，由于编译器优化重排，两个线程在使用的变量能否保住一致性是无法确定的，结果无法预测 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date4</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a; <span class="comment">//使用 volatile 禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">5</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;打印成功&quot;</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile-针对指令重排做了啥"><a href="#volatile-针对指令重排做了啥" class="headerlink" title="volatile 针对指令重排做了啥"></a>volatile 针对指令重排做了啥</h4><p>volatile 实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象</p><p>首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，它的作用有两个：</p><ul><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）</li></ul><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器 和 CPU，不管什么指令都不能和这条 Memory Barrier 指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是刷新出各种 CPU 的缓存数，因此任何 CPU 上的线程都能读取到这些数据的最新版本。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105310.png"></p><p>也就是过在 volatile 的写 和 读的时候，加入屏障，防止出现指令重排的！！！</p><h4 id="那么你在什么场景下有使用到-volatile-呢-？"><a href="#那么你在什么场景下有使用到-volatile-呢-？" class="headerlink" title="那么你在什么场景下有使用到 volatile 呢 ？"></a>那么你在什么场景下有使用到 volatile 呢 ？</h4><p><strong>单例模式中【双重检查机制</strong>】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.提供静态变量保存实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton6 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供获取对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一重检查：针对很多个线程同时想要创建对象的情况</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步代码块锁定</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton6.class)&#123;</span><br><span class="line">     <span class="comment">//第二重锁检查(针对比如A,B两个线程都为null，第一个线程创建完对象，第二个等待锁的线程拿到锁的情况)</span></span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请你说说为什么要在这里加上 volatile 呢？</strong></p><p>因为创建对象分为 3 步：</p><ol><li>分配内存空间；</li><li>初始化对象</li><li>设置实例执行刚分配的内存地址【正常流程走：instance ! = null】</li></ol><p>但是，由于这 3 步<strong>不存在数据依赖关系</strong> ，所以可能进行重排序优化，造成下列现象：</p><ol><li>分配内存空间</li><li>设置实例执行刚分配的内存地址【instance ! = null 有名无实，初始化并未完成！】</li><li>初始化对象</li></ol><p><strong>所有当另一条线程访问 instance 时 不为null，但是 instance实例化未必已经完成，也就造成线程安全问题！</strong></p><hr><h3 id="JMM-是什么"><a href="#JMM-是什么" class="headerlink" title="JMM  是什么"></a>JMM  是什么</h3><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105311.png" style="zoom:67%;" /><p>JMM （Java 内存模型）是一种抽象的概念 <strong>并不真实存在</strong>，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素，不包括局部变量和方法参数，这是线程私有的，不存在竞争关系）的访问方式。</p><ul><li><p>具体的 JMM 规定如下：</p><ol><li> 所有 共享变量 储存于 主内存 中；</li><li> 每条线程拥有自己的工作内存，保存了被线程使用的变量的副本拷贝；</li><li> 线程对变量的所有操作（读，写）都必须在自己的 工作内存 中完成，而不能直接读写 主内存 中的变量；</li><li> 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存中转来完成</li></ol></li></ul><p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU</p><p>两个概念：主内存 和 工作内存</p><ul><li><p>主内存：就是计算机的内存，也就是经常提到的 8G 内存，16G 内存</p></li><li><p>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中</p><ul><li>当同时有三个线程同时访问 student 中的 age 变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝 。</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105312.png"></p><p>即：JMM 内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><hr><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>为什么这里主线程中某个值被更改后，其它线程能马上知晓呢？其实这里是用到了<strong>总线嗅探技术</strong></p><p>在说嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一。</p><p><strong>为了解决缓存一致性的问题</strong>，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有 MSI、MESI 等等。</p><h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><p>当 CPU 写数据时，如果发现操作的变量是共享变量，即在其它 CPU中 也存在该变量的副本，会发出信号通知其它 CPU 将该内存变量的缓存行设置为无效，因此当其它 CPU 读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。</p><h4 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h4><p><strong>那么是如何发现数据是否失效呢？</strong></p><p>这里是用到了总线嗅探技术，就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p><h4 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h4><p><strong>总线嗅探技术有哪些缺点？</strong></p><p>由于 volatile 的 MESI 缓存一致性协议，需要不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用 volatile 关键字，至于什么时候使用 volatile、什么时候用锁以及 Syschonized 都是需要根据实际场景的。</p><hr><h3 id="线程安全获得保证"><a href="#线程安全获得保证" class="headerlink" title="线程安全获得保证"></a>线程安全获得保证</h3><p><strong>工作内存与主内存同步延迟现象导致的可见性问题</strong></p><ul><li>可通过 synchronized 或 volatile 关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见 。</li></ul><p><strong>对于指令重排导致的可见性问题和有序性问题</strong></p><ul><li>可以使用 volatile 关键字解决，因为 volatile 关键字的另一个作用就是禁止重排序优化 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_垃圾收集器</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5_垃圾收集器"></a>5_垃圾收集器</h1><blockquote><p>问题5：GC垃圾回收算法和垃圾收集器关系？分别是什么请你谈谈？</p><ul><li>天上飞的理念，要有落地的实现（垃圾收集器就是GC垃圾回收算法的实现）</li><li>GC算法是内存回收的方法论，垃圾收集器就是算法的落地实现</li></ul></blockquote><p><strong>GC算法主要有以下几种：</strong></p><ul><li><del>引用计数（几乎不用，无法解决循环引用的问题）</del></li><li>复制拷贝（用于新生代）</li><li>标记清除（用于老年代）</li><li>标记整理（用于老年代）</li><li>因为目前为止还没有完美的收集器出现，更没有万能的收集器，只是针对具体应用最合适的收集器，进行<font color='red'>;</font></li></ul><hr><p> <strong>四种主要的垃圾收集器：</strong></p><ul><li>Serial：串行回收 <code>-XX:+UseSeriallGC</code></li><li>Parallel：并行回收 <code>-XX:+UseParallelGC</code></li><li>CMS：并发标记清除</li><li>G1</li><li>ZGC：（java 11 出现的）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105011.png"></p><hr><h2 id="四种主要的垃圾收集器"><a href="#四种主要的垃圾收集器" class="headerlink" title="四种主要的垃圾收集器"></a>四种主要的垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><blockquote><p>串行垃圾回收器，它为单线程环境设计且值<code>使用一个线程进行垃圾收集，会暂停所有的用户线程</code>，只有当垃圾回收完成时，才会重新唤醒主线程继续执行。所以不适合服务器环境</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105012.png"></p><hr><h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><blockquote><p>并行垃圾收集器，<code>多个垃圾收集线程并行工作，此时用户线程也是阻塞的</code>，适用于科学计算 / 大数据处理等弱交互场景，</p><p>也就是说Serial 和 Parallel其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停，但是并行垃圾收集器处理时间，<strong>肯定比串行的垃圾收集器要更短</strong></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105013.png"></p><hr><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><blockquote><p>并发标记清除，<code>用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程</code>，互联网公司都在使用，适用于响应时间有要求的场景。</p><p>并发是可以有交互的，也就是说可以一边进行收集，一边执行应用程序。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105014.png"></p><hr><h3 id="串行-并行-并发-垃圾收集器总结"><a href="#串行-并行-并发-垃圾收集器总结" class="headerlink" title="串行/并行/并发 垃圾收集器总结"></a>串行/并行/并发 垃圾收集器总结</h3><p>注意：并行垃圾回收在单核CPU下可能会更慢</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105015.png"></p><hr><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><blockquote><p>G1垃圾回收器将堆内存<code>分割成不同区域，然后并发的进行垃圾回收</code>.</p><p>Java 7 和 Java 8 开始使用G1，Java 11开始换成了ZGC</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105016.png"></p><hr><h2 id="默认垃圾收集器"><a href="#默认垃圾收集器" class="headerlink" title="默认垃圾收集器"></a>默认垃圾收集器</h2><blockquote><p>问题7：怎么查看服务器的默认GC收集器？生产上如何配置GC收集器？谈谈你的GC收集器的理解？</p></blockquote><h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><p>使用下面JVM命令，查看配置的初始参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure><p>然后运行一个程序后，能够看到它的一些初始配置信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105017.png"></p><p>移动到最后一句，就能看到 <code>-XX:+UseParallelGC</code> 说明使用的是并行垃圾回收。</p><hr><h3 id="默认垃圾收集器种类"><a href="#默认垃圾收集器种类" class="headerlink" title="默认垃圾收集器种类"></a>默认垃圾收集器种类</h3><p>Java中一共有7大垃圾收集器</p><ul><li>UserSerialGC：串行垃圾收集器</li><li>UserParallelGC：并行垃圾收集器</li><li>UseConcMarkSweepGC：（CMS）并发标记清除</li><li>UseParNewGC：年轻代的并行垃圾回收器</li><li>UseParallelOldGC：老年代的并行垃圾回收器</li><li>UseG1GC：G1垃圾收集器</li><li><del>UserSerialOldGC：串行老年代垃圾收集器（已经被移除）</del></li></ul><hr><p><strong>底层源码：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105018.png"></p><hr><h3 id="各垃圾收集器的使用范围"><a href="#各垃圾收集器的使用范围" class="headerlink" title="各垃圾收集器的使用范围"></a>各垃圾收集器的使用范围</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105019.png"></p><p>新生代使用的：</p><ul><li>Serial Copying： UserSerialGC，串行垃圾回收器</li><li>Parallel Scavenge：UserParallelGC，并行垃圾收集器</li><li>ParNew：UserParNewGC，新生代并行垃圾收集器</li></ul><p>老年区使用的：</p><ul><li><del>Serial Old：UseSerialOldGC，老年代串行垃圾收集器</del></li><li>Parallel Compacting（Parallel Old）：UseParallelOldGC，老年代并行垃圾收集器</li><li>CMS：UseConcMarkSwepp，并行标记清除垃圾收集器</li></ul><p>各区都能使用的：</p><p>G1：UseG1GC，G1垃圾收集器</p><blockquote><p><font color='red'>垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大</font></p></blockquote><hr><p>HotSpot中包含的收集器如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105020.png"></p><h3 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h3><ul><li>DefNew：Default New Generation</li><li>Tenured：Old</li><li>ParNew：Parallel New Generation</li><li>PSYoungGen：Parallel Scavenge</li><li>ParOldGen：Parallel Old Generation</li></ul><hr><h3 id="Java中的Server和Client模式"><a href="#Java中的Server和Client模式" class="headerlink" title="Java中的Server和Client模式"></a>Java中的Server和Client模式</h3><blockquote><p>使用范围：一般使用Server模式，Client模式基本不会使用</p></blockquote><p>操作系统</p><ul><li>32位的Window操作系统，不论硬件如何都默认使用Client的JVM模式</li><li>32位的其它操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式</li><li>64位只有Server模式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105021.png"></p><hr><h2 id="新生代下的垃圾收集器"><a href="#新生代下的垃圾收集器" class="headerlink" title="新生代下的垃圾收集器"></a>新生代下的垃圾收集器</h2><h3 id="串行GC-Serial"><a href="#串行GC-Serial" class="headerlink" title="串行GC(Serial)"></a>串行GC(Serial)</h3><blockquote><p>串行GC（Serial）（Serial Copying）：是一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105022.png"></p><p>串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在垃圾收集过程中可能会产生较长的停顿(Stop-The-World 状态)。 虽然在收集垃圾过程中需要暂停所有其它的工作线程，但是它<strong>简单高效</strong>，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是Java虚拟机运行在Client模式下默认的新生代垃圾收集器</p><p><font color='red'>对应JVM参数是：-XX:+UseSerialGC</font></p><p><font color='red'>开启后会使用：Serial(Young区用) + Serial Old(Old区用) 的收集器组合</font></p><p><strong>表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法</strong></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105023.png"></p><p>对应： DefNew + Tenured</p><hr><h3 id="并行GC-ParNew"><a href="#并行GC-ParNew" class="headerlink" title="并行GC(ParNew)"></a>并行GC(ParNew)</h3><blockquote><p>并行收集器，使用<code>多线程进行垃圾回收</code>，在垃圾收集，会 Stop-the-World 暂停其他所有的工作线程直到它收集结束</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105024.png"></p><p>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景时配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。<strong>它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</strong></p><p><font color='red'>常见对应JVM参数：-XX:+UseParNewGC 启动ParNew收集器，只影响新生代的收集，不影响老年代</font></p><p><font color='red'>开启上述参数后，会使用：ParNew（Young区用） + Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</font></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParNewGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105025.png"></p><p>但是会出现警告，即 ParNew 和 Serial Old 这样搭配，Java8已经不再被推荐</p><p>对应： ParNew + Tenured</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105020.png"></p><p>备注： -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数</p><hr><h3 id="并行回收GC（Parallel）-（Parallel-Scavenge）"><a href="#并行回收GC（Parallel）-（Parallel-Scavenge）" class="headerlink" title="并行回收GC（Parallel）/ （Parallel Scavenge）"></a>并行回收GC（Parallel）/ （Parallel Scavenge）</h3><blockquote><p>因为Serial 和 ParNew都不推荐使用了，因此现在新生代默认使用的是Parallel Scavenge，也就是新生代和老年代都是使用并行</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105026.png"></p><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。一句话：<strong>串行收集器在新生代和老年代的并行化</strong></p><p>它关注的重点是：</p><p><font color='red'>可控制的吞吐量（Thoughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。</font>高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。</p><p><font color='red'>自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。</font>（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间( -XX:MaxGCPauseMills)）或最大的吞吐量。</p><p><font color='red'>常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC（可互相激活）使用Parallel Scanvenge收集器</font></p><p><strong>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</strong></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105027.png"></p><p>对应：PSYoungGen + ParOldGen</p><hr><h2 id="老年代下的垃圾收集器"><a href="#老年代下的垃圾收集器" class="headerlink" title="老年代下的垃圾收集器"></a>老年代下的垃圾收集器</h2><h3 id="并行GC（Parallel-Old）-（Parallel-MSC）"><a href="#并行GC（Parallel-Old）-（Parallel-MSC）" class="headerlink" title="并行GC（Parallel Old）/ （Parallel MSC）"></a>并行GC（Parallel Old）/ （Parallel MSC）</h3><blockquote><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p></blockquote><p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。<font color='red'>在JDK1.6以前(Parallel Scavenge + Serial Old)</font></p><p>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以考虑新生代Parallel Scavenge和老年代Parallel Old 收集器的搭配策略。<font color='red'>在JDK1.8及后（Parallel Scavenge + Parallel Old）</font></p><p><font color='red'>JVM常用参数：-XX +UseParallelOldGC：使用Parallel Old收集器，设置该参数后，新生代Parallel+老年代 Parallel Old</font></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105028.png"></p><hr><p>实例：</p><p>使用老年代并行收集器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelOldlGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105029.png"></p><p>对应：PSYoungGen + ParOldGen</p><hr><h3 id="并发标记清除GC（CMS）"><a href="#并发标记清除GC（CMS）" class="headerlink" title="并发标记清除GC（CMS）"></a>并发标记清除GC（CMS）</h3><blockquote><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以最短回收停顿时间为目标的收集器适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，<strong>希望系统停顿时间最短。</strong></p><p>CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105030.png"></p><p>Concurrent Mark Sweep：并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行</p><p><font color='red'>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后，会自动将 -XX:+UseParNewGC打开，开启该参数后，使用ParNew(young 区用）+ CMS（Old 区用） + Serial Old 的收集器组合，Serial Old将作为CMS出错的后备收集器</font></p><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105031.png"></p><hr><h4 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h4><ul><li>初始标记（CMS initial mark）<ul><li>只是标记一个GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程</li></ul></li><li>并发标记（CMS concurrent mark）和用户线程一起<ul><li>进行GC Roots跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象</li></ul></li><li>重新标记（CMS remark）<ul><li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，在做修正</li></ul></li><li>并发清除（CMS concurrent sweep）和用户线程一起<ul><li>清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105032.png"></p><hr><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li><font color='red'>并发收集低停顿</font></li></ul><p>缺点：</p><ul><li>并发执行，对CPU资源压力大，采用的标记清除算法<font color='red'>会导致大量碎片</font></li></ul><p>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW方式进行一次GC，从而造成较大的停顿时间</p><p>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩，CMS也提供了参数 -XX:CMSFullGCSBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</p><hr><h3 id="串行GC（Serial-Old）-Serial-MSC"><a href="#串行GC（Serial-Old）-Serial-MSC" class="headerlink" title="串行GC（Serial Old） / (Serial MSC)"></a>串行GC（Serial Old） / (Serial MSC)</h3><blockquote><p>Serial Old是Serial垃圾收集器老年代版本，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机中默认的老年代垃圾收集器</p></blockquote><p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）</p><ul><li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用（Parallel Scavenge + Serial Old）</li><li>作为老年代版中使用CMS收集器的后备垃圾收集方案。</li></ul><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialOldlGC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105033.png"></p><p><del><font color='red'>该垃圾收集器，目前已经不推荐使用了！！！</font></del></p><hr><h2 id="为什么新生代采用复制算法，老年代采用标整算法"><a href="#为什么新生代采用复制算法，老年代采用标整算法" class="headerlink" title="为什么新生代采用复制算法，老年代采用标整算法"></a>为什么新生代采用复制算法，老年代采用标整算法</h2><p><strong>新生代使用复制算法</strong></p><blockquote><p>因为新生代对象的生存时间比较短，80%的都要回收的对象，采用标记-清除算法则内存碎片化比较严重，采用复制算法可以灵活高效，且便与整理空间。</p></blockquote><p><strong>老年代采用标记整理</strong></p><blockquote><p>标记整理算法主要是为了解决标记清除算法存在内存碎片的问题，又解决了复制算法两个Survivor区的问题，因为老年代的空间比较大，不可能采用复制算法，特别占用内存空间</p></blockquote><h2 id="垃圾收集器如何选择"><a href="#垃圾收集器如何选择" class="headerlink" title="垃圾收集器如何选择"></a>垃圾收集器如何选择</h2><p><strong>组合的选择</strong></p><ul><li>单CPU或者小内存，单机程序<ul><li>-XX:+UseSerialGC</li></ul></li><li>多CPU，需要最大的吞吐量，如后台计算型应用<ul><li>-XX:+UseParallelGC（这两个相互激活）</li><li>-XX:+UseParallelOldGC</li></ul></li><li>多CPU，追求低停顿时间，需要快速响应如互联网应用<ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+ParNewGC</li></ul></li></ul><table><thead><tr><th>参数</th><th>新生代垃圾收集器</th><th>新生代算法</th><th>老年代垃圾收集器</th><th>老年代算法</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>SerialGC</td><td>复制</td><td>SerialOldGC</td><td>标记整理</td></tr><tr><td>-XX:+UseParNewGC</td><td>ParNew</td><td>复制</td><td>SerialOldGC</td><td>标记整理</td></tr><tr><td>-XX:+UseParallelGC</td><td>Parallel [Scavenge]</td><td>复制</td><td>Parallel Old</td><td>标记整理</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>ParNew</td><td>复制</td><td>CMS + Serial Old的收集器组合，Serial Old作为CMS出错的后备收集器</td><td><strong>标记清除</strong></td></tr><tr><td>-XX:+UseG1GC</td><td>G1整体上采用标记整理算法</td><td>局部复制</td><td></td><td></td></tr></tbody></table><hr><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><blockquote><p>问题8：G1垃圾收集器</p></blockquote><p>开启G1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><p><strong>以前收集器的特点：</strong></p><ul><li>年轻代和老年代是各自独立且连续的内存块</li><li>年轻代收集使用单eden + S0 + S1 进行复制算法</li><li>老年代收集必须扫描珍整个老年代区域</li><li>都是以尽可能少而快速地执行GC为设计原则</li></ul><hr><h3 id="G1是什么"><a href="#G1是什么" class="headerlink" title="G1是什么"></a>G1是什么</h3><blockquote><p>G1：Garbage-First 收集器，是一款面向服务端应用的收集器，应用在多处理器和大容量内存环境中，<code>在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求。</code></p></blockquote><p>另外，它还具有一下特征：</p><ul><li>像CMS收集器一样，能与应用程序并发执行</li><li>整理空闲空间更快</li><li>需要更多的时间来预测GC停顿时间</li><li>不希望牺牲大量的吞吐量性能</li><li>不需要更大的Java Heap</li></ul><p>G1收集器设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色</p><ul><li>G1是一个有整理内存过程的垃圾收集器，<font color='red'>不会产生很多内存碎片。</font></li><li>G1的Stop The World（STW）更可控，<font color='red'>G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</font></li></ul><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器</p><p>G1是在2012才在JDK1.7中可用，Oracle官方计划在JDK9中将G1变成默认的垃圾收集器以替代CMS，它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换Java8以前的CMS收集器</p><p><font color='orange'>主要改变时：Eden，Survivor 和 Tenured 等内存区域不再是连续了，而是变成一个个大小一样的region，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</font></p><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW</li><li>G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片</li><li>宏观上看G1之中不再区分年轻代和老年代。把内存划分成多个独立的子区域（Region），可以近似理解为一个围棋的棋盘</li><li>G1收集器里面将整个内存区域都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但他们不再是物理隔离的，而是通过一部分Region的集合且不需要Region是连续的，也就是说依然会采取不同的GC方式来处理不同的区域</li><li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的Survivor（to space）堆做复制准备，<strong>G1只有逻辑上的分代概念</strong>，或者说每个分区都可能随G1的运行在不同代之间前后切换。</li></ul><hr><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><blockquote><p>Region区域化垃圾收集器，化整为零，打破了原来新生区和老年区的壁垒，<code>避免了全内存扫描，只需要按照区域来进行扫描即可。</code></p></blockquote><p>区域化内存划片Region，整体遍为了一些列不连续的内存区域，避免了全内存区的GC操作。</p><p>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置子区域大小</p><p><strong>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可</strong>，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code> 可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。</p><p>大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048 = 64G内存</p><p>Region区域化垃圾收集器</p><h4 id="Region区域化垃圾收集器"><a href="#Region区域化垃圾收集器" class="headerlink" title="Region区域化垃圾收集器"></a>Region区域化垃圾收集器</h4><p>G1将新生代、老年代的物理空间划分取消了</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105034.png"></p><p>同时对内存进行了区域划分</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105035.png" alt="image-20200326120130427"></p><p>G1算法将堆划分为若干个区域（Reign），它仍然属于分代收集器，这些Region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</p><p>这些Region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片的问题存在了。</p><p>在G1中，还有一种特殊的区域，叫做Humongous（巨大的）区域，如果一个对象占用了空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象，这些巨型对象默认直接分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p><hr><h4 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h4><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是<strong>小区域收集 + 形成连续的内存块</strong>，避免内碎片</p><ul><li>Eden区的数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会晋升到Old区</li><li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区</li><li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105036.png" alt="image-20200326121409237"></p><p>回收完成后</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105037.png" alt="image-20200326121622208"></p><p>小区域收集 + 形成连续的内存块，最后在收集完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p><hr><h4 id="四步过程"><a href="#四步过程" class="headerlink" title="四步过程"></a>四步过程</h4><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217105038.png"></p><hr><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>开发人员仅仅需要申明以下参数即可</p><p>三步归纳：<code>-XX:+UseG1GC -Xmx32G -XX:MaxGCPauseMillis=100</code></p><p>-XX:MaxGCPauseMillis=n：最大GC停顿时间单位毫秒，这是个软目标，JVM尽可能停顿小于这个时间 </p><p><strong>常用配置（了解）：</strong></p><ul><li>-XX:UseG1GC：使用G1垃圾回收器</li><li>-XX:G1HeapRegionSize=n：划分region大小</li><li>-XX:MaxGCPauseMillis：最大GC停顿时间，是个软目标，尽量达到。</li><li>-XX:InitiatingHeapOccupancyPercent：堆占用了多少执行GC，默认45%</li><li>-XX:ConcGCThreads：并发GC使用的线程数</li><li>-XX:G1ReservePercent：设置为空闲空间的预留内存比</li></ul><hr><h3 id="G1和CMS比较"><a href="#G1和CMS比较" class="headerlink" title="G1和CMS比较"></a>G1和CMS比较</h3><ul><li>G1不会产生内碎片</li><li>是可以精准控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。</li></ul><hr><h2 id="SpringBoot结合JVMGC"><a href="#SpringBoot结合JVMGC" class="headerlink" title=" SpringBoot结合JVMGC"></a><font color='red'> SpringBoot结合JVMGC</font></h2><p>启动微服务时候，就可以带上JVM和GC的参数</p><ul><li>IDEA开发完微服务工程</li><li>maven进行clean package：打成jar包或者war包</li><li>要求微服务启动的时候，同时配置我们的JVM/GC的调优参数<ul><li>我们就可以根据具体的业务配置我们启动的JVM参数</li></ul></li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xms1024m -Xmx1024 -XX:UseG1GC -jar   xxx.jar</span><br></pre></td></tr></table></figure><p>可以使用<code>jps -l</code>查看端口号，使用<code>jinfo -flags 端口号</code>查看我们配置的参数</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_Java内存溢出OOM</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/4-Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAOOM/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/4-Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAOOM/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Java内存溢出OOM"><a href="#4-Java内存溢出OOM" class="headerlink" title="4_Java内存溢出OOM"></a>4_Java内存溢出OOM</h1><p>JVM中常见的两个错误</p><p>StackoverFlowError ：栈溢出</p><p>OutofMemoryError: java heap space：堆溢出</p><p>除此之外，还有以下的错误</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><hr><p><strong>架构：</strong></p><p>OutOfMemoryError和StackOverflowError是属于Error，不是Exception</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104822.png"></p><h2 id="StackoverFlowError"><a href="#StackoverFlowError" class="headerlink" title="StackoverFlowError"></a>StackoverFlowError</h2><blockquote><p>堆栈溢出，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p></blockquote><p>栈一般是512K，不断的深度调用，直到栈被撑破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowErrorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈一般是512K，不断的深度调用，直到栈被撑破</span><br><span class="line">     * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void stackOverflowError() &#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.moxi.interview.study.oom.StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:17)</span><br></pre></td></tr></table></figure><hr><h2 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h2><blockquote><p><code>java heap space</code></p><p>创建了很多对象，导致堆空间不够存储</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Java堆内存不足</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JavaHeapSpaceDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 堆空间的大小 -Xms10m -Xmx10m</span><br><span class="line">        &#x2F;&#x2F; 创建一个 80M的字节数组</span><br><span class="line">        byte [] bytes &#x3D; new byte[80 * 1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个80M的数组，会直接出现Java heap space</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><hr><h2 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h2><blockquote><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，<font color='red'>超过了98%的时间用来做GC，并且回收了不到2%的堆内存</font></p></blockquote><p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p><p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104823.png"></p><hr><p><strong>代码演示：</strong></p><p>为了更快的达到效果，我们首先需要设置JVM启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br></pre></td></tr></table></figure><p>这个异常出现的步骤就是，我们不断的向list中插入String对象，直到启动GC回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * GC 回收超时</span><br><span class="line"> * JVM参数配置: -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class GCOverheadLimitDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                list.add(String.valueOf(++i).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;***************i:&quot; + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7106K-&gt;7106K(7168K)] 9154K-&gt;9154K(9728K), [Metaspace: 3504K-&gt;3504K(1056768K)], 0.0311093 secs] [Times: user&#x3D;0.13 sys&#x3D;0.00, real&#x3D;0.03 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7136K-&gt;667K(7168K)] 9184K-&gt;667K(9728K), [Metaspace: 3540K-&gt;3540K(1056768K)], 0.0058093 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 114K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 5% used [0x00000000ffd00000,0x00000000ffd1c878,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 667K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a6ff8,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3605K, capacity 4540K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 399K, capacity 428K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">at java.lang.Integer.toString(Integer.java:403)</span><br><span class="line">at java.lang.String.valueOf(String.java:3099)</span><br><span class="line">at com.moxi.interview.study.oom.GCOverheadLimitDemo.main(GCOverheadLimitDemo.java:18)</span><br></pre></td></tr></table></figure><p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 <code>GC overhead limit</code></p><hr><h2 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h2><blockquote><p>Netty + NIO：<code>这是由于NIO引起的</code></p><p>写NIO程序的时候经常会使用ByteBuffer来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。</p></blockquote><p>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><ul><li>ByteBuffer.allocate(capability)：第一种方式是<font color='red'>分配JVM堆内存，属于GC管辖范围</font>，由于需要拷贝所以速度相对较慢</li><li>ByteBuffer.allocteDirect(capability)：第二种方式是<font color='red'>分配OS本地内存，不属于GC管辖范围</font>，由于不需要内存的拷贝，所以速度相对较快</li></ul><p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104824.png"></p><p><font color='orange'>一句话说：本地内存不足，但是堆内存充足的时候，就会出现这个问题</font></p><hr><p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br></pre></td></tr></table></figure><p>然后我们申请一个6M的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只设置了5M的物理内存使用，但是却分配 6M的空间</span><br><span class="line">ByteBuffer bb &#x3D; ByteBuffer.allocateDirect(6 * 1024 * 1024);</span><br></pre></td></tr></table></figure><p>这个时候，运行就会出现问题了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">配置的maxDirectMemory：5.0MB</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2030K-&gt;488K(2560K)] 2030K-&gt;796K(9728K), 0.0008326 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 308K-&gt;712K(7168K)] 796K-&gt;712K(9728K), [Metaspace: 3512K-&gt;3512K(1056768K)], 0.0052052 secs] [Times: user&#x3D;0.09 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:693)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">at com.moxi.interview.study.oom.DIrectBufferMemoryDemo.main(DIrectBufferMemoryDemo.java:19)</span><br></pre></td></tr></table></figure><hr><h2 id="unable-to-create-new-native-thread"><a href="#unable-to-create-new-native-thread" class="headerlink" title="unable to create new native thread"></a>unable to create new native thread</h2><blockquote><p>不能够创建更多的新的线程了，也就是说<code>创建线程的上限达到了</code></p></blockquote><p>在高并发场景的时候，会应用到</p><p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p><p><strong>导致原因：</strong></p><ul><li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li><li>服务器并不允许你的应用程序创建这么多线程，linux系统默认运行单个进程可以创建的线程为1024个，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li></ul><p><strong>解决方法：</strong></p><ol><li>想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li><li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过修改linux服务器配置，扩大linux默认限制</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">![4](images&#x2F;4.png)&#x2F;**</span><br><span class="line"> * 无法创建更多的线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UnableCreateNewThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; ; i++) &#123;</span><br><span class="line">            System.out.println(&quot;************** i &#x3D; &quot; + i);</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，就会出现下列的错误，线程数大概在 900多个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to cerate new native thread</span><br></pre></td></tr></table></figure><p>如何查看线程数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -u</span><br></pre></td></tr></table></figure><p>修改配置方法：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104825.png"></p><hr><h2 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h2><blockquote><p>元空间内存不足，Matespace元空间应用的是本地内存</p><p><code>-XX:MetaspaceSize</code> 的初始化化大小为20M</p></blockquote><h3 id="元空间是什么"><a href="#元空间是什么" class="headerlink" title="元空间是什么"></a>元空间是什么</h3><p><strong>元空间就是我们的方法区，存放的是类模板，类信息，常量池等</strong></p><p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p><p>永久代（java8后背元空间Metaspace取代了）存放了以下信息：</p><ul><li>虚拟机加载的类信息</li><li>常量池</li><li>静态变量</li><li>即时编译后的代码</li></ul><hr><p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;8m -XX:MaxMetaspaceSize&#x3D;8m</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 元空间溢出</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MetaspaceOutOfMemoryDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态类</span><br><span class="line">    static class OOMTest &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟计数多少次以后发生异常</span><br><span class="line">        int i &#x3D;0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                &#x2F;&#x2F; 使用Spring的动态字节码技术</span><br><span class="line">                Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">                enhancer.setSuperclass(OOMTest.class);</span><br><span class="line">                enhancer.setUseCache(false);</span><br><span class="line">                enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">                        return methodProxy.invokeSuper(o, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;发生异常的次数:&quot; + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发生异常的次数: 201</span><br><span class="line">java.lang.OutOfMemoryError:Metaspace</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_Java中的引用</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/3-Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/3-Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Java中的引用"><a href="#3-Java中的引用" class="headerlink" title="3_Java中的引用"></a>3_Java中的引用</h1><p>在原来的时候，我们谈到一个类的实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; new Person()</span><br></pre></td></tr></table></figure><p>在等号的左边，就是一个对象的引用，存储在栈中</p><p>而等号右边，就是实例化的对象，存储在堆中</p><p>其实这样的一个引用关系，就被称为强引用</p><hr><p> 整体架构</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104721.png"></p><hr><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><blockquote><p>当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，<font color='red'>就算是出现了OOM也不会对该对象进行回收，打死也不回收~！</font></p></blockquote><p>强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。</p><p>在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，<strong>因此强引用是造成Java内存泄漏的主要原因之一。</strong></p><p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用于或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p><hr><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这样定义的默认就是强应用</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用第二个引用，指向刚刚创建的Object对象</span></span><br><span class="line">        Object obj2 = obj1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置空</span></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并没有将该对象进行垃圾回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">java.lang.Object@14ae5a5</span><br></pre></td></tr></table></figure><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><blockquote><p>软引用是一种相对弱化了一些的引用，需要用<code>Java.lang.ref.SoftReference</code>类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p><ul><li><font color='red'>当系统内存充足时，它不会被回收</font></li><li><font color='red'>当系统内存不足时，它会被回收</font></li></ul></blockquote><p>软引用通常在对内存敏感的程序中，比如高速缓存就用到了软引用，<strong>内存够用 的时候就保留，不够用就回收</strong></p><hr><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存够用的时候</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个强应用</span></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个软引用</span></span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span></span><br><span class="line"><span class="comment">     * -Xms5m -Xmx5m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softRefMemoryNoEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个强应用</span></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个软引用</span></span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟OOM自动GC</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建30M的大对象</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        softRefMemoryEnough();</span><br><span class="line"></span><br><span class="line">        softRefMemoryNoEnough();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>情况一：</strong></p><p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p><p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p><p>然后我们把o1设置为null，执行手动GC后，我们发现softReference的值还存在，说明内存充足的时候，软引用的对象不会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1396K-&gt;504K(1536K)] 1504K-&gt;732K(5632K), <span class="number">0.0007842</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 504K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 228K-&gt;651<span class="title">K</span><span class="params">(4096K)</span>] 732K-&gt;651<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3480K-&gt;3480<span class="title">K</span><span class="params">(1056768K)</span>], 0.0058450 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">java.lang.Object@14ae5a5</span><br></pre></td></tr></table></figure><hr><p><strong>情况二：</strong></p><p>下面我们看当内存不够的时候，我们使用了JVM启动参数配置，给初始化堆内存为5M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms5m -Xmx5m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>但是在创建对象的时候，我们创建了一个30M的大对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建30M的大对象</span><br><span class="line">byte[] bytes &#x3D; new byte[30 * 1024 * 1024];</span><br></pre></td></tr></table></figure><p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明，软引用在内存不足的时候，会自动回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@7f31245a</span><br><span class="line">java.lang.Object@7f31245a</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 31K-&gt;160K(1536K)] 682K-&gt;811K(5632K), <span class="number">0.0003603</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 160K-&gt;96K(1536K)] 811K-&gt;747K(5632K), <span class="number">0.0006385</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 96K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 651K-&gt;646<span class="title">K</span><span class="params">(4096K)</span>] 747K-&gt;646<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3488K-&gt;3488<span class="title">K</span><span class="params">(1056768K)</span>], 0.0067976 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 646K-&gt;646K(5632K), <span class="number">0.0004024</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(1536K)</span>] [ParOldGen: 646K-&gt;627<span class="title">K</span><span class="params">(4096K)</span>] 646K-&gt;627<span class="title">K</span><span class="params">(5632K)</span>, [Metaspace: 3488K-&gt;3488<span class="title">K</span><span class="params">(1056768K)</span>], 0.0065506 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><hr><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><blockquote><p><font color='red'>不管内存是否够，只要有GC操作就会进行回收</font></p><p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的空间。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看结果，能够发现，我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5246K-&gt;808K(76288K)] 5246K-&gt;816K(251392K), 0.0008236 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;675K(175104K)] 816K-&gt;675K(251392K), [Metaspace: 3494K-&gt;3494K(1056768K)], 0.0035953 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line"></span><br><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure><hr><h2 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h2><blockquote><p>场景：假如有一个应用需要读取大量的本地图片</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能</li><li>如果一次性全部加载到内存中，又可能造成内存溢出</li></ul><p>说明：下面方式使用<code>弱引用</code>也可以完成！</p></blockquote><p>此时使用软引用可以解决这个问题</p><p><strong>设计思路：</strong> 使用HashMap来保存图片的路径和相应图片<code>对象关联的软引用</code>之间的映射关系，<font color='red'>在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache &#x3D; new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure><hr><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>比如一些常常和底层打交道的，mybatis等，底层都应用到了WeakHashMap</p><blockquote><p>WeakHashMap和HashMap类似，只不过它的Key是使用了弱引用的，也就是说，当执行GC的时候，HashMap中的key会进行回收，</p></blockquote><p>下面我们使用例子来测试一下</p><p>我们使用了两个方法，一个是普通的HashMap方法</p><p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    String value = <span class="string">&quot;HashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    System.gc();</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个是使用了WeakHashMap，完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        myHashMap();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        myWeakHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        String value = <span class="string">&quot;HashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        String value = <span class="string">&quot;WeakHashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;1&#x3D;HashMap&#125;</span><br><span class="line">&#123;1&#x3D;HashMap&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#123;1&#x3D;WeakHashMap&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p><p>但是WeakHashMap，在进行GC操作后，弱引用的就会被回收</p><hr><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><blockquote><p>虚引用又称为幽灵引用，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p><p>顾名思义，就是<code>形同虚设</code>，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p><p>如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，<strong>虚引用必须和引用队列ReferenceQueue联合使用。</strong></p><p><font color='red'>虚引用的主要作用和跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</font></p><p><strong>PhantomReference的get方法总是返回null</strong>，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>换句话说，设置虚引用关联的唯一目的，<strong>就是在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</strong></p><p>这个就相当于Spring AOP里面的后置通知</p></blockquote><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><blockquote><p>一般用于在回收时候做通知相关操作</p></blockquote><p>软引用，弱引用，虚引用在回收之前，需要在引用队列保存一下</p><p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object o1 &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建引用队列</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个弱引用</span><br><span class="line">WeakReference&lt;Object&gt; weakReference &#x3D; new WeakReference&lt;&gt;(o1, referenceQueue);</span><br></pre></td></tr></table></figure><p>那么在进行GC回收的时候，弱引用和虚引用的对象都会被回收，但是在回收之前，它会被送至引用队列中</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个弱引用</span></span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个弱引用</span></span><br><span class="line"><span class="comment">//        PhantomReference&lt;Object&gt; weakReference = new PhantomReference&lt;&gt;(o1, referenceQueue);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        <span class="comment">// 取队列中的内容</span></span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">        o1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行GC操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        <span class="comment">// 取队列中的内容</span></span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">null</span><br><span class="line">执行GC操作</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">java.lang.ref.WeakReference@7f3124</span><br></pre></td></tr></table></figure><p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例被放置引用队列中了，我们可以通过引用队列进行一些后置操作</p><hr><h2 id="GCRoots和四大引用小总结"><a href="#GCRoots和四大引用小总结" class="headerlink" title="GCRoots和四大引用小总结"></a>GCRoots和四大引用小总结</h2><ul><li>红色部分在垃圾回收之外，也就是强引用的</li><li>蓝色部分：属于软引用，在内存不够的时候，才回收</li><li>虚引用和弱引用：每次垃圾回收的时候，都会被干掉，但是它在干掉之前还会存在引用队列中，我们可以通过引用队列进行一些通知机制</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104722.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_JVM参数调优</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/2-JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/2-JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="2-JVM参数调优"><a href="#2-JVM参数调优" class="headerlink" title="2_JVM参数调优"></a>2_JVM参数调优</h1><blockquote><p>题目2：你说你做过JVM调优和参数配置，请问如何盘点查看 <code>JVM系统默认值</code>？</p></blockquote><p>使用 jps 和 jinfo 进行查看</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 调整JVM初始化参数（-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收）</span></span><br><span class="line">-Xms：初始堆空间</span><br><span class="line">-Xmx：堆最大值</span><br><span class="line">-Xss：栈空间</span><br></pre></td></tr></table></figure><hr><h2 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h2><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><blockquote><p>从JDK1.0 - Java12都在，很稳定</p></blockquote><ul><li>-version</li><li>-help</li><li>java -showversion</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104624.png"></p><hr><h3 id="X参数（了解）"><a href="#X参数（了解）" class="headerlink" title="X参数（了解）"></a>X参数（了解）</h3><ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104625.png"></p><hr><h3 id="XX参数（重点）"><a href="#XX参数（重点）" class="headerlink" title="XX参数（重点）"></a><font color='red'>XX参数（重点）</font></h3><h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><blockquote><p>公式：</p><ul><li>-XX:+ 或者-某个属性</li><li>+表示开启，-表示关闭</li></ul></blockquote><hr><h5 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h5><blockquote><p>-XX:-PrintGCDetails：表示关闭了GC详情输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps：查看java的后台进程</span><br><span class="line">jinfo：查看正在运行的java程序</span><br></pre></td></tr></table></figure><p><strong>查看运行的Java程序，JVM参数是否开启，具体值为多少？</strong></p></blockquote><p>首先我们运行一个HelloGC的 Java 程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-27 13:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello GC&quot;</span>);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104626.png"></p><hr><p>然后查看java的后台进程：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 得到进程号</span></span><br><span class="line">jps -l</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104627.png"></p><hr><p>然后查看是否开启PrintGCDetails这个参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># + 表示开启，-号 表示没开启</span></span><br><span class="line">jinfo -flag PrintGCDetails 9936</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104628.png"></p><p>结果表明：-号表示关闭，即没有开启PrintGCDetails这个参数</p><hr><p>最后：需要在启动HelloGC的时候，增加 PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104629.png"></p><p>在VM Options中加入下面的代码，现在+号表示开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104630.png"></p><hr><p>重启启动程序，使用 <code>jps -l</code>得到进程号，使用<code>jinfo -flag PrintGCDetails 进程号</code>得到配置结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104631.png"></p><p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p><hr><p>也可以使用下列命令，会把jvm的全部默认参数输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags 进程号</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104632.png"></p><hr><h4 id="KV设值类型"><a href="#KV设值类型" class="headerlink" title="KV设值类型"></a>KV设值类型</h4><blockquote><p>-XX:属性key=值value</p></blockquote><h5 id="Case-1"><a href="#Case-1" class="headerlink" title="Case"></a>Case</h5><blockquote><p>-XX:MetaspaceSize=128m   调整元空间大小</p><p>-XX:MaxTenuringThreshold=15  调整存活年龄</p></blockquote><p>还是刚刚那个程序，首先我们查看默认的元空间大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看进程号</span></span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看默认空间（此时是键值对类型）</span></span><br><span class="line">jinfo -flag MetaspaceSize 11080</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104633.png"></p><hr><p>配置元空间大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 配置元空间大小为1024m</span></span><br><span class="line">-XX:MetaspaceSize=1024m</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104634.png"></p><p>重新启动程序，查看：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104635.png"></p><p>配置生效！</p><hr><p>同样操作：配置存活年龄</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold&#x3D;10</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104636.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104637.png"></p><hr><h4 id="jinfo：如何查看当前程序运行的配置"><a href="#jinfo：如何查看当前程序运行的配置" class="headerlink" title="jinfo：如何查看当前程序运行的配置"></a><font color='red'>jinfo：如何查看当前程序运行的配置</font></h4><blockquote><p>jinfo -flag 某个参数 pid </p><p>或者</p><p>jinfo -flags pid 显示所有参数</p></blockquote><h5 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看堆内存初始化大小</span></span><br><span class="line">jinfo -flag InitialHeapSize  15276</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104638.png"></p><hr><h5 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看全部配置信息</span></span><br><span class="line">jinfo -flags 15276</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 结果：</span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=<span class="number">12</span> -XX:InitialHeapSize=<span class="number">268435456</span> -XX:MaxHeapSize=<span class="number">4278190080</span> -XX:MaxNewSize=<span class="number">1426063360</span></span><br><span class="line">-XX:MetaspaceSize=<span class="number">1073741824</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">89128960</span> -XX:OldSize=<span class="number">179306496</span> -XX:+</span><br><span class="line">UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndivi</span><br><span class="line">dualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><hr><h4 id="题外话（坑题）"><a href="#题外话（坑题）" class="headerlink" title="题外话（坑题）"></a><font color='red'>题外话（坑题）</font></h4><blockquote><p>两个经典参数：<code>-Xms </code>和 <code>-Xmx</code>，这两个参数 如何解释？</p></blockquote><p>这两个参数，还是属于XX参数，因为取了别名</p><ul><li>-Xms 等价于 -XX:InitialHeapSize ：初始化堆内存（默认只会用最大物理内存的64分1）</li><li>-Xmx 等价于 -XX:MaxHeapSize ：最大堆内存（默认只会用最大物理内存的4分1）</li></ul><hr><p>与机器本身配置有关：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104639.png"></p><p>我们进行重新配置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 设置初始化大小200m，最大3g</span></span><br><span class="line">-Xms200m -Xmx3g</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104640.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104641.png"></p><hr><h4 id="查看JVM默认参数"><a href="#查看JVM默认参数" class="headerlink" title="查看JVM默认参数"></a>查看JVM默认参数</h4><blockquote><p>-XX:+PrintFlagsInitial</p></blockquote><h5 id="方式一：查看初始默认值"><a href="#方式一：查看初始默认值" class="headerlink" title="方式一：查看初始默认值"></a>方式一：查看<code>初始默认值</code></h5><blockquote><p>公式：</p><ul><li>java -XX:+PrintFlagsInitial -version</li><li>java -XX:+PrintFlagsInitial（重要参数）</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104642.png"></p><hr><h5 id="方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）"><a href="#方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）" class="headerlink" title="方式二：查看修改后的，最终的值（可能是JVM，也可能是人为修改）"></a>方式二：<code>查看修改后的，最终的值</code>（可能是JVM，也可能是人为修改）</h5><blockquote><p>公式：</p><ul><li>-XX:+PrintFlagsFinal -version</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104643.png"></p><p>会将JVM的各个结果都进行打印</p><p><font color='red'>如果有 := 表示修改过的， = 表示没有修改过的</font></p><p>以初始化堆内存为例：我的机器是16G内存，所以JVM会划内存的1/64给堆初始化，即270m左右</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104644.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104645.png"></p><p>实例2：运行java<strong>命令的同时打印出参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -Xss128k javaClass</span><br></pre></td></tr></table></figure><hr><h5 id="方式三：查看一些常见的参数"><a href="#方式三：查看一些常见的参数" class="headerlink" title="方式三：查看一些常见的参数"></a><font color='red'>方式三：查看一些<code>常见的参数</code></font></h5><blockquote><p> -XX:+PrintCommandLineFlags</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104646.png"></p><p>该命令主要是用来查看当前使用的垃圾回收器</p><hr><h2 id="工作中常用的JVM基本配置参数"><a href="#工作中常用的JVM基本配置参数" class="headerlink" title="工作中常用的JVM基本配置参数"></a>工作中常用的JVM基本配置参数</h2><blockquote><p>题目3：用过的JVM常用基本配置参数有哪些？</p></blockquote><p>知识复习：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104647.png"></p><hr><h3 id="查看堆内存"><a href="#查看堆内存" class="headerlink" title="查看堆内存"></a>查看堆内存</h3><blockquote><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p></blockquote><p>代码方式查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2021-01-27 13:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中内存的总量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回Java虚拟机中试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="string">&quot;(字节)、&quot;</span> + (totalMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="string">&quot;(字节)、&quot;</span> + (maxMemory / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104648.png"></p><p>-Xms 初始堆内存为：物理内存的1/64 -Xmx 最大堆内存为：系统物理内存的 1/4</p><hr><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><h4 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h4><blockquote><p>-Xms：<code>初始化堆内存</code>，默认为物理内存的1/64，</p><p>等价于 -XX:initialHeapSize</p></blockquote><hr><h4 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h4><blockquote><p>-Xmx：<code>最大堆内存</code>，默认为物理内存的1/4，</p><p>等价于-XX:MaxHeapSize</p></blockquote><hr><h4 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h4><blockquote><p>-Xss：设计<code>单个线程栈的大小</code>，一般默认为512K~1024K，</p><p>等价于 -XX:ThreadStackSize</p></blockquote><p>使用 jinfo -flag ThreadStackSize 会发现 -XX:ThreadStackSize = 0</p><p>原因：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 官网解释（JDK8）</span></span><br><span class="line">Linux/x64:1024KB</span><br><span class="line">OS X：1024KB</span><br><span class="line">Oracle Solaris：1024KB</span><br><span class="line">Windows：取决于虚拟内存的大小</span><br></pre></td></tr></table></figure><hr><h4 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h4><blockquote><p>设置<code>元空间大小</code>。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。</p><p>元空间与永久代的最大区别在于，永久代在虚拟机中（占用堆内存），而元空间在本地内存中（占用物理内存）。</p><p>为了防止在频繁的实例化对象的时候，让元空间出现OOM，因此可以把元空间设置的大一些</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看默认配置大小(大约21m)</span></span><br><span class="line">java -XX:+PrintFlagsFinal -version</span><br><span class="line"></span><br><span class="line"><span class="section"># 设置元空间大小</span></span><br><span class="line">-XX:+MetaspaceSize=1024m</span><br></pre></td></tr></table></figure><hr><h4 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a><font color='red'>-XX:+PrintGCDetails</font></h4><blockquote><p>输出GC收集<code>日志信息</code></p><p>分为：</p><ul><li>GC</li><li>Full GC</li></ul></blockquote><p>我们使用一段代码，制造出垃圾回收的过程</p><p>首先我们设置一下程序的启动配置: 设置初始堆内存为10M，最大堆内存为10M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>然后用下列代码，创建一个 非常大空间的byte类型数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte [] byteArray &#x3D; new byte[50 * 1024 * 1024];</span><br></pre></td></tr></table></figure><p>运行后，发现会出现下列错误，这就是OOM：<code>java内存溢出，也就是堆空间不足</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104649.png"></p><p>同时还打印出了GC垃圾回收时候的详情</p><p>问题发生的原因：因为们通过 -Xms10m 和 -Xmx10m 只给Java堆栈设置了10M的空间，但是创建了50M的对象，因此就会出现空间不足，而导致出错</p><p>同时在垃圾收集的时候，我们看到有两个对象：GC 和 Full GC</p><hr><h6 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h6><blockquote><p>GC垃圾回收发生在<code>新生代</code>。</p></blockquote><hr><p><strong>参数图：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104650.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># GC信息（GC (Allocation Failure)：表示分配失败，那么就需要触发年轻代空间中的内容被回收）</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1580K-&gt;504K(2560K)] 1580K-&gt;764K(9728K), 0.0167268 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] </span><br></pre></td></tr></table></figure><hr><h6 id="Full-GC垃圾回收"><a href="#Full-GC垃圾回收" class="headerlink" title="Full GC垃圾回收"></a>Full GC垃圾回收</h6><blockquote><p>Full GC大部分发生在<code>养老区</code></p></blockquote><p><strong>参数图：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104651.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Full GC</span></span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 592K-&gt;574K(7168K)] 592K-&gt;574K(9728K), [Metaspace: 3158K-&gt;3158K(1056768K)], 0.0040996 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br></pre></td></tr></table></figure><hr><p><font color='red'>规律：</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[名称： GC前内存占用 -&gt; GC后内存占用 (该区内存总大小)]</span><br></pre></td></tr></table></figure><p><font color='red'>当我们出现了老年代都扛不住的时候，就会出现OOM异常</font></p><hr><h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><p>VM综合配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss1024k -Xms200m -Xmx4g -XX:MetaspaceSize&#x3D;1024m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><ul><li>-Xss1024k  栈大小</li><li>-Xms200m  堆初始化大小</li><li>-Xmx4g   堆最大值</li><li>-XX:MetaspaceSize=1024m  元空间大小</li><li>-XX:+PrintCommandLineFlags  打印常用配置</li><li>-XX:+PrintGCDetails   打印日志信息</li><li>-XX:+UseSerialGC   使用垃圾回收器的名称（串行回收器）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104652.png"></p><hr><h4 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h4><blockquote><p>调节新生代中<code> eden 和 S0、S1的空间比例，</code></p></blockquote><p>默认为 -XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104653.png"></p><p>我们设置如下参数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 分配堆内存为10m（此时新生代大约占2~3m）</span></span><br><span class="line">-Xms10m -Xmx10m  -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><hr><p>假如设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p><p>SurvivorRatio值就是设置eden区的比例占多少？S0和S1相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m  -XX:+PrintGCDetails -XX:SurvivorRatio&#x3D;4</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104654.png"></p><hr><h4 id="XX-NewRatio（了解）"><a href="#XX-NewRatio（了解）" class="headerlink" title="-XX:NewRatio（了解）"></a>-XX:NewRatio（了解）</h4><blockquote><p>配置<code>年轻代new 和老年代old 在堆结构的占比</code></p><p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p></blockquote><p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p><p><font color='orange'>新生代特别小，会造成频繁的进行GC收集</font></p><hr><h4 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h4><blockquote><p>设置<code>垃圾最大年龄</code></p><p>SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代。</p><p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看默认进入老年代年龄：</span></span><br><span class="line">jinfo -flag MaxTenuringThreshold 进程号</span><br><span class="line"></span><br><span class="line"><span class="section"># 设置年龄：</span></span><br><span class="line"> -XX:MaxTenuringThreshold=15</span><br></pre></td></tr></table></figure><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_GC Roots分析</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/1-GC-Roots%E5%88%86%E6%9E%90/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/1-GC-Roots%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-GC-Roots分析"><a href="#1-GC-Roots分析" class="headerlink" title="1_GC Roots分析"></a>1_GC Roots分析</h1><blockquote><p>题目1：JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots</p></blockquote><hr><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><blockquote><p>简单来说就是：内存中已经不再被使用的空间就是垃圾</p></blockquote><hr><h2 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><del>引用计数法</del></h3><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收</p><p>简单说，给对象中添加一个<code>引用计数器</code>，每当有一个地方引用它，计数器值加1，每当有一个引用失效，计数器值减1，任何时刻计数器值<code>为零</code>的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104521.png"></p><p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它<code>很难解决对象之间相互循环引用的问题</code>。该算法存在但目前无人用了，解决不了循环引用的问题，了解即可。</p><hr><h3 id="枚举根节点做可达性分析"><a href="#枚举根节点做可达性分析" class="headerlink" title="枚举根节点做可达性分析"></a>枚举根节点做可达性分析</h3><blockquote><p><code>根搜索路径算法</code>：为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法</p><p>所谓 GC Roots 或者说 Tracing Roots的“根集合” 就是<font color='red'>一组必须活跃的引用 </font></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104522.png"></p><p>基本思路：就是通过<font color='red'>一系列名为 GC Roots的对象作为起始点</font>，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的对象就被判定为死亡</p><hr><p><strong>举例1说明：</strong></p><blockquote><p>必须从<code>GC Roots对象</code>开始，这个类似于linux的 / 也就是根目录：</p><ul><li>蓝色部分是从GC Roots出发，能够循环可达</li><li>而白色部分未从GC Roots出发，无法到达</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104523.png"></p><hr><p><strong>举例2说明：</strong></p><blockquote><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p></blockquote><p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p><p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p><p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p><hr><h2 id="哪些对象可以当做GC-Roots"><a href="#哪些对象可以当做GC-Roots" class="headerlink" title="哪些对象可以当做GC Roots"></a>哪些对象可以当做GC Roots</h2><ul><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li><li>本地方法栈中的JNI（Native方法）的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><hr><p> <strong>代码说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Java中，可以作为GC Roots的对象有：</span></span><br><span class="line"><span class="comment"> * - 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</span></span><br><span class="line"><span class="comment"> * - 方法区中的类静态属性引用的对象</span></span><br><span class="line"><span class="comment"> * - 方法区中常量引用的对象</span></span><br><span class="line"><span class="comment"> * - 本地方法栈中的JNI（Native方法）的引用对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法区中的类静态属性引用的对象</span></span><br><span class="line">    <span class="comment">// private static GCRootDemo2 t2;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span></span><br><span class="line">    <span class="comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种，虚拟机栈中的引用对象</span></span><br><span class="line">        GCRootDemo t1 = <span class="keyword">new</span> GCRootDemo();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0_JVM体系结构</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/0-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/JVM/0-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="0-JVM体系结构"><a href="#0-JVM体系结构" class="headerlink" title="0_JVM体系结构"></a>0_JVM体系结构</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104258.jpg"></p><hr><p>Java gc 主要回收的是 <strong>方法区</strong> 和 <strong>堆</strong> 中的内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104259.png"></p><hr><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>常考考点：</p><ul><li>类加载器是什么</li><li>双亲委派机制</li><li>Java类加载的沙箱安全机制</li></ul><hr><h2 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a><del>引用计数</del></h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104300.png"></p><hr><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><blockquote><p>复制算法在<code>年轻代</code>的时候，进行使用，复制时候有交换</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104301.png"></p><p>优点：没有内存碎片</p><p>缺点：消耗内存</p><hr><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><blockquote><p>先标记，后清除。用于<code>老年代</code>多一些</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104302.png"></p><p>优点：不会消耗那么多内存</p><p>缺点：会产生内存碎片</p><hr><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><blockquote><p>也叫标记清除整理，多用于<code>老年代</code></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104303.png"></p><p>优点：不会消耗太多内存；不会有内存碎片</p><p>缺点：比较耗时</p><hr><p>总结：没有完美的算法，只有合适的算法，一般采用<code>分代收集算法</code></p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux诊断原因</title>
      <link href="2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Linux/Linux%E8%AF%8A%E6%96%AD%E5%8E%9F%E5%9B%A0/"/>
      <url>2021/02/17/%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%AD%A3_%E5%91%A8%E9%98%B3%E8%80%81%E5%B8%88/Linux/Linux%E8%AF%8A%E6%96%AD%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux诊断原因"><a href="#Linux诊断原因" class="headerlink" title="Linux诊断原因"></a>Linux诊断原因</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><blockquote><p>问题9：生产环境服务器变慢，诊断思路和性能评估谈谈？</p></blockquote><p>运行服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Xms xxx参数名字 -jar </span><br></pre></td></tr></table></figure><hr><h3 id="top：查看整机系统新能"><a href="#top：查看整机系统新能" class="headerlink" title="top：查看整机系统新能"></a>top：查看整机系统新能</h3><blockquote><ul><li>load average三个指标：分别代表1、5、15分钟的负载情况</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104152.png"></p><p>重点关注的是 %CPU、%MEM 、load average 三个指标</p><p>在这个命令下，按1的话，可以看到每个CPU的占用情况</p><hr><h3 id="uptime精简版"><a href="#uptime精简版" class="headerlink" title="uptime精简版"></a>uptime精简版</h3><blockquote><p>系统性能命令的精简版</p></blockquote><hr><h3 id="CPU：vmstat"><a href="#CPU：vmstat" class="headerlink" title="CPU：vmstat"></a>CPU：vmstat</h3><blockquote><p>查看CPU（包含但是不限于）</p><p>查看额外</p><ul><li>查看所有CPU核信息：mpstat -p ALL 2</li><li>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</li></ul></blockquote><hr><p>命令格式：<code>vmstat -n 2 3</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104153.png"></p><p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数（单位秒），第二个参数是采样的次数</p><p><strong>procs</strong></p><ul><li> r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了2，说明现在压力过大</li><li> b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等</li></ul><p><strong>cpu</strong></p><ul><li> us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序</li><li> sy：内核进程消耗的CPU时间百分比</li><li> us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明CPU消耗不是很高</li><li> id：处于空闲的CPU百分比</li><li> wa：系统等待IO的CPU时间百分比</li><li> st：来自于一个虚拟机偷取的CPU时间比</li></ul><hr><h3 id="内存：free"><a href="#内存：free" class="headerlink" title="内存：free"></a>内存：free</h3><p>应用程序可用内存数：free -m</p><ul><li>应用程序可用内存/系统物理内存 &gt; 70% 内存充足</li><li>应用程序可用内存/系统物理内存 &lt; 20% 内存不足，需要增加内存</li><li>20% &lt; 应用程序可用内存/系统物理内存 &lt; 70%，表示内存基本够用</li></ul><hr><p>free -h：以人类能看懂的方式查看物理内存</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104154.png"></p><hr><p>free -m：以MB为单位，查看物理内存</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104155.png"></p><hr><p>free -g：以GB为单位，查看物理内存</p><hr><h3 id="硬盘：df"><a href="#硬盘：df" class="headerlink" title="硬盘：df"></a>硬盘：df</h3><blockquote><p>格式：<code>df -h /</code> (-h：human，表示以人类能看到的方式换算)</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104156.png"></p><hr><h3 id="硬盘IO：iostat"><a href="#硬盘IO：iostat" class="headerlink" title="硬盘IO：iostat"></a>硬盘IO：iostat</h3><blockquote><p>系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作</p></blockquote><p>格式：<code>iostat -xdk 2 3</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104157.png" alt="image-20200326170522559"></p><p>磁盘块设备分布：</p><ul><li>rkB /s：每秒读取数据量kB；</li><li>wkB/s：每秒写入数据量kB；</li><li>svctm I/O：请求的平均服务时间，单位毫秒</li><li>await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好</li><li>util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘；</li><li>rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</li><li>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘</li></ul><hr><h3 id="网络IO：ifstat"><a href="#网络IO：ifstat" class="headerlink" title="网络IO：ifstat"></a>网络IO：ifstat</h3><blockquote><p>默认本地没有，下载ifstat</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104158.png"></p><hr><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><blockquote><p>问题10：假如生产环境CPU占用过高，谈谈分析思路和定位？</p></blockquote><p>分析步骤：</p><ol><li><p>先用top命令找出CPU占比最高的进程</p></li><li><p>ps -ef或者jps查看进程编号</p></li><li><p>定位到具体的线程或者代码</p><blockquote><p>ps -mp 进程 -o THREAD，tid，time</p><p>参数：</p><ul><li>-m：显示所有的线程</li><li>-p：pid进程使用CPU的时间</li><li>-o：该参数后是用户自定义格式</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104159.png"></p></blockquote></li><li><p>将线程的id转换为16进制</p><blockquote><p>printf “%x\n” 有问题的线程ID</p></blockquote></li><li><p>jstack 线程id | grep tid （16进制） 得到java程序详细信息，定位到第几行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217104200.png"></p><hr></li></ol><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><blockquote><p>问题11：对于JDK自带的JVM监控和性能分析工具用过哪些？一般怎么用的？</p></blockquote><ul><li>jps 进程状态工具</li><li>jinfo java配置信息工具</li><li>jmap 内存映像工具</li><li>jstat 统计信息监视工具</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 面试汇总 </category>
          
          <category> 大厂面试第二季_周阳老师 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10_Docker 私有仓库</title>
      <link href="2021/02/17/Docker/10-Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
      <url>2021/02/17/Docker/10-Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="10-Docker-私有仓库"><a href="#10-Docker-私有仓库" class="headerlink" title="10_Docker 私有仓库"></a>10_Docker 私有仓库</h1><p>Docker官方的Docker hub（<a href="https://hub.docker.com)是一个用于管理公共镜像的仓库,我们可以从上面拉/">https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉</a> 取镜像 到本地，也可以把我们自己的镜像推送上去。但是，有时候我们不希望将自己的镜 像放到公网当中， 那么这时我们就需要搭建自己的私有仓库来存储和管理自己的镜像 </p><h2 id="私有仓库搭建"><a href="#私有仓库搭建" class="headerlink" title="私有仓库搭建"></a>私有仓库搭建</h2><p><strong>步骤：</strong></p><h3 id="1、拉取私有仓库镜像"><a href="#1、拉取私有仓库镜像" class="headerlink" title="1、拉取私有仓库镜像"></a>1、拉取私有仓库镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><h3 id="2、启动私有仓库容器"><a href="#2、启动私有仓库容器" class="headerlink" title="2、启动私有仓库容器"></a>2、启动私有仓库容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure><h3 id="3、访问仓库"><a href="#3、访问仓库" class="headerlink" title="3、访问仓库"></a>3、访问仓库</h3><p>打开浏览器 输入地址：http://私有仓库服务器ip:5000/v2/_catalog，看到{“repositories”:[]} 表示私有仓 库 搭建成功 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102238.png"></p><h3 id="4、修改-daemon-json"><a href="#4、修改-daemon-json" class="headerlink" title="4、修改 daemon.json"></a>4、修改 daemon.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p># 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器 ip 修改为自 己私有仓库服务器真实 ip </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125;</span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.220.12:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102239.png"></p><p><strong>我的文件源码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;y1ye9vg6.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;:[&quot;192.168.77.138:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、重启docker-服务"><a href="#5、重启docker-服务" class="headerlink" title="5、重启docker 服务"></a>5、重启docker 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker </span><br></pre></td></tr></table></figure><h3 id="6、重启-私有仓库容器"><a href="#6、重启-私有仓库容器" class="headerlink" title="6、重启 私有仓库容器"></a>6、重启 私有仓库容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure><hr><h2 id="将镜像上传至私有仓库"><a href="#将镜像上传至私有仓库" class="headerlink" title="将镜像上传至私有仓库"></a>将镜像上传至私有仓库</h2><p>下面以 上传 nginx 镜像为例，</p><h3 id="1、标记镜像为私有仓库的镜像"><a href="#1、标记镜像为私有仓库的镜像" class="headerlink" title="1、标记镜像为私有仓库的镜像"></a>1、标记镜像为私有仓库的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><h3 id="2、上传标记的镜像"><a href="#2、上传标记的镜像" class="headerlink" title="2、上传标记的镜像"></a>2、上传标记的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><h3 id="3、查看私有仓库"><a href="#3、查看私有仓库" class="headerlink" title="3、查看私有仓库"></a>3、查看私有仓库</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102240.png"></p><hr><h2 id="从私有仓库拉取镜像"><a href="#从私有仓库拉取镜像" class="headerlink" title="从私有仓库拉取镜像"></a>从私有仓库拉取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.77.138:5000&#x2F;nginx:8</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9_服务编排</title>
      <link href="2021/02/17/Docker/9-%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/"/>
      <url>2021/02/17/Docker/9-%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1 id="9-服务编排"><a href="#9-服务编排" class="headerlink" title="9_服务编排"></a>9_服务编排</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启 动停止，维护的工作量会很大。来看下我们日常工作：</p><ul><li>要从Dockerfile build image 或者去 dockerhub 拉取 image </li><li>要创建多个 container </li><li>要管理这些 container（启动停止删除）</li></ul><p>通过服务编排可以大量简化上面的工作服务编排：<strong>按照一定的业务规则批量管理容器</strong></p><hr><h2 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h2><p>Docker Compose 是一个编排多容器分布式部署的工具，提供命令集中管理容器化应用的完整开发周期，包括服务 构建，启动和停止。使用步骤：</p><ol><li>利用 Dockerfile 定义运行环境镜像 </li><li>使用 docker-compose.yml 定义组成应用的各服务 </li><li>运行 docker-compose up 启动应用</li></ol><h3 id="1-安装-Docker-Compose"><a href="#1-安装-Docker-Compose" class="headerlink" title="1. 安装 Docker Compose"></a>1. 安装 Docker Compose</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.8.0&#x2F;run.sh &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="2-设置文件可执行权限"><a href="#2-设置文件可执行权限" class="headerlink" title="2. 设置文件可执行权限"></a>2. 设置文件可执行权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="3-查看版本信息"><a href="#3-查看版本信息" class="headerlink" title="3. 查看版本信息"></a>3. 查看版本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><h3 id="4-卸载-Docker-Compose"><a href="#4-卸载-Docker-Compose" class="headerlink" title="4. 卸载 Docker Compose"></a>4. 卸载 Docker Compose</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><hr><h2 id="编排-nginx-springboot"><a href="#编排-nginx-springboot" class="headerlink" title="编排 nginx+springboot"></a>编排 nginx+springboot</h2><p>安装之前的做法，我们需要使用先启动 nginx 容器 ，再启动 app 项目容器</p><p>现在我们使用 docker-compose 进行管理编排，让它帮我们进行启动、停止或者删除</p><p><strong>需求：</strong>  使用 nginx 做反向代理，当我们 访问 192.168.77.130:80 时，映射到 app 容器</p><h4 id="1-创建-docker-compose目录"><a href="#1-创建-docker-compose目录" class="headerlink" title="1. 创建 docker-compose目录"></a>1. 创建 docker-compose目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;docker-compose </span><br><span class="line">cd ~&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h4 id="2-编写-docker-compose-yml-文件"><a href="#2-编写-docker-compose-yml-文件" class="headerlink" title="2.编写 docker-compose.yml 文件"></a>2.编写 docker-compose.yml 文件</h4><p>编排 nginx 和 app 两个服务 ，nginx 服务使用到 nginx 镜像，当访问到 80 端口时，映射到 容器的 80 端口，同时链接到app ，对 nginx 配置文件进行挂载 [ 注意这里 conf.d 是目录 ]，而 app  服务需要使用到 app 镜像，同时暴露容器端口 80 </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line">   <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;80&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-创建-nginx-conf-d目录"><a href="#3-创建-nginx-conf-d目录" class="headerlink" title="3.创建./nginx/conf.d目录"></a>3.创建./nginx/conf.d目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p .&#x2F;nginx&#x2F;conf.d</span><br></pre></td></tr></table></figure><h4 id="4-在-nginx-conf-d目录下-编写app-conf文件"><a href="#4-在-nginx-conf-d目录下-编写app-conf文件" class="headerlink" title="4. 在./nginx/conf.d目录下 编写app.conf文件"></a>4. 在./nginx/conf.d目录下 编写app.conf文件</h4><p>当 nginx 监听其他主机访问 80 端口时，进行代理转发到  <a href="http://app/test">http://app:80/test</a></p><p>这里的 app 指 app 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;app:80&#x2F;test;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-在-docker-compose-目录下-使用docker-compose-启动容器"><a href="#5-在-docker-compose-目录下-使用docker-compose-启动容器" class="headerlink" title="5. 在~/docker-compose 目录下 使用docker-compose 启动容器"></a>5. 在~/docker-compose 目录下 使用docker-compose 启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d # -d表示已守护模式启动</span><br></pre></td></tr></table></figure><h4 id="6-测试访问"><a href="#6-测试访问" class="headerlink" title="6.测试访问"></a>6.测试访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:80</span><br></pre></td></tr></table></figure><p>当然，80 端口也可以省略</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102124.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8_本地镜像发布到阿里云</title>
      <link href="2021/02/17/Docker/8-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/"/>
      <url>2021/02/17/Docker/8-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h1 id="8-本地镜像发布到阿里云"><a href="#8-本地镜像发布到阿里云" class="headerlink" title="8_本地镜像发布到阿里云"></a>8_本地镜像发布到阿里云</h1><h2 id="本地镜像发布到阿里云流程"><a href="#本地镜像发布到阿里云流程" class="headerlink" title="本地镜像发布到阿里云流程"></a>本地镜像发布到阿里云流程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102008.png"></p><h2 id="镜像的生成方法"><a href="#镜像的生成方法" class="headerlink" title="镜像的生成方法"></a>镜像的生成方法</h2><h3 id="1、前面的-DockerFile"><a href="#1、前面的-DockerFile" class="headerlink" title="1、前面的 DockerFile"></a>1、前面的 DockerFile</h3><h3 id="2、从容器创建一个新的镜像"><a href="#2、从容器创建一个新的镜像" class="headerlink" title="2、从容器创建一个新的镜像"></a>2、从容器创建一个新的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102009.png"></p><h3 id="3、将本地镜像推送到阿里云"><a href="#3、将本地镜像推送到阿里云" class="headerlink" title="3、将本地镜像推送到阿里云"></a>3、将本地镜像推送到阿里云</h3><h4 id="本地镜像素材原型"><a href="#本地镜像素材原型" class="headerlink" title="本地镜像素材原型"></a>本地镜像素材原型</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102010.png"></p><h4 id="阿里云开发者平台"><a href="#阿里云开发者平台" class="headerlink" title="阿里云开发者平台"></a>阿里云开发者平台</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;cn-hangzhou&#x2F;instances&#x2F;repositories</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102011.png"></p><h4 id="创建仓库镜像"><a href="#创建仓库镜像" class="headerlink" title="创建仓库镜像"></a>创建仓库镜像</h4><p>命名空间 + 仓库名称</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102012.png"></p><h4 id="将镜像推送到-registry"><a href="#将镜像推送到-registry" class="headerlink" title="将镜像推送到 registry"></a>将镜像推送到 registry</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102013.png" alt="image-20201111183221165"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102014.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102015.png"></p><h4 id="公有云可以查询到"><a href="#公有云可以查询到" class="headerlink" title="公有云可以查询到"></a>公有云可以查询到</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102016.png" alt="image-20201111183454166"></p><h4 id="查看详情"><a href="#查看详情" class="headerlink" title="查看详情"></a>查看详情</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102017.png" alt="image-20201111183544458"></p><h3 id="4、下载到本地"><a href="#4、下载到本地" class="headerlink" title="4、下载到本地"></a>4、下载到本地</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217102018.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装ElasticSearch 6.8.0</title>
      <link href="2021/02/17/Docker/Docker-%E5%AE%89%E8%A3%85ElasticSearch-6-8-0/"/>
      <url>2021/02/17/Docker/Docker-%E5%AE%89%E8%A3%85ElasticSearch-6-8-0/</url>
      
        <content type="html"><![CDATA[<h1 id="12-Docker-安装ElasticSearch-6-8-0"><a href="#12-Docker-安装ElasticSearch-6-8-0" class="headerlink" title="12_Docker 安装ElasticSearch 6.8.0"></a>12_Docker 安装ElasticSearch 6.8.0</h1><h4 id="1、拉取镜像"><a href="#1、拉取镜像" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:6.8.0</span><br></pre></td></tr></table></figure><h4 id="2、修改系统配置参数"><a href="#2、修改系统配置参数" class="headerlink" title="2、修改系统配置参数"></a>2、修改系统配置参数</h4><p>elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优</p><p>进入配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br></pre></td></tr></table></figure><p>追加内容 (nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制 ) </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure><p>进入配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><p>限制一个进程可以拥有的VMA(虚拟内存区域)的数量，末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;655360</span><br></pre></td></tr></table></figure><p>使配置生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>重启虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><hr><h4 id="3、启动容器"><a href="#3、启动容器" class="headerlink" title="3、启动容器"></a>3、启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;es -p 9200:9200 -p 9300:9300 elasticsearch:6.8.0</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 9200端口(Web管理平台端口) 9300(服务默认端口，kibana客户端或者集群节点之间交流时用该端口) </p><h4 id="4、访问ElasticSearch"><a href="#4、访问ElasticSearch" class="headerlink" title="4、访问ElasticSearch"></a>4、访问ElasticSearch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:9200</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101921.png"></p><p>代表ES启动成功！</p><hr><h4 id="5、远程访问"><a href="#5、远程访问" class="headerlink" title="5、远程访问"></a>5、远程访问</h4><p>虽然ES启动了，但是不能远程进行访问，，elasticsearch从5版本以后默认不开启远程连接，需要我们进行开启</p><p><strong>（1）登录容器</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it es &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><strong>（2）修改配置文件</strong></p><p>进入配置文件所在目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd configls</span><br></pre></td></tr></table></figure><p>vi命令无法识别，因为docker容器里面没有该命令，我们还需要安装该编辑器 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 集群名字</span><br><span class="line"># node.name: es</span><br><span class="line">cluster.name: &quot;cluster_es&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 允许elasticsearch跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line"># 示跨域访问允许的域名地址（表示任意）</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101922.png"></p><hr><p><strong>（3）重启容器</strong></p><p>ctrl + P+Q 退出容器（并未停止），重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><p><strong>（4）远程访问测试</strong></p><p>浏览器输入：[主机ip:web访问端口]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101923.png"></p><hr><h2 id="Head客户端安装"><a href="#Head客户端安装" class="headerlink" title="Head客户端安装"></a>Head客户端安装</h2><p>ElasticSearch不同于Solr自带图形化界面，我们可以通过安装ElasticSearch的head插件，完成图形化界面的效 </p><p>果，完成索引数据的查看。安装插件的方式有两种，在线安装和本地安装。本文档采用本地安装方式进行head插 </p><p>件的安装。elasticsearch-5-*以上版本安装head需要安装node和grunt </p><p><strong>windows下安装Head</strong></p><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>官网github地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head</span><br></pre></td></tr></table></figure><h4 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h4><h4 id="3、安装node"><a href="#3、安装node" class="headerlink" title="3、安装node"></a>3、安装node</h4><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;download&#x2F;</span><br></pre></td></tr></table></figure><p>完成后，控制台输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101924.png"></p><p>node安装成功！</p><h4 id="4、安装grunt"><a href="#4、安装grunt" class="headerlink" title="4、安装grunt"></a>4、安装grunt</h4><p>将grunt安装为全局命令 ，Grunt是基于Node.js的项目构建工具 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g grunt-cli</span><br></pre></td></tr></table></figure><p>cnpm 是换源的安装命令，如果你没有安装过cnpm可用选择使用npm</p><h4 id="5、启动Head"><a href="#5、启动Head" class="headerlink" title="5、启动Head"></a>5、启动Head</h4><p>进入elasticsearch-head-master目录启动head，进入cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt server</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101925.png"></p><h4 id="6、访问测试"><a href="#6、访问测试" class="headerlink" title="6、访问测试"></a>6、访问测试</h4><p>打开浏览器，输入 <a href="http://localhost:9100/">http://localhost:9100</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101926.png"></p><h4 id="7、连接ElasticSearch"><a href="#7、连接ElasticSearch" class="headerlink" title="7、连接ElasticSearch"></a>7、连接ElasticSearch</h4><p>在Head页面中输入ElasticSearch的访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101927.png"></p><p>至此，Head的安装就完成了！</p><hr><h2 id="Postman工具客户端"><a href="#Postman工具客户端" class="headerlink" title="Postman工具客户端"></a>Postman工具客户端</h2><p>依赖Restful接口进行访问</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; &#39;&lt;PROTOCOL&gt;:&#x2F;&#x2F;&lt;HOST&gt;:&lt;PORT&gt;&#x2F;&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#39; -d &#39;&lt;BODY&gt;&#39;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101928.png"></p><h4 id="创建索引index和映射mapping"><a href="#创建索引index和映射mapping" class="headerlink" title="创建索引index和映射mapping"></a>创建索引index和映射mapping</h4><p>地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;book</span><br></pre></td></tr></table></figure><p>请求体：访问格式必须是Json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;musicbook&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;name&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;price&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;double&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;desc&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;text&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101929.png"></p><hr><h4 id="创建索引后设置Mapping"><a href="#创建索引后设置Mapping" class="headerlink" title="创建索引后设置Mapping"></a>创建索引后设置Mapping</h4><p>我们可以在创建索引时设置mapping信息，当然也可以先创建索引然后再设置mapping</p><p>在上一个步骤中不设置maping信息，直接使用put方法创建一个索引，然后设置mapping信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT   http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems1&#x2F;emp&#x2F;_mapping </span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;musicbook&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;double&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;desc&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101930.png"></p><hr><h4 id="删除索引index"><a href="#删除索引index" class="headerlink" title="删除索引index"></a>删除索引index</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems1</span><br></pre></td></tr></table></figure><hr><h4 id="创建文档document"><a href="#创建文档document" class="headerlink" title="创建文档document"></a>创建文档document</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems&#x2F;emp&#x2F;1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;音乐书&quot;,</span><br><span class="line">  &quot;price&quot;:&quot;22.0&quot;,</span><br><span class="line">  &quot;desc&quot;:&quot;这是一本音乐书&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101931.png"></p><hr><h4 id="修改文档document"><a href="#修改文档document" class="headerlink" title="修改文档document"></a>修改文档document</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST   http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems&#x2F;emp&#x2F;1&#x2F;_update</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;price&quot;:&quot;40&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101932.png"></p><hr><h4 id="删除文档document"><a href="#删除文档document" class="headerlink" title="删除文档document"></a>删除文档document</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems&#x2F;emp&#x2F;1</span><br></pre></td></tr></table></figure><hr><h4 id="查询文档document"><a href="#查询文档document" class="headerlink" title="查询文档document"></a>查询文档document</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;ems&#x2F;emp&#x2F;1</span><br></pre></td></tr></table></figure><hr><h2 id="ElasticSearch安装IK分词器"><a href="#ElasticSearch安装IK分词器" class="headerlink" title="ElasticSearch安装IK分词器"></a>ElasticSearch安装IK分词器</h2><h4 id="1、下载安装包-1"><a href="#1、下载安装包-1" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>注意：下载版本需要和你的ElasticSearch版本一致</p><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases</span><br></pre></td></tr></table></figure><h4 id="2、解压-1"><a href="#2、解压-1" class="headerlink" title="2、解压"></a>2、解压</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 创建目录来保存解压后的文件</span></span><br><span class="line">mkdir IK</span><br><span class="line"></span><br><span class="line"><span class="section"># 解压[在IK中解压]</span></span><br><span class="line">unzip elasticsearch-analysis-ik-6.8.0.zip</span><br></pre></td></tr></table></figure><h4 id="3、拷贝IK目录到ES容器"><a href="#3、拷贝IK目录到ES容器" class="headerlink" title="3、拷贝IK目录到ES容器"></a>3、拷贝IK目录到ES容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  IK es:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</span><br></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><h4 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;_analyze</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;:&quot;中华人民共和国人民大会堂&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>IK分词器有两种标准：”ik_smart”表示粗粒度划分，”ik_max_word”表示细粒度划分</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101933.png"></p><hr><h2 id="Kibana-客户端"><a href="#Kibana-客户端" class="headerlink" title="Kibana 客户端"></a>Kibana 客户端</h2><p>Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可 以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。 </p><p>Kibana 可以使大数据通俗易懂。它很简单，基于浏览器的界面便于您快速创建和分享动态数据仪表板来追踪 </p><p>Elasticsearch 的实时数据变化。</p><h4 id="1、拉取镜像-1"><a href="#1、拉取镜像-1" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:6.8.0</span><br></pre></td></tr></table></figure><h4 id="2、启动容器"><a href="#2、启动容器" class="headerlink" title="2、启动容器"></a>2、启动容器</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 后台方式启动</span><br><span class="line">docker run  -id --name kibana -e ELASTICSEARCH_URL=http://192.168.77.138:9200 -p 5601:5601  kibana:6.8.0</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>ELASTICSEARCH_URL=<a href="http://192.168.220.100:9200：是指链接的ES地址">http://192.168.220.100:9200：是指链接的ES地址</a> </li><li>5601是kibana的默认端口</li></ul><h4 id="3、访问测试"><a href="#3、访问测试" class="headerlink" title="3、访问测试"></a>3、访问测试</h4><p>注意开启端口或者关闭防火墙</p><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:5601&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101934.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装 ElasticSearch 5.6.8</title>
      <link href="2021/02/17/Docker/Docker-%E5%AE%89%E8%A3%85-ElasticSearch-5-6-8/"/>
      <url>2021/02/17/Docker/Docker-%E5%AE%89%E8%A3%85-ElasticSearch-5-6-8/</url>
      
        <content type="html"><![CDATA[<h1 id="11-Docker-安装-ElasticSearch-5-6-8"><a href="#11-Docker-安装-ElasticSearch-5-6-8" class="headerlink" title="11_Docker 安装 ElasticSearch 5.6.8"></a>11_Docker 安装 ElasticSearch 5.6.8</h1><h4 id="1、拉取镜像"><a href="#1、拉取镜像" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:5.6.8</span><br></pre></td></tr></table></figure><h4 id="2、修改系统配置参数"><a href="#2、修改系统配置参数" class="headerlink" title="2、修改系统配置参数"></a>2、修改系统配置参数</h4><p>elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，如果你放开了此配置，意味着需要打开更多的文件以及虚拟内存，所以我们还需要系统调优</p><p>进入配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br></pre></td></tr></table></figure><p>追加内容 (nofile是单个进程允许打开的最大文件个数 soft nofile 是软限制 hard nofile是硬限制 ) </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure><p>进入配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><p>限制一个进程可以拥有的VMA(虚拟内存区域)的数量，末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count&#x3D;655360</span><br></pre></td></tr></table></figure><p>使配置生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>重启虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><hr><h4 id="3、启动容器"><a href="#3、启动容器" class="headerlink" title="3、启动容器"></a>3、启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;es -p 9200:9200 -p 9300:9300 elasticsearch:5.6.8</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 9200端口(Web管理平台端口) 9300(服务默认端口，kibana客户端或者集群节点之间交流时用该端口) </p><h4 id="4、访问ElasticSearch"><a href="#4、访问ElasticSearch" class="headerlink" title="4、访问ElasticSearch"></a>4、访问ElasticSearch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;localhost:9200</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101752.png"></p><p>代表ES启动成功！</p><hr><h4 id="5、远程访问"><a href="#5、远程访问" class="headerlink" title="5、远程访问"></a>5、远程访问</h4><p>虽然ES启动了，但是不能远程进行访问，，elasticsearch从5版本以后默认不开启远程连接，需要我们进行开启</p><p><strong>（1）登录容器</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it es &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><strong>（2）修改配置文件</strong></p><p>进入配置文件所在目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd configls</span><br></pre></td></tr></table></figure><p>vi命令无法识别，因为docker容器里面没有该命令，我们还需要安装该编辑器 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 设置apt下载源</span></span><br><span class="line">docker cp sources.list es:/etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>sources.list 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]&#x2F; xenial main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security multiverse</span><br></pre></td></tr></table></figure><p>进入es容器，安装vim编辑器 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 集群名字</span><br><span class="line"># node.name: es</span><br><span class="line">cluster.name: &quot;cluster_es&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 允许elasticsearch跨域访问</span><br><span class="line">http.cors.enabled: true</span><br><span class="line"># 示跨域访问允许的域名地址（表示任意）</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101753.png"></p><hr><p><strong>（3）重启容器</strong></p><p>ctrl + P+Q 退出容器（并未停止），重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><p><strong>（4）远程访问测试</strong></p><p>浏览器输入：[主机ip:web访问端口]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101754.png"></p><hr><h2 id="Head客户端安装"><a href="#Head客户端安装" class="headerlink" title="Head客户端安装"></a>Head客户端安装</h2><p>ElasticSearch不同于Solr自带图形化界面，我们可以通过安装ElasticSearch的head插件，完成图形化界面的效 </p><p>果，完成索引数据的查看。安装插件的方式有两种，在线安装和本地安装。本文档采用本地安装方式进行head插 </p><p>件的安装。elasticsearch-5-*以上版本安装head需要安装node和grunt </p><p><strong>windows下安装Head</strong></p><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>官网github地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head</span><br></pre></td></tr></table></figure><h4 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h4><h4 id="3、安装node"><a href="#3、安装node" class="headerlink" title="3、安装node"></a>3、安装node</h4><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;download&#x2F;</span><br></pre></td></tr></table></figure><p>完成后，控制台输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101755.png"></p><p>node安装成功！</p><h4 id="4、安装grunt"><a href="#4、安装grunt" class="headerlink" title="4、安装grunt"></a>4、安装grunt</h4><p>将grunt安装为全局命令 ，Grunt是基于Node.js的项目构建工具 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g grunt-cli</span><br></pre></td></tr></table></figure><p>cnpm 是换源的安装命令，如果你没有安装过cnpm可用选择使用npm</p><h4 id="5、启动Head"><a href="#5、启动Head" class="headerlink" title="5、启动Head"></a>5、启动Head</h4><p>进入elasticsearch-head-master目录启动head，进入cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt server</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101756.png"></p><h4 id="6、访问测试"><a href="#6、访问测试" class="headerlink" title="6、访问测试"></a>6、访问测试</h4><p>打开浏览器，输入 <a href="http://localhost:9100/">http://localhost:9100</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101757.png"></p><h4 id="7、连接ElasticSearch"><a href="#7、连接ElasticSearch" class="headerlink" title="7、连接ElasticSearch"></a>7、连接ElasticSearch</h4><p>在Head页面中输入ElasticSearch的访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:9200&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101758.png"></p><p>至此，Head的安装就完成了！</p><hr><h2 id="ElasticSearch安装IK分词器"><a href="#ElasticSearch安装IK分词器" class="headerlink" title="ElasticSearch安装IK分词器"></a>ElasticSearch安装IK分词器</h2><h4 id="1、下载安装包-1"><a href="#1、下载安装包-1" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>注意：下载版本需要和你的ElasticSearch版本一致</p><p>官网地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases</span><br></pre></td></tr></table></figure><h4 id="2、解压-1"><a href="#2、解压-1" class="headerlink" title="2、解压"></a>2、解压</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 创建目录来保存解压后的文件</span></span><br><span class="line">mkdir IK</span><br><span class="line"></span><br><span class="line"><span class="section"># 解压[在IK中解压]</span></span><br><span class="line">unzip elasticsearch-analysis-ik-5.6.8.zip</span><br></pre></td></tr></table></figure><h4 id="3、拷贝IK目录到ES容器"><a href="#3、拷贝IK目录到ES容器" class="headerlink" title="3、拷贝IK目录到ES容器"></a>3、拷贝IK目录到ES容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  IK es:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins</span><br></pre></td></tr></table></figure><p>重启容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><h4 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.211.132:9200&#x2F;_analyze?analyzer&#x3D;ik_max_word&amp;pretty&#x3D;true&amp;text&#x3D;中华人民共和国人民大会堂</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>IK分词器有两种标准：”ik_smart”表示粗粒度划分，”ik_max_word”表示细粒度划分</p><hr><h2 id="Kibana-客户端"><a href="#Kibana-客户端" class="headerlink" title="Kibana 客户端"></a>Kibana 客户端</h2><p>Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可 以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。 </p><p>Kibana 可以使大数据通俗易懂。它很简单，基于浏览器的界面便于您快速创建和分享动态数据仪表板来追踪 </p><p>Elasticsearch 的实时数据变化。</p><h4 id="1、拉取镜像-1"><a href="#1、拉取镜像-1" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io&#x2F;kibana:5.6.8</span><br></pre></td></tr></table></figure><h4 id="2、启动容器"><a href="#2、启动容器" class="headerlink" title="2、启动容器"></a>2、启动容器</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 后台方式启动</span><br><span class="line">docker run  -id --name kibana -e ELASTICSEARCH_URL=http://192.168.77.138:9200 -p 5601:5601  kibana:5.6.8</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>ELASTICSEARCH_URL=<a href="http://192.168.220.100:9200：是指链接的ES地址">http://192.168.220.100:9200：是指链接的ES地址</a> </li><li>5601是kibana的默认端口</li></ul><h4 id="3、访问测试"><a href="#3、访问测试" class="headerlink" title="3、访问测试"></a>3、访问测试</h4><p>注意开启端口或者关闭防火墙</p><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.77.138:5601&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101759.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7_Docker常用安装</title>
      <link href="2021/02/17/Docker/7-Docker%E5%B8%B8%E7%94%A8%E5%AE%89%E8%A3%85/"/>
      <url>2021/02/17/Docker/7-Docker%E5%B8%B8%E7%94%A8%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="7-Docker常用安装"><a href="#7-Docker常用安装" class="headerlink" title="7_Docker常用安装"></a>7_Docker常用安装</h1><h2 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h2><ul><li>搜索镜像</li><li>拉取镜像</li><li>查看镜像</li><li>启动镜像</li><li>停止容器</li><li>移除容器</li></ul><hr><h2 id="tomcat-部署"><a href="#tomcat-部署" class="headerlink" title="tomcat 部署"></a>tomcat 部署</h2><h3 id="1、docker-hub上面查找-tomcat-镜像"><a href="#1、docker-hub上面查找-tomcat-镜像" class="headerlink" title="1、docker hub上面查找 tomcat 镜像"></a>1、docker hub上面查找 tomcat 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101655.png"></p><h3 id="2、从-docker-hub-上拉取-tomcat-镜像到本地"><a href="#2、从-docker-hub-上拉取-tomcat-镜像到本地" class="headerlink" title="2、从 docker hub 上拉取 tomcat 镜像到本地"></a>2、从 docker hub 上拉取 tomcat 镜像到本地</h3><p>不指定版本时，拉取为：latest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101656.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101657.png" alt="image-20201112080607304"></p><h3 id="3、docker-images-查看是否有拉取到的-tomcat"><a href="#3、docker-images-查看是否有拉取到的-tomcat" class="headerlink" title="3、docker images 查看是否有拉取到的 tomcat"></a>3、docker images 查看是否有拉取到的 tomcat</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101658.png"></p><h3 id="4、使用-tomcat-镜像创建容器-也叫运行镜像"><a href="#4、使用-tomcat-镜像创建容器-也叫运行镜像" class="headerlink" title="4、使用 tomcat 镜像创建容器(也叫运行镜像)"></a>4、使用 tomcat 镜像创建容器(也叫运行镜像)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">-p 主机端口:docker容器端口</span><br><span class="line">-P 随机分配端口</span><br><span class="line">-it 交互终端</span><br></pre></td></tr></table></figure><p>如果是随机分配终端，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101659.png" alt="image-20201112080848910"></p><hr><h2 id="mysql-部署"><a href="#mysql-部署" class="headerlink" title="mysql 部署"></a>mysql 部署</h2><h3 id="1、docker-hub上面查找-mysql-镜像"><a href="#1、docker-hub上面查找-mysql-镜像" class="headerlink" title="1、docker hub上面查找 mysql 镜像"></a>1、docker hub上面查找 mysql 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101700.png" alt="image-20201112081011330"></p><h3 id="2、从docker-hub上-阿里云加速器-拉取-mysql-镜像到本地标签为-5-6"><a href="#2、从docker-hub上-阿里云加速器-拉取-mysql-镜像到本地标签为-5-6" class="headerlink" title="2、从docker hub上(阿里云加速器)拉取 mysql 镜像到本地标签为 5.6"></a>2、从docker hub上(阿里云加速器)拉取 mysql 镜像到本地标签为 5.6</h3><p>拉取指定版本到本地</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101701.png" alt="image-20201112081108267"></p><h3 id="3、使用-mysql5-6-镜像创建容器-也叫运行镜像"><a href="#3、使用-mysql5-6-镜像创建容器-也叫运行镜像" class="headerlink" title="3、使用 mysql5.6 镜像创建容器(也叫运行镜像)"></a>3、使用 mysql5.6 镜像创建容器(也叫运行镜像)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 12345:3306 --name mysql</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;logs:&#x2F;logs</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456</span><br><span class="line">-d mysql:5.6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">命令说明：</span><br><span class="line"></span><br><span class="line">-p 12345:3306：将主机的12345端口映射到docker容器的3306端口。[一般使用软件默认的端口就行]</span><br><span class="line">--name mysql：运行服务名字</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d ：将主机&#x2F;zzyyuse&#x2F;mysql录下的conf&#x2F;my.cnf 挂载到容器的 &#x2F;etc&#x2F;mysql&#x2F;conf.d</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;logs:&#x2F;logs：将主机&#x2F;zzyyuse&#x2F;mysql目录下的 logs 目录挂载到容器的 &#x2F;logs。</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql ：将主机&#x2F;zzyyuse&#x2F;mysql目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456：初始化 root 用户的密码。</span><br><span class="line">-d mysql:5.6 : 后台程序运行mysql5.6</span><br></pre></td></tr></table></figure><p>进入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it MySQL运行成功后的容器ID     &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101702.png" alt="image-20201112081549644"></p><h3 id="4、外部-Win10-也来连接运行在-dokcer上的-mysql-服务"><a href="#4、外部-Win10-也来连接运行在-dokcer上的-mysql-服务" class="headerlink" title="4、外部 Win10 也来连接运行在 dokcer上的 mysql 服务"></a>4、外部 Win10 也来连接运行在 dokcer上的 mysql 服务</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101703.png" alt="image-20201112081830145"></p><h3 id="5、备份测试"><a href="#5、备份测试" class="headerlink" title="5、备份测试"></a>5、备份测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec myql服务容器ID sh -c &#39; exec mysqldump --all-databases -uroot -p&quot;123456&quot; &#39; &gt; &#x2F;zzyyuse&#x2F;all-databases.sql</span><br></pre></td></tr></table></figure><hr><h2 id="redis-部署"><a href="#redis-部署" class="headerlink" title="redis 部署"></a>redis 部署</h2><h3 id="1、docker-hub上面查找-redis-镜像"><a href="#1、docker-hub上面查找-redis-镜像" class="headerlink" title="1、docker hub上面查找 redis 镜像"></a>1、docker hub上面查找 redis 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure><h3 id="2、从docker-hub上-阿里云加速器-拉取-redis-镜像到本地标签为-3-2"><a href="#2、从docker-hub上-阿里云加速器-拉取-redis-镜像到本地标签为-3-2" class="headerlink" title="2、从docker hub上(阿里云加速器)拉取 redis 镜像到本地标签为 3.2"></a>2、从docker hub上(阿里云加速器)拉取 redis 镜像到本地标签为 3.2</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101704.png" alt="image-20201112082107134"></p><h3 id="3、使用-redis-3-2-镜像创建容器-也叫运行镜像"><a href="#3、使用-redis-3-2-镜像创建容器-也叫运行镜像" class="headerlink" title="3、使用 redis 3.2  镜像创建容器(也叫运行镜像)"></a>3、使用 redis 3.2  镜像创建容器(也叫运行镜像)</h3><p>注意这里主机下面 redis.conf 是一层目录 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 \</span><br><span class="line">-v &#x2F;xj0927&#x2F;myredis&#x2F;data:&#x2F;data \</span><br><span class="line">-v &#x2F;xj0927&#x2F;myredis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf  \</span><br><span class="line">-d redis:3.2 \</span><br><span class="line">redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span><br><span class="line">--appendonly yes</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101705.png" alt="image-20201112082336274"></p><h3 id="4、测试-redis-cli-连接上来"><a href="#4、测试-redis-cli-连接上来" class="headerlink" title="4、测试 redis-cli 连接上来"></a>4、测试 redis-cli 连接上来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 运行着Rediis服务的容器ID redis-cli</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101706.png" alt="image-20201112082424493"></p><h3 id="5、测试持久化文件生成"><a href="#5、测试持久化文件生成" class="headerlink" title="5、测试持久化文件生成"></a>5、测试持久化文件生成</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101707.png" alt="image-20201112082501645"></p><hr><h2 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h2><h3 id="1、搜索-nginx-镜像"><a href="#1、搜索-nginx-镜像" class="headerlink" title="1、搜索 nginx 镜像"></a>1、搜索 nginx 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure><h3 id="2、拉取-nginx-镜像"><a href="#2、拉取-nginx-镜像" class="headerlink" title="2、拉取 nginx 镜像"></a>2、拉取 nginx 镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="3、创建容器，设置目录映射"><a href="#3、创建容器，设置目录映射" class="headerlink" title="3、创建容器，设置目录映射"></a>3、创建容器，设置目录映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir nginx</span><br><span class="line">cd nginx</span><br><span class="line">mkdir conf</span><br><span class="line">cd conf </span><br><span class="line"></span><br><span class="line"># 在~&#x2F;nginx&#x2F;conf&#x2F;下创建nginx.conf文件,粘贴下面内容 </span><br><span class="line">vim nginx.conf </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">user nginx;   </span><br><span class="line">worker_processes 1;   </span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  worker_connections  1024;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  include    &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">  default_type application&#x2F;octet-stream;</span><br><span class="line">  log_format   main &#39;$remote_addr - $remote_user [$time_local]  $status &#39;</span><br><span class="line">    &#39;&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">  access_log   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line">  sendfile     on;</span><br><span class="line">  #tcp_nopush   on;  keepalive_timeout  65;</span><br><span class="line">  #gzip on;</span><br><span class="line">  </span><br><span class="line">  # 后面需要应用的端口文件都放在conf.d下面</span><br><span class="line">  include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、运行镜像"><a href="#4、运行镜像" class="headerlink" title="4、运行镜像"></a>4、运行镜像</h3><p>当前目录：nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name&#x3D;nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-p 81:81 \</span><br><span class="line">-p 82:82 \ </span><br><span class="line">-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \</span><br><span class="line">-v $PWD&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \</span><br><span class="line">-v $PWD&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \</span><br><span class="line">-v $PWD&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong> </p><ul><li><strong>-p 80:80：</strong>将容器的80端口映射到宿主机的 80 端口</li><li><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：</strong>将主机当前目录下的 /conf/nginx.conf 挂载到容 器的 :/etc/nginx/nginx.conf  [配置目录 ]</li><li><strong>-v $PWD/logs:/var/log/nginx：</strong>将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx [ 日志目录]</li><li><strong>-v $PWD/conf.d:/etc/nginx/conf.d ：</strong> [应用目录]</li><li><strong>-v $PWD/html:/usr/share/nginx/html ：</strong> [静态资源目录]</li></ul><h3 id="5、端口映射"><a href="#5、端口映射" class="headerlink" title="5、端口映射"></a>5、端口映射</h3><p>路径：nginx/conf.d/80.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">listen 80; # 监听的端口</span><br><span class="line">    server_name localhost; # 域名或ip</span><br><span class="line">    location &#x2F; &#123; # 访问路径配置</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;# 根目录</span><br><span class="line">       index index.html index.htm; # 默认首页</span><br><span class="line">    &#125;</span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html; # 错误页面</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123; </span><br><span class="line">    root html; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、静态页面"><a href="#6、静态页面" class="headerlink" title="6、静态页面"></a>6、静态页面</h3><p>在 主机的 html 目录下新增 index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;hello docker nginx&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><h3 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h3><p>访问：192.168.77.138</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101708.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6_DockerFile 解析</title>
      <link href="2021/02/17/Docker/6-DockerFile-%E8%A7%A3%E6%9E%90/"/>
      <url>2021/02/17/Docker/6-DockerFile-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="6-DockerFile-解析"><a href="#6-DockerFile-解析" class="headerlink" title="6_DockerFile 解析"></a>6_DockerFile 解析</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Dockerfile 是用来构建 Docker 镜像的构建文件，是由一系列命令和参数构成的脚本。</p><h3 id="构建三步骤"><a href="#构建三步骤" class="headerlink" title="构建三步骤"></a>构建三步骤</h3><ol><li>编写 Dockerfile 文件</li><li>docker build</li><li>docker run</li></ol><h3 id="文件什么样？？？"><a href="#文件什么样？？？" class="headerlink" title="文件什么样？？？"></a>文件什么样？？？</h3><p>以我们熟悉的 CentOS 为例 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101509.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101510.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101511.png"></p><h2 id="DockerFile-构建过程解析"><a href="#DockerFile-构建过程解析" class="headerlink" title="DockerFile 构建过程解析"></a>DockerFile 构建过程解析</h2><h3 id="Dockerfile内容基础知识"><a href="#Dockerfile内容基础知识" class="headerlink" title="Dockerfile内容基础知识"></a>Dockerfile内容基础知识</h3><ul><li>1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>2：指令按照从上到下，顺序执行</li><li>3：# 表示注释</li><li>4：每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ul><h3 id="Docker-执行-Dockerfile-的大致流程"><a href="#Docker-执行-Dockerfile-的大致流程" class="headerlink" title="Docker 执行 Dockerfile 的大致流程"></a>Docker 执行 Dockerfile 的大致流程</h3><p>类似千层饼，一层包一层 ，每一层都是一个镜像。 </p><p>（1）docker 从基础镜像运行一个容器</p><p>（2）执行一条指令并对容器作出修改</p><p>（3）执行类似 docker commit 的操作提交一个新的镜像层</p><p>（4）docker 再基于刚提交的镜像运行一个新容器</p><p>（5）执行 dockerfile 中的下一条指令直到所有指令都执行完成</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、Docker 镜像与 Docker 容器分别代表软件的三个不同段，</p><ul><li>Dockerfile 是软件的原材料</li><li>Docker 镜像是软件的交付品</li><li>Docker 容器则可以认为是软件的运行态。</li></ul><p>Dockerfile 面向开发，Docker 镜像成为交付标准，Docker 容器则涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101512.png"></p><p>1、Dockerfile，需要定义一个Dockerfile，Dockerfile 定义了进程需要的一切东西。Dockerfile 涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p><p>2 、Docker 镜像，在用 Dockerfile 定义一个文件之后，docker build 时会产生一个Docker 镜像，当运行 Docker 镜像时，会真正开始提供服务;</p><p>3、 Docker 容器，容器是直接提供服务的。</p><h2 id="DockerFile-体系结构-保留字指令"><a href="#DockerFile-体系结构-保留字指令" class="headerlink" title="DockerFile 体系结构(保留字指令)"></a>DockerFile 体系结构(保留字指令)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM  基础镜像，当前新镜像是基于哪个镜像的</span><br><span class="line"></span><br><span class="line">MAINTAINER  镜像维护者的姓名和邮箱地址</span><br><span class="line"></span><br><span class="line">RUN  容器构建时需要运行的命令</span><br><span class="line"></span><br><span class="line">EXPOSE  当前容器对外暴露出的端口</span><br><span class="line"></span><br><span class="line">WORKDIR  指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点[进入容器时,默认的目录位置]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ENV 用来在构建镜像过程中设置环境变量</span><br><span class="line"></span><br><span class="line">ENV MY_PATH &#x2F;usr&#x2F;mytest</span><br><span class="line">这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样；</span><br><span class="line">也可以在其它指令中直接使用这些环境变量，比如：WORKDIR $MY_PATH</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADD 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</span><br><span class="line"></span><br><span class="line">COPY 类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</span><br><span class="line">COPY src dest</span><br><span class="line">COPY [&quot;src&quot;, &quot;dest&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME 容器数据卷，用于数据保存和持久化工作</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD 指定一个容器启动时要运行的命令</span><br><span class="line">Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101513.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT  指定一个容器启动时要运行的命令</span><br><span class="line">   但docker run之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD   当构建一个被继承的 Dockerfile 时运行命令，父镜像在被子继承后父镜像的 onbuild 被触发</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101514.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101515.png"></p><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101516.png"></p><hr><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="Base镜像-scratch"><a href="#Base镜像-scratch" class="headerlink" title="Base镜像(scratch)"></a>Base镜像(scratch)</h3><p>Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101517.png"></p><h3 id="自定义镜像-mycentos"><a href="#自定义镜像-mycentos" class="headerlink" title="自定义镜像 mycentos"></a>自定义镜像 mycentos</h3><h4 id="1、编写"><a href="#1、编写" class="headerlink" title="1、编写"></a>1、编写</h4><h5 id="（1）Hub-默认CentOS-镜像什么情况"><a href="#（1）Hub-默认CentOS-镜像什么情况" class="headerlink" title="（1）Hub 默认CentOS 镜像什么情况"></a>（1）Hub 默认CentOS 镜像什么情况</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101518.png"></p><p>自定义 mycentos 目的 使我们自己的镜像具备如下：</p><ul><li>​     登陆后的默认路径</li><li>​     vim 编辑器</li><li>​     查看网络配置 ifconfig 支持</li></ul><h5 id="（2）准备编写-DockerFile-文件"><a href="#（2）准备编写-DockerFile-文件" class="headerlink" title="（2）准备编写 DockerFile 文件"></a>（2）准备编写 DockerFile 文件</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101519.png"></p><h5 id="（3）myCentOS-内容-DockerFile"><a href="#（3）myCentOS-内容-DockerFile" class="headerlink" title="（3）myCentOS 内容 DockerFile"></a>（3）myCentOS 内容 DockerFile</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER zzyy&lt;zzyy167@126.com&gt;</span><br><span class="line"></span><br><span class="line"># 默认路径</span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line"># 构建时需要运行的指令</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line"># mycentos 暴露的端口</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success--------------ok&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h4 id="2、构建"><a href="#2、构建" class="headerlink" title="2、构建"></a>2、构建</h4><p>docker build 命令最后有一个 .                  . 表示当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 新镜像名字:TAG .</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101520.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101521.png"></p><h4 id="3、运行"><a href="#3、运行" class="headerlink" title="3、运行"></a>3、运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 新镜像名字:TAG </span><br></pre></td></tr></table></figure><p>可以看到，我们自己的新镜像已经支持 vim / ifconfig 命令，扩展成功了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101522.png"></p><h4 id="4、列出镜像的变更历史"><a href="#4、列出镜像的变更历史" class="headerlink" title="4、列出镜像的变更历史"></a>4、列出镜像的变更历史</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history 镜像名</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101523.png"></p><h3 id="CMD-ENTRYPOINT-镜像案例"><a href="#CMD-ENTRYPOINT-镜像案例" class="headerlink" title="CMD / ENTRYPOINT 镜像案例"></a>CMD / ENTRYPOINT 镜像案例</h3><p>都是指定一个容器启动时要运行的命令 </p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换！！！</p><h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>tomcat 的讲解演示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8888:8080 tomcat ls -l</span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101524.png"></p><h5 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h5><p>制作 CMD 版可以查询 IP 信息的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install -y curl</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101525.png"></p><blockquote><p>crul 命令解释：</p><p>curl 命令可以用来执行下载、发送各种HTTP请求，指定 HTTP 头部等操作。</p><p>如果系统没有 curl 可以使用 yum install curl 安装，也可以下载安装。</p><p>curl 是将下载文件输出到 stdout </p><p>使用命令：curl <a href="http://www.baidu.com/">http://www.baidu.com</a></p><p>执行后，<a href="http://www.baidu.com/">www.baidu.com</a> 的 html 就会显示在屏幕上了</p><p>这是最简单的使用方法。用这个命令获得了<a href="http://curl.haxx.se指向的页面,同样,如果这里的url指向的是一个文件或者一幅图都可以直接下载到本地.如果下载的是html文档,那么缺省的将只显示文件头部,即html文档的header.要全部显示,请加参数/">http://curl.haxx.se指向的页面，同样，如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。如果下载的是HTML文档，那么缺省的将只显示文件头部，即HTML文档的header。要全部显示，请加参数</a> -i</p></blockquote><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如果我们希望显示 HTTP 头信息，就需要加上 -i 参数</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101526.png"></p><h5 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h5><p>我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。</p><p>因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s <a href="http://ip.cn/">http://ip.cn</a> 后面。而 -i 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip curl -s http:&#x2F;&#x2F;ip.cn -i</span><br></pre></td></tr></table></figure><h5 id="制作-ENTRYPOINT-版查询-IP-信息的容器"><a href="#制作-ENTRYPOINT-版查询-IP-信息的容器" class="headerlink" title="制作 ENTRYPOINT 版查询 IP 信息的容器"></a>制作 ENTRYPOINT 版查询 IP 信息的容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">RUN yum install -y curl</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101527.png"></p><h3 id="自定义镜像-Tomcat9"><a href="#自定义镜像-Tomcat9" class="headerlink" title="自定义镜像 Tomcat9"></a>自定义镜像 Tomcat9</h3><h5 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;zzyyuse&#x2F;mydockerfile&#x2F;tomcat9</span><br></pre></td></tr></table></figure><h5 id="2、在上述目录下-touch-c-txt"><a href="#2、在上述目录下-touch-c-txt" class="headerlink" title="2、在上述目录下 touch c.txt"></a>2、在上述目录下 touch c.txt</h5><h5 id="3、将-jdk-和-tomcat-安装的压缩包拷贝进上一步目录"><a href="#3、将-jdk-和-tomcat-安装的压缩包拷贝进上一步目录" class="headerlink" title="3、将 jdk 和 tomcat 安装的压缩包拷贝进上一步目录"></a>3、将 jdk 和 tomcat 安装的压缩包拷贝进上一步目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apache-tomcat-9.0.8.tar.gz</span><br><span class="line">jdk-8u171-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h5 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h5><p>在 /zzyyuse/mydockerfile/tomcat9 目录下新建 Dockerfile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM         centos</span><br><span class="line">MAINTAINER    zzyy&lt;zzyybs@126.com&gt;</span><br><span class="line">#把宿主机当前上下文的c.txt拷贝到容器&#x2F;usr&#x2F;local&#x2F;路径下</span><br><span class="line">COPY c.txt &#x2F;usr&#x2F;local&#x2F;cincontainer.txt</span><br><span class="line">#把java与tomcat添加到容器中</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">ADD apache-tomcat-9.0.8.tar.gz &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#设置工作访问时候的WORKDIR路径，登录落脚点</span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">#配置java与tomcat环境变量</span><br><span class="line">ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_171</span><br><span class="line">ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">ENV CATALINA_HOME &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8</span><br><span class="line">ENV CATALINA_BASE &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME&#x2F;bin:$CATALINA_HOME&#x2F;lib:$CATALINA_HOME&#x2F;bin</span><br><span class="line">#容器运行时监听的端口</span><br><span class="line">EXPOSE  8080</span><br><span class="line">#启动时运行tomcat</span><br><span class="line"># ENTRYPOINT [&quot;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;startup.sh&quot; ]</span><br><span class="line"># CMD [&quot;&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;catalina.sh&quot;,&quot;run&quot;]</span><br><span class="line">CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;startup.sh &amp;&amp; tail -F &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;bin&#x2F;logs&#x2F;catalina.out</span><br></pre></td></tr></table></figure><p>此时，目录内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101528.png"></p><h5 id="5、构建"><a href="#5、构建" class="headerlink" title="5、构建"></a>5、构建</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101529.png"></p><h5 id="6、run"><a href="#6、run" class="headerlink" title="6、run"></a>6、run</h5><p>运行且和主机之间建立数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9080:8080 --name myt9</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mydockerfile&#x2F;tomcat9&#x2F;test:&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;webapps&#x2F;test</span><br><span class="line">-v &#x2F;zzyyuse&#x2F;mydockerfile&#x2F;tomcat9&#x2F;tomcat9logs&#x2F;:&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.8&#x2F;logs</span><br><span class="line">--privileged&#x3D;true</span><br><span class="line">zzyytomcat9</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101530.png"></p><blockquote><p>备注：Docker 挂载主机目录 Docker 访问出现 cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个 –privileged=true 参数即可</p></blockquote><h5 id="7、验证"><a href="#7、验证" class="headerlink" title="7、验证"></a>7、验证</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101531.png"></p><h5 id="8、"><a href="#8、" class="headerlink" title="8、"></a>8、</h5><p>结合前述的容器卷将测试的 web 服务 tes t发布</p><h6 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101532.png"></p><h6 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">  xsi: schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot;</span><br><span class="line">  id&#x3D;&quot;WebApp_ID&quot; version&#x3D;&quot;2.5&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;display-name&gt;test&lt;&#x2F;display-name&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure><h6 id="a-jsp"><a href="#a-jsp" class="headerlink" title="a.jsp"></a>a.jsp</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">     &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">     &lt;title&gt;Insert title here&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      -----------welcome------------</span><br><span class="line">     &lt;%&#x3D;&quot;i am in docker tomcat self &quot;%&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;% System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;docker tomcat self&quot;);%&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101533.png"></p><hr><h2 id="自定义-dockerFile-镜像"><a href="#自定义-dockerFile-镜像" class="headerlink" title="自定义 dockerFile 镜像"></a>自定义 dockerFile 镜像</h2><h3 id="自定义-centos7-镜像"><a href="#自定义-centos7-镜像" class="headerlink" title="自定义 centos7 镜像"></a>自定义 centos7 镜像</h3><p>使用官方的镜像，我们发现没有没有 ifconfig ，vim 等功能，我们可以在官方的镜像基础上进行自定义，构建我们希望的镜像，然后运行容器</p><p><strong>需求：</strong></p><ol><li><p>默认登录路径为 /usr </p></li><li><p>可以使用 vim </p></li></ol><p><strong>步骤：</strong></p><ol><li>定义父镜像：FROM centos:7 </li><li>定义作者信息：MAINTAINER xj0927  <a href="mailto:&#120;&#106;&#x30;&#x39;&#x32;&#55;&#64;&#108;&#x78;&#115;&#46;&#x63;&#x6e;">&#120;&#106;&#x30;&#x39;&#x32;&#55;&#64;&#108;&#x78;&#115;&#46;&#x63;&#x6e;</a> </li><li>执行安装 vim 命令： RUN yum install -y vim </li><li>定义默认的工作目录：WORKDIR /usr </li><li>定义容器启动执行的命令：CMD /bin/bash </li><li>通过 dockerfile 构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本 . </li></ol><p>现在开始构建 dockerFile 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;docker-files</span><br><span class="line">cd ~&#x2F;docker-files</span><br><span class="line">vim centos_dockerfile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7 </span><br><span class="line">MAINTAINER xj0927  xj0927@lxs.cn </span><br><span class="line">RUN yum install -y vim </span><br><span class="line">WORKDIR &#x2F;usr </span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><strong>构建：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f .&#x2F;centos_dockerfile -t mycentos:1 .</span><br></pre></td></tr></table></figure><ul><li>-f：镜像文件 </li><li>-t：新镜像名 </li><li>. 寻址路径</li></ul><p><strong>查看镜像：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>运行容器：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name&#x3D;mycentos mycentos:1</span><br></pre></td></tr></table></figure><hr><h3 id="发布-springboot-项目"><a href="#发布-springboot-项目" class="headerlink" title="发布 springboot 项目"></a>发布 springboot 项目</h3><p>Spring Boot 项目：</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/1.png)</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/2.png)</p><p>使用 maven 打包项目：</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/3.png)</p><p>windows 下，使用 cmd 运行 jar 包：</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/4.png)</p><p>浏览器便可以访问：<a href="http://localhost/test">http://localhost/test</a></p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/5.png)</p><hr><p>现在，把 jar 放在docker 环境中，使用 dockerFile 进行构建成镜像，然后运行容器，进行访问</p><p>Spring Boot 项目依赖 java 8，所以需要先拉取 Java 8 的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull java:8</span><br></pre></td></tr></table></figure><p>现在开始构建 dockerFile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim springboot</span><br></pre></td></tr></table></figure><p><strong>步骤：</strong></p><ol><li>定义父镜像：FROM java:8</li><li>定义作者信息：MAINTAINER xj0927  <a href="mailto:&#x78;&#106;&#48;&#57;&#50;&#x37;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;">&#x78;&#106;&#48;&#57;&#50;&#x37;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;</a> </li><li>将 jar 包添加到容器并重命名： ADD springboot.jar app.jar</li><li>定义容器启动执行的命令：CMD [“java”,”-jar”,”app.jar”] </li><li>通过 dockerfile 构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本 . </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">MAINTAINER xj0927  xj0927@163.com </span><br><span class="line">ADD springboot.jar app.jar</span><br><span class="line">CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure><p><strong>构建：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker bulid –f .&#x2F;springboot –t app .</span><br></pre></td></tr></table></figure><p><strong>查看镜像：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>启动容器 ：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id -p 9090:80 --name&#x3D;springboot app</span><br></pre></td></tr></table></figure><p>**访问测试： **<a href="http://192.168.77.138:9090/test">http://192.168.77.138:9090/test</a></p><p>此时，便可以在别的主机上[ 这里使用的windows ]访问 Linux 上的 9090端口的宿主机，因为进行了端口映射，便可以访问到 启动的 springboot 容器</p><p>![](../Typora_工具类/docker/4_Docker 镜像/images/6.png)</p><hr><h2 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101534.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5_Docker容器数据卷</title>
      <link href="2021/02/17/Docker/5-Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
      <url>2021/02/17/Docker/5-Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Docker-容器数据卷"><a href="#5-Docker-容器数据卷" class="headerlink" title="5_Docker 容器数据卷"></a>5_Docker 容器数据卷</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>先来看看 Docker 的理念：</p><ul><li>将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望<strong>是持久化的</strong></li><li>容器之间希望有可能<strong>共享数据</strong></li></ul><p>Docker 容器产生的数据，如果不通过 docker commit 生成新的镜像，使得数据做为镜像的一部分保存下来，</p><p>那么当容器删除后，数据自然也就没有了。</p><p>为了能保存数据在 docker 中我们使用卷。</p><p>一句话：有点类似我们 Redis 里面的 rdb 和 aof 文件</p><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><p>卷就是目录或文件，存在于一个或多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System 提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷 。特点：</p><ul><li>1：数据卷可在容器之间共享或重用数据</li><li>2：卷中的更改可以直接生效</li><li>3：数据卷中的更改不会包含在镜像的更新中</li><li>4：数据卷的生命周期一直持续到没有容器使用它为止</li></ul><p><strong>总结</strong></p><h3 id="（1）容器的持久化"><a href="#（1）容器的持久化" class="headerlink" title="（1）容器的持久化"></a>（1）容器的持久化</h3><h3 id="（2）容器间继承-共享数据"><a href="#（2）容器间继承-共享数据" class="headerlink" title="（2）容器间继承 + 共享数据"></a>（2）容器间继承 + 共享数据</h3><hr><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>前提：容器内添加</p><h3 id="1、直接命令添加"><a href="#1、直接命令添加" class="headerlink" title="1、直接命令添加"></a>1、直接命令添加</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>也就是将主机中的某个文件与容器间的某个文件进行挂载，达到数据共享的目的 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录   镜像名</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;宿主机目录:&#x2F;容器内目录 centos &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101356.png"></p><h4 id="查看数据卷是否挂载成功"><a href="#查看数据卷是否挂载成功" class="headerlink" title="查看数据卷是否挂载成功"></a>查看数据卷是否挂载成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101357.png"></p><h4 id="容器和宿主机之间数据共享"><a href="#容器和宿主机之间数据共享" class="headerlink" title="容器和宿主机之间数据共享"></a>容器和宿主机之间数据共享</h4><p>数据共享！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101358.png"></p><h4 id="容器停止退出后，主机修改后数据是否同步"><a href="#容器停止退出后，主机修改后数据是否同步" class="headerlink" title="容器停止退出后，主机修改后数据是否同步"></a>容器停止退出后，主机修改后数据是否同步</h4><p>仍然同步！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101359.png"></p><h4 id="命令-带权限"><a href="#命令-带权限" class="headerlink" title="命令(带权限)"></a>命令(带权限)</h4><p>如果想要 容器“仅读”，不能写操作，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101400.png"></p><h3 id="2、DockerFile-添加"><a href="#2、DockerFile-添加" class="headerlink" title="2、DockerFile 添加"></a>2、DockerFile 添加</h3><p>出于可移植和分享的考虑，用 -v  主机目录 ：容器目录这种方法不能够直接在 Dockerfile 中实现 。</p><p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p><h4 id="根目录下新建-mydocker-文件夹并进入"><a href="#根目录下新建-mydocker-文件夹并进入" class="headerlink" title="根目录下新建 mydocker 文件夹并进入"></a>根目录下新建 mydocker 文件夹并进入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir mydocker</span><br></pre></td></tr></table></figure><h4 id="可在-Dockerfile-中使用-VOLUME-指令来给镜像添加一个或多个数据卷"><a href="#可在-Dockerfile-中使用-VOLUME-指令来给镜像添加一个或多个数据卷" class="headerlink" title="可在 Dockerfile 中使用 VOLUME 指令来给镜像添加一个或多个数据卷"></a>可在 Dockerfile 中使用 VOLUME 指令来给镜像添加一个或多个数据卷</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME[&quot;&#x2F;dataVolumeContainer&quot;,&quot;&#x2F;dataVolumeContainer2&quot;,&quot;&#x2F;dataVolumeContainer3&quot;]</span><br></pre></td></tr></table></figure><h4 id="File-构建"><a href="#File-构建" class="headerlink" title="File 构建"></a>File 构建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># volume test</span><br><span class="line"># 基于 centos 基础镜像</span><br><span class="line">FROM centos</span><br><span class="line"># 添加数据卷</span><br><span class="line">VOLUME [&quot;&#x2F;dataVolumeContainer1&quot;,&quot;&#x2F;dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;finished,--------success1&quot;</span><br><span class="line"># 启动命令</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101401.png"></p><h4 id="build-后生成镜像"><a href="#build-后生成镜像" class="headerlink" title="build 后生成镜像"></a>build 后生成镜像</h4><p>如果此时所在位置下面就有 目的构建文件 可以省略 -f </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101402.png"></p><p>获得一个新镜像 zzyy/centos ！！！</p><h4 id="run-容器"><a href="#run-容器" class="headerlink" title="run 容器"></a>run 容器</h4><p>使用刚刚我们构建的镜像，创建容器实例并启动</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101403.png"></p><p>通过上述步骤，容器内的卷目录地址已经知道！！</p><p>那对应的主机目录地址哪？？</p><p>使用下列命令便可以找到主机对应的卷目录的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101404.png"></p><h4 id="主机对应默认地址"><a href="#主机对应默认地址" class="headerlink" title="主机对应默认地址"></a>主机对应默认地址</h4><p>根据上面信息显示的位置目录便可以找到！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101405.png"></p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>Docker 挂载主机目录 Docker 访问出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot open directory .: Permission denied</span><br></pre></td></tr></table></figure><p>解决办法：在挂载目录后多加一个参数即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--privileged&#x3D;true</span><br></pre></td></tr></table></figure><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器 。</p><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>以上一步新建的镜像 zzyy/centos 为模板并运行容器 dc01/dc02/dc03</p><p>它们已经具有容器卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dataVolumeContainer1</span><br><span class="line">&#x2F;dataVolumeContainer2</span><br></pre></td></tr></table></figure><h3 id="容器间传递共享-–volumes-from"><a href="#容器间传递共享-–volumes-from" class="headerlink" title="容器间传递共享(–volumes-from)"></a>容器间传递共享(–volumes-from)</h3><h5 id="先启动一个父容器-dc01"><a href="#先启动一个父容器-dc01" class="headerlink" title="先启动一个父容器 dc01"></a>先启动一个父容器 dc01</h5><p>在 dataVolumeContainer2 新增内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101406.png"></p><h5 id="dc02-dc03-继承自-dc01"><a href="#dc02-dc03-继承自-dc01" class="headerlink" title="dc02/dc03 继承自 dc01"></a>dc02/dc03 继承自 dc01</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加如下命令</span><br><span class="line">--volumes-from 父容器</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dc02 --volumes-from dc01 zzyy&#x2F;centos</span><br></pre></td></tr></table></figure><p>同时，dc02/dc03 分别在 dataVolumeContainer2 各自新增内容</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101407.png"></p><h5 id="回到-dc01-可以看到-02-03-各自添加的都能共享了"><a href="#回到-dc01-可以看到-02-03-各自添加的都能共享了" class="headerlink" title="回到 dc01 可以看到 02/03 各自添加的都能共享了"></a>回到 dc01 可以看到 02/03 各自添加的都能共享了</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101408.png"></p><h5 id="删除-dc01，dc02-修改后-dc03-可否访问"><a href="#删除-dc01，dc02-修改后-dc03-可否访问" class="headerlink" title="删除 dc01，dc02 修改后 dc03 可否访问"></a>删除 dc01，dc02 修改后 dc03 可否访问</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101409.png"></p><h5 id="删除-dc02-后-dc03-可否访问"><a href="#删除-dc02-后-dc03-可否访问" class="headerlink" title="删除 dc02 后 dc03 可否访问"></a>删除 dc02 后 dc03 可否访问</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101410.png"></p><h5 id="如果-再以-dc03-为父容器创建容器实例-dc04"><a href="#如果-再以-dc03-为父容器创建容器实例-dc04" class="headerlink" title="如果 再以 dc03 为父容器创建容器实例 dc04"></a>如果 再以 dc03 为父容器创建容器实例 dc04</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101411.png"></p><h5 id="新建-dc04-继承-dc03-后再删除-dc03"><a href="#新建-dc04-继承-dc03-后再删除-dc03" class="headerlink" title="新建 dc04 继承 dc03 后再删除 dc03"></a>新建 dc04 继承 dc03 后再删除 dc03</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101412.png"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止！！！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4_Docker 镜像</title>
      <link href="2021/02/17/Docker/4-Docker-%E9%95%9C%E5%83%8F/"/>
      <url>2021/02/17/Docker/4-Docker-%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Docker-镜像"><a href="#4-Docker-镜像" class="headerlink" title="4_Docker 镜像"></a>4_Docker 镜像</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，<strong>用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容</strong>，包括代码、运行时、库、环境变量和配置文件。</p><h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101223.png"></p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><h3 id="Docker-镜像加载原理"><a href="#Docker-镜像加载原理" class="headerlink" title="Docker 镜像加载原理"></a>Docker 镜像加载原理</h3><p> docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。</p><p>bootfs(boot file system) 主要包含 bootloader 和 kernel, bootloader 主要是引导加载 kernel, Linux 刚启动时会加载 bootfs 文件系统，在 Docker 镜像的最底层是 bootfs。这一层与我们典型的 Linux/Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p><p>rootfs (root file system) ，在 bootfs 之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu，Centos 等等。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101224.png"></p><p> 平时我们安装进虚拟机的 CentOS 都是好几个G，为什么 docker 这里才200M ？？</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101225.png"></p><p>对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的 linux发行版, bootfs 基本是一致的, rootfs 会有差别, 因此不同的发行版可以公用 bootfs。</p><h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><p>以我们的 pull 为例，在下载的过程中我们可以看到 docker 的镜像好像是在一层一层的在下载 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101226.png"></p><h3 id="为什么-Docker-镜像要采用这种分层结构呢"><a href="#为什么-Docker-镜像要采用这种分层结构呢" class="headerlink" title="为什么 Docker 镜像要采用这种分层结构呢"></a>为什么 Docker 镜像要采用这种分层结构呢</h3><p>最大的一个好处就是 ：<strong>共享资源</strong></p><p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份 base镜像，</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Docker 镜像都是只读的</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。</p><p>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><hr><h2 id="Docker-镜像-commit-操作补充"><a href="#Docker-镜像-commit-操作补充" class="headerlink" title="Docker 镜像 commit 操作补充"></a>Docker 镜像 commit 操作补充</h2><p> 提交容器副本使之成为一个新的镜像 [ 这里也可以省略 ‘’=’’ ，直接: 参数 值 ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit</span><br><span class="line">docker commit -m&#x3D;“提交的描述信息” -a&#x3D;“作者” 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><hr><h2 id="容器转镜像"><a href="#容器转镜像" class="headerlink" title="容器转镜像"></a>容器转镜像</h2><h3 id="转化-tomcat-镜像"><a href="#转化-tomcat-镜像" class="headerlink" title="转化 tomcat 镜像"></a>转化 tomcat 镜像</h3><p>1、从 Hub 上下载 tomcat 镜像到本地并成功运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat</span><br></pre></td></tr></table></figure><ul><li><p>-p 主机端口: docker容器端口</p></li><li><p>-P 随机分配端口</p></li><li><p>-it 交互终端</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101227.png"></p><p>如果，第一次访问时出现，参考</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101228.png"></p><p>2、故意删除上一步镜像生产 tomcat 容器的文档 ，此时在页面访问文档选项，便要出现错误！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101229.png"></p><p>3、也即当前的 tomcat 运行实例是一个没有文档内容的容器，以它为模板 commit 一个没有doc 的 tomcat 新镜像 atguigu/tomcat02</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101230.png"></p><p>4、启动我们的新镜像并和原来的对比</p><p>（1）启动 atguigu/tomcat02，它没有 docs</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101231.png"></p><p>（2）新启动原来的 tomcat，它有 docs</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101232.png"></p><p>这样我们便可以在标准的容器基础上，增加我们想要的功能，commit 成镜像，后面需要时，再以此镜像创建容器实例，便是我们想要的样子！！！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3_Docker常用命令</title>
      <link href="2021/02/17/Docker/3-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2021/02/17/Docker/3-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Docker常用命令"><a href="#3-Docker常用命令" class="headerlink" title="3_Docker常用命令"></a>3_Docker常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="查看-docker-版本"><a href="#查看-docker-版本" class="headerlink" title="查看 docker 版本"></a>查看 docker 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="查看-docker-镜像数、Register等详细信息"><a href="#查看-docker-镜像数、Register等详细信息" class="headerlink" title="查看 docker 镜像数、Register等详细信息"></a>查看 docker 镜像数、Register等详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><h3 id="更多指令查看"><a href="#更多指令查看" class="headerlink" title="更多指令查看"></a>更多指令查看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><hr><h2 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h2><p>启动docker服务: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>重启docker服务: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看docker服务状态: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>设置开机启动docker服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="（1）查看-docker-本地主机镜像"><a href="#（1）查看-docker-本地主机镜像" class="headerlink" title="（1）查看 docker 本地主机镜像"></a>（1）查看 docker 本地主机镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101119.png"></p><p><strong>各个选项说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY：表示镜像的仓库源</span><br><span class="line">TAG：镜像的标签[类似版本号]</span><br><span class="line">IMAGE ID：镜像ID[唯一]</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br></pre></td></tr></table></figure><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 <code>REPOSITORY:TAG </code>来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用<code>ubuntu:latest</code>镜像</p><p><strong>OPTIONS说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a :列出本地所有的镜像（含中间映像层）[一个镜像可能不止一层，类似千层饼]</span><br><span class="line">-q :只显示镜像ID [在删除镜像时,可能要 -qa 结合使用]</span><br><span class="line">--digests :显示镜像的摘要信息</span><br><span class="line">--no-trunc :显示完整的镜像信息</span><br></pre></td></tr></table></figure><h3 id="（2）docker-search-某个XXX镜像名字"><a href="#（2）docker-search-某个XXX镜像名字" class="headerlink" title="（2）docker search 某个XXX镜像名字"></a>（2）docker search 某个XXX镜像名字</h3><p><strong>网站：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;hub.docker.com</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101120.png"></p><p><strong>命令：</strong>搜索镜像是从 docker Hub 官网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [OPTIONS] 镜像名字</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明：</span><br><span class="line">--no-trunc : 显示完整的镜像描述</span><br><span class="line">-s : 列出收藏数不小于指定值的镜像</span><br><span class="line">--automated : 只列出 automated build类型的镜像；</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101121.png"></p><h3 id="（3）docker-pull-某个XXX镜像名字"><a href="#（3）docker-pull-某个XXX镜像名字" class="headerlink" title="（3）docker  pull  某个XXX镜像名字"></a>（3）docker  pull  某个XXX镜像名字</h3><p>下载镜像：如果不指定版本，则默认下载 latest 最新版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名字[:TAG]</span><br></pre></td></tr></table></figure><h3 id="（4）docker-rmi-某个XXX镜像名字-ID"><a href="#（4）docker-rmi-某个XXX镜像名字-ID" class="headerlink" title="（4）docker  rmi  某个XXX镜像名字 ID"></a>（4）docker  rmi  某个XXX镜像名字 ID</h3><p>删除镜像：如果不指定版本，则默认删除 latest 最新版</p><p>删除单个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像ID&#x2F;镜像名字</span><br></pre></td></tr></table></figure><p>删除多个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像名1:TAG 镜像名2:TAG </span><br></pre></td></tr></table></figure><p>删除全部：先找到所有镜像 ID，再进行删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><hr><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>根本前提：必须要有镜像才能创建容器</p><p> <strong>CentOS 镜像演示</strong></p><h4 id="从仓库下载镜像"><a href="#从仓库下载镜像" class="headerlink" title="从仓库下载镜像"></a>从仓库下载镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101122.png"></p><h4 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101123.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OPTIONS说明（常用）：有些是一个减号，有些是两个减号</span><br><span class="line"></span><br><span class="line">--name&#x3D;&quot;容器新名字&quot;: 为容器指定一个名称；[不指定时,会默认给1个名字]</span><br><span class="line">-d: 后台运行容器，并返回容器ID，也即启动守护式容器；[后台启动]</span><br><span class="line"></span><br><span class="line">-i：以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；[两者结合使用,启动并显示伪终端]</span><br><span class="line"></span><br><span class="line">-P: 随机端口映射；[不指定时,会默认给定端口,使用 docker ps 查看]</span><br><span class="line">-p: 指定端口映射，有以下四种格式[一般使用第三种,主机端口:容器端口]</span><br><span class="line">      ip:hostPort:containerPort</span><br><span class="line">      ip::containerPort</span><br><span class="line">      hostPort:containerPort</span><br><span class="line">      containerPort</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动交互式容器:</span><br><span class="line">可简单理解为:要显示伪终端, &#x2F;bin&#x2F;bash 可加可不加,这是因为在构建时加上了CMD 末尾有这个命令；同时如果不指定版本，默认启动 latest </span><br></pre></td></tr></table></figure><h4 id="列出当前所有正在运行的容器"><a href="#列出当前所有正在运行的容器" class="headerlink" title="列出当前所有正在运行的容器"></a>列出当前所有正在运行的容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101124.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS说明（常用）：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的 [列出所有容器]</span><br><span class="line"></span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line"></span><br><span class="line">-n：显示最近n个创建的容器。</span><br><span class="line"></span><br><span class="line">-q :静默模式，只显示容器编号。[配合 -aq 使用，用于删除所有容器]</span><br><span class="line"></span><br><span class="line">--no-trunc :不截断输出。</span><br></pre></td></tr></table></figure><h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><h5 id="方式-1：容器停止退出"><a href="#方式-1：容器停止退出" class="headerlink" title="方式 1：容器停止退出"></a>方式 1：容器停止退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit   容器就停止运行了</span><br></pre></td></tr></table></figure><h5 id="方式-2：容器不停止退出"><a href="#方式-2：容器不停止退出" class="headerlink" title="方式 2：容器不停止退出"></a>方式 2：容器不停止退出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + P + Q    容器在后台运行</span><br></pre></td></tr></table></figure><p>如何再次进入正在运行中的容器也有两种方式，看后面介绍 。</p><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><p>有时候需要停止正在运行的容器，就是用这个命令 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除一个容器:</span><br><span class="line">docker rm 容器ID</span><br><span class="line">一次性删除多个容器:</span><br><span class="line">方式 1: docker rm -f $(docker ps -a -q)</span><br><span class="line">方式 2: docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure><hr><h4 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h4><h5 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>以后台模式启动一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure><p>会发现容器已经退出！！！</p><p>很重要的要说明的一点: Docker 容器后台运行,就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p>这个是 docker 的机制问题,比如你的 web 容器,我们以 nginx 为例，正常情况下,我们配置启动服务只需要启动响应的 service 即可。例如 service nginx start</p><p>但是,这样做,nginx 为后台进程模式运行,就导致 docker 前台没有运行的应用,</p><p>这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.</p><p>所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行 。</p><hr><h5 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail 容器ID</span><br><span class="line"></span><br><span class="line">*   -t 是加入时间戳</span><br><span class="line">*   -f 跟随最新的日志打印</span><br><span class="line">*   --tail 数字 显示最后多少条</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><p>运行容器，并让其不断输出语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos &#x2F;bin&#x2F;sh -c &quot;while true;do echo hello zzyy;sleep 2;done&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101125.png"></p><p>查看每个时间下，日志尾的最新 10 条</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101126.png"></p><h5 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure><h5 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h5><p>此命令可以用来查看该容器进行数据卷的主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><h5 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h5><p>前面提到 使用 ctrl + Q + P 退出伪终端后，想要再次进入该怎么办，</p><p><strong>方式 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID bashShell</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101127.png"></p><p><strong>方式 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101128.png"></p><p><strong>上述两个区别</strong></p><p>attach 直接进入容器启动命令的终端，不会启动新的进程 。</p><p>exec 是在容器中打开新的终端，并且可以启动新的进程 【隔山打牛】。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101129.png"></p><h5 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101130.png"></p><hr><p><strong>容器命令总结：</strong></p><p>查看容器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 查看正在运行的容器 </span><br><span class="line">docker ps –a # 查看所有容器</span><br></pre></td></tr></table></figure><p>创建并启动容器 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run 参数</span><br><span class="line"></span><br><span class="line">i：保持容器运行。通常与-t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容 器自动关闭。 </span><br><span class="line">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</span><br><span class="line">-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容 器不会关闭。</span><br><span class="line">-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</span><br><span class="line">--name：为创建的容器命名。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name&#x3D;c1 centos:7 &#x2F;bin&#x2F;bash #创建交互式容器 </span><br><span class="line">docker run -id --name&#x3D;c2 centos:7 #创建守护式容器</span><br></pre></td></tr></table></figure><p>**注意： ** 交互式容器，exit后容器自动关闭，守护式容器会在后台执行</p><p>进入容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it c2 &#x2F;bin&#x2F;bash #进入容器</span><br></pre></td></tr></table></figure><p>停止容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名称</span><br></pre></td></tr></table></figure><p>删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称</span><br></pre></td></tr></table></figure><p>查看容器信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名称</span><br></pre></td></tr></table></figure><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>常用命令</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101131.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">attach  Attach to a running container  # 当前 shell 下 attach 连接指定运行镜像</span><br><span class="line"></span><br><span class="line">build   Build an image from a Dockerfile   # 通过 Dockerfile 定制镜像</span><br><span class="line"></span><br><span class="line">commit  Create a new image from a container changes  # 提交当前容器为新的镜像</span><br><span class="line"></span><br><span class="line">cp   Copy files&#x2F;folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line"></span><br><span class="line">create  Create a new container   # 创建一个新的容器，同 run，但不启动容器</span><br><span class="line"></span><br><span class="line">diff  Inspect changes on a container&#39;s filesystem  # 查看 docker 容器变化</span><br><span class="line"></span><br><span class="line">events Get real time events from the server   # 从 docker 服务获取容器实时事件</span><br><span class="line"></span><br><span class="line">exec   Run a command in an existing container    # 在已存在的容器上运行命令</span><br><span class="line"></span><br><span class="line">export Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line"></span><br><span class="line">history  Show the history of an image     # 展示一个镜像形成历史</span><br><span class="line"></span><br><span class="line">images    List images                          # 列出系统当前镜像</span><br><span class="line"></span><br><span class="line">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line"></span><br><span class="line">info      Display system-wide information               # 显示系统相关信息</span><br><span class="line"></span><br><span class="line">inspect   Return low-level information on a container   # 查看容器详细信息</span><br><span class="line"></span><br><span class="line">kill      Kill a running container                      # kill 指定 docker 容器</span><br><span class="line"></span><br><span class="line">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line"></span><br><span class="line">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span><br><span class="line"></span><br><span class="line">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</span><br><span class="line"></span><br><span class="line">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span><br><span class="line"></span><br><span class="line">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span><br><span class="line"></span><br><span class="line">pause     Pause all processes within a container        # 暂停容器</span><br><span class="line"></span><br><span class="line">ps        List containers                               # 列出容器列表</span><br><span class="line"></span><br><span class="line">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line"></span><br><span class="line">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line"></span><br><span class="line">restart   Restart a running container                   # 重启运行的容器</span><br><span class="line"></span><br><span class="line">rm        Remove one or more containers                 # 移除一个或者多个容器</span><br><span class="line"></span><br><span class="line">rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line"></span><br><span class="line">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span><br><span class="line"></span><br><span class="line">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">start     Start a stopped containers                    # 启动容器</span><br><span class="line"></span><br><span class="line">stop      Stop a running containers                     # 停止容器</span><br><span class="line"></span><br><span class="line">tag       Tag an image into a repository                # 给源中镜像打标签</span><br><span class="line"></span><br><span class="line">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span><br><span class="line"></span><br><span class="line">unpause   Unpause a paused container                    # 取消暂停容器</span><br><span class="line"></span><br><span class="line">version   Show the docker version information           # 查看 docker 版本号</span><br><span class="line"></span><br><span class="line">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_Docker安装</title>
      <link href="2021/02/17/Docker/2-Docker%E5%AE%89%E8%A3%85/"/>
      <url>2021/02/17/Docker/2-Docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Docker安装"><a href="#2-Docker安装" class="headerlink" title="2_Docker安装"></a>2_Docker安装</h1><h2 id="前提说明"><a href="#前提说明" class="headerlink" title="前提说明"></a>前提说明</h2><h3 id="CentOS-Docker-安装"><a href="#CentOS-Docker-安装" class="headerlink" title="CentOS Docker 安装"></a>CentOS Docker 安装</h3><p>Docker 支持以下的 CentOS 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CentOS 7 (64-bit)</span><br><span class="line">CentOS 6.5 (64-bit) 或更高的版本</span><br></pre></td></tr></table></figure><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>目前，CentOS 仅发行版本中的内核支持 Docker。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。</span><br><span class="line"></span><br><span class="line">Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</span><br></pre></td></tr></table></figure><h3 id="查看自己的内核"><a href="#查看自己的内核" class="headerlink" title="查看自己的内核"></a>查看自己的内核</h3><p>uname 命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100950.png"></p><h3 id="查看已安装的CentOS版本信息"><a href="#查看已安装的CentOS版本信息" class="headerlink" title="查看已安装的CentOS版本信息"></a>查看已安装的CentOS版本信息</h3><p>CentOs 6：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100951.png"></p><p>CentOs 7：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100952.png"></p><h2 id="Docker-的基本组成"><a href="#Docker-的基本组成" class="headerlink" title="Docker 的基本组成"></a>Docker 的基本组成</h2><h3 id="镜像（images）"><a href="#镜像（images）" class="headerlink" title="镜像（images）"></a>镜像（images）</h3><p>Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，<strong>一个镜像可以创建很多容器</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100953.png"></p><h3 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h3><p>Docker 利用容器（Container）独立运行的一个或一组应用。<strong>容器是用镜像创建的运行实例。</strong></p><p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p><strong>可以把容器看做是一个简易版的 Linux 环境</strong>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><h3 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h3><p>仓库（Repository）是<strong>集中存放镜像</strong>文件的场所。</p><p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）【不同标签对应不同的版本】。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p><strong>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)%EF%BC%8C">https://hub.docker.com/)，</a></strong></p><p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等【一般下载镜像都在这上面下载，速度比较快】 。</p><p><strong>小总结</strong></p><p>需要正确的理解仓储/镜像/容器这几个概念:</p><p> Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。<strong>image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</strong></p><p>*  image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p><p>*  一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p><p>* 至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来就可以了。</p><h3 id="Docker-的架构图"><a href="#Docker-的架构图" class="headerlink" title="Docker 的架构图"></a>Docker 的架构图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100954.png"></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="CentOS-7-安装-Docker"><a href="#CentOS-7-安装-Docker" class="headerlink" title="CentOS 7 安装 Docker"></a>CentOS 7 安装 Docker</h3><p>可以选择参考官网：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100955.png"></p><h4 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤"></a>安装步骤</h4><h5 id="1-官网中文安装参考手册"><a href="#1-官网中文安装参考手册" class="headerlink" title="1.官网中文安装参考手册"></a>1.官网中文安装参考手册</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.docker-cn.com&#x2F;engine&#x2F;installation&#x2F;linux&#x2F;docker-ce&#x2F;centos&#x2F;#prerequisites</span><br></pre></td></tr></table></figure><h5 id="2-确定你是CentOS7及以上版本"><a href="#2-确定你是CentOS7及以上版本" class="headerlink" title="2.确定你是CentOS7及以上版本"></a>2.确定你是CentOS7及以上版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;redhat-release</span><br></pre></td></tr></table></figure><h5 id="3-yum安装gcc相关"><a href="#3-yum安装gcc相关" class="headerlink" title="3.yum安装gcc相关"></a>3.yum安装gcc相关</h5><p>CentOS7能上外网</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100956.png"></p><blockquote><p>CentOs 7 如何连接外网，可参考我这篇博客</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><h5 id="4-卸载旧版本"><a href="#4-卸载旧版本" class="headerlink" title="4.卸载旧版本"></a>4.卸载旧版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>官网版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h5 id="5-安装需要的软件包"><a href="#5-安装需要的软件包" class="headerlink" title="5.安装需要的软件包"></a>5.安装需要的软件包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h5 id="6-设置-stable-镜像仓库"><a href="#6-设置-stable-镜像仓库" class="headerlink" title="6.设置 stable 镜像仓库"></a>6.设置 stable 镜像仓库</h5><p>大坑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h5 id="7-更新-yum-软件包索引"><a href="#7-更新-yum-软件包索引" class="headerlink" title="7.更新 yum 软件包索引"></a>7.更新 yum 软件包索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h5 id="8-安装DOCKER-CE"><a href="#8-安装DOCKER-CE" class="headerlink" title="8.安装DOCKER CE"></a>8.安装DOCKER CE</h5><p>CE 表示社区版，EE 表示企业版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><h5 id="9-启动-docker"><a href="#9-启动-docker" class="headerlink" title="9.启动 docker"></a>9.启动 docker</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h5 id="10-测试"><a href="#10-测试" class="headerlink" title="10.测试"></a>10.测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100957.png"></p><p>Docker 成功安装！！！</p><p>此时还可以从 docker 仓库下载其提供的镜像进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker </span><br><span class="line">yum -y remove docker-ce</span><br><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure><h2 id="永远的-HelloWorld"><a href="#永远的-HelloWorld" class="headerlink" title="永远的 HelloWorld"></a>永远的 HelloWorld</h2><p>每次下载镜像如果都从 docker 官网进行下载，速度太慢，所以需更换镜像下载的地址为国内的（阿里云或者网易云）</p><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><h4 id="1、注册一个属于自己的阿里云账户-可复用淘宝账号"><a href="#1、注册一个属于自己的阿里云账户-可复用淘宝账号" class="headerlink" title="1、注册一个属于自己的阿里云账户(可复用淘宝账号)"></a>1、注册一个属于自己的阿里云账户(可复用淘宝账号)</h4><h4 id="2、获得加速器地址连接"><a href="#2、获得加速器地址连接" class="headerlink" title="2、获得加速器地址连接"></a>2、获得加速器地址连接</h4><h5 id="（1）登陆阿里云开发者平台"><a href="#（1）登陆阿里云开发者平台" class="headerlink" title="（1）登陆阿里云开发者平台"></a>（1）登陆阿里云开发者平台</h5><h5 id="（2）获取加速器地址"><a href="#（2）获取加速器地址" class="headerlink" title="（2）获取加速器地址"></a>（2）获取加速器地址</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100958.png"></p><h4 id="3、配置本机Docker运行镜像加速器"><a href="#3、配置本机Docker运行镜像加速器" class="headerlink" title="3、配置本机Docker运行镜像加速器"></a>3、配置本机Docker运行镜像加速器</h4><p> CentoS 7：</p><p>（1）进入到 docker 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;etc&#x2F;docker</span><br></pre></td></tr></table></figure><p>（2）创建 daemon.json 文件，并添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100959.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>（3）重新启动 Docker 后台服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>（4）Linux 系统下配置完加速器需要检查是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep docker</span><br></pre></td></tr></table></figure><h3 id="网易云加速"><a href="#网易云加速" class="headerlink" title="网易云加速"></a>网易云加速</h3><p>基本同上述阿里云</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101000.png"></p><h3 id="启动Docker后台容器-测试运行-hello-world"><a href="#启动Docker后台容器-测试运行-hello-world" class="headerlink" title="启动Docker后台容器(测试运行 hello-world)"></a>启动Docker后台容器(测试运行 hello-world)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101001.png"></p><p>输出这段提示以后，hello world就会停止运行，容器自动终止。</p><p><strong>run干了什么</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101002.png"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="Docker是怎么工作的"><a href="#Docker是怎么工作的" class="headerlink" title="Docker是怎么工作的"></a>Docker是怎么工作的</h3><p>Docker是一个Client-Server结构的系统，Docker 守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 <strong>容器，是一个运行时环境，就是我们前面说到的集装箱。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101003.png"></p><h3 id="为什么Docker比较比VM快"><a href="#为什么Docker比较比VM快" class="headerlink" title="为什么Docker比较比VM快"></a>为什么Docker比较比VM快</h3><p>(1)docker 有着比虚拟机更少的抽象层。由于 docker <strong>不需要 Hypervisor 实现硬件资源虚拟化</strong>,运行在 docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>(2)<strong>docker 利用的是宿主机的内核</strong>,而不需要 Guest OS。因此,当新建一个容器时,docker 不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载 Guest OS,返个新建过程是分钟级别的。而 docker 由于直接利用宿主机的操作系统,则省略了返个过程,因此<strong>新建一个docker容器只需要几秒钟。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101004.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217101005.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1_Docker 简介</title>
      <link href="2021/02/17/Docker/1-Docker-%E7%AE%80%E4%BB%8B/"/>
      <url>2021/02/17/Docker/1-Docker-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker-简介"><a href="#1-Docker-简介" class="headerlink" title="1_Docker 简介"></a>1_Docker 简介</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h3 id="为什么会有docker出现"><a href="#为什么会有docker出现" class="headerlink" title="为什么会有docker出现"></a>为什么会有docker出现</h3><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验</p><p>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，<strong>软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100419.png"></p><p>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿电商项目的环境来说吧 Java/Tomcat/MySQL/JDBC 驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p><p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<strong>开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</strong></p><h3 id="docker-理念"><a href="#docker-理念" class="headerlink" title="docker 理念"></a>docker 理念</h3><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“<strong>一次封装，到处运行</strong>”。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100420.png"></p><p>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</strong></p><h3 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h3><p>解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><h3 id="之前的虚拟化技术"><a href="#之前的虚拟化技术" class="headerlink" title="之前的虚拟化技术"></a>之前的虚拟化技术</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。</p><p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100421.png"></p><p>虚拟机的缺点：</p><p>1   资源占用多        2   冗余步骤多         3   启动慢</p><h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100422.png"></p><p><strong>比较了 Docker 和传统虚拟化方式的不同之处：</strong></p><p>*传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p><p>*而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且<strong>也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</p><p>* 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><h3 id="开发-运维（DevOps）"><a href="#开发-运维（DevOps）" class="headerlink" title="开发/运维（DevOps）"></a>开发/运维（DevOps）</h3><p><strong>一次构建、随处运行</strong></p><ul><li>更快速的应用交付和部署</li><li>更便捷的升级和扩缩容</li><li>更简单的系统运维</li><li>更高效的计算资源利用</li></ul><h2 id="企业级"><a href="#企业级" class="headerlink" title="企业级"></a>企业级</h2><p>美团</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100423.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100424.png"></p><p>蘑菇街</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217100322.png"></p><h2 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a>去哪下</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p>docker官网：<a href="http://www.docker.com/">http://www.docker.com</a></p><p>docker中文网站：<a href="https://www.docker-cn.com/">https://www.docker-cn.com/</a></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Docker Hub官网: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="2021/02/17/%E5%B7%A5%E5%85%B7/Maven/"/>
      <url>2021/02/17/%E5%B7%A5%E5%85%B7/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="maven的使用"><a href="#maven的使用" class="headerlink" title="maven的使用"></a>maven的使用</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>Maven 项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。</p></blockquote><p><a href="http://maven.apache.org/">Maven官方地址</a></p><hr><p><strong>两个主要功能：</strong></p><ul><li>依赖管理-jar包管理 </li><li>项目构建-代码编译 </li></ul><hr><p> <strong>maven的模型：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095523.jpg"></p><hr><p> <strong>maven依赖管理原理分析：</strong></p><blockquote><p>优先从本地查找，若没有则从远程仓库，中央仓库查找,查找结果先返回给本地仓库，再返回给项目。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095524.png"></p><hr><p><strong>项目构建：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095525.png"></p><hr><p><strong>构建过程：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095526.png"></p><hr><p><strong>项目构建的方式：</strong></p><p>1.Ant </p><blockquote><p>Ant只是一个项目构建工具，它没有集成依赖管理。Ant在进行项目构建时，它没有对项目目录结构进行约定，需要手动指定源文件、类文件等目录地址。同 时它执行 task时，需要显示指定依赖的task，这样会造成大量的代码重复。</p></blockquote><p>2.Maven </p><blockquote><p>Maven不仅是一个<strong>项目构建工具</strong>，更是一个<strong>项目管理工具</strong>。它在项目构建工程中，比ant更全面，更灵活。 </p><p>Maven在进行项目构建时，它<strong>对项目目录结构拥有约定</strong>，知道你的源代码在哪里，类文件应该放到哪里 去。</p><p>它拥有<strong>生命周期的概念</strong>，maven的生命周期是有顺序的，在执行后面的生命周期的任务时，不需要显示的配</p><p>置前面任务的生命周期。</p><p>例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程。</p></blockquote><p>3.Gradle </p><blockquote><p>一个开源的自动化构建系统，建立在Apache Ant和Maven Apache概念的基础上，并引入了基于Groovy的 特定领 域语言（DSL），而不是使用Apache Maven宣布的项目配置XML形式。</p></blockquote><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="maven-安装"><a href="#maven-安装" class="headerlink" title="maven_安装"></a>maven_安装</h3><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><p>Maven下载：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 官网</span></span><br><span class="line">http://maven.apache.org/download.cgi</span><br><span class="line"></span><br><span class="line"><span class="section"># 百度云链接：https://pan.baidu.com/s/1N<span class="emphasis">_Xwk3aMefopq8Usi6m8cg </span></span></span><br><span class="line"><span class="section"><span class="emphasis"># 提取码：xjvo</span></span></span><br></pre></td></tr></table></figure><p>Maven中央仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mvnrepository.com&#x2F; </span><br></pre></td></tr></table></figure><hr><h4 id="2、确定jdk版本"><a href="#2、确定jdk版本" class="headerlink" title="2、确定jdk版本"></a>2、确定jdk版本</h4><blockquote><p>确定jdk 已经安装和配置(要求jdk版本最低1.8) </p></blockquote><p>​        <img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095527.jpg"></p><hr><h4 id="3、解压"><a href="#3、解压" class="headerlink" title="3、解压"></a>3、解压</h4><blockquote><p>把maven3.3.3解压到放到任意磁盘以及任意文件夹，注意:解压路径不要有中文 </p></blockquote><p>​        <img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095528.png"  /></p><hr><h4 id="4、确定IDEA版本"><a href="#4、确定IDEA版本" class="headerlink" title="4、确定IDEA版本"></a>4、确定IDEA版本</h4><blockquote><p>idea和maven的版本一定要兼容，我这里使用的idea版本:</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095529.png"></p><hr><h4 id="5、配置环境变量"><a href="#5、配置环境变量" class="headerlink" title="5、配置环境变量"></a>5、配置环境变量</h4><blockquote><p>“计算机”右键-&gt;“属性”-&gt;”高级系统设置”-&gt;“高级”-&gt;”环境变量”-&gt;”系统变量”-&gt;”新建” </p></blockquote><p><strong>添加系统变量：</strong></p><ul><li><p>变量名:M2_HOME （固定值） </p></li><li><p>变量值:F:\Maven\apache-maven-3.3.3（maven中bin文件夹的全路径） </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095530.png"></p></li></ul><p><strong>配置系统变量：</strong></p><p>在变量值的最前面添加下面代码:<code>%M2_HOME%\bin </code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095531.png"></p><hr><h6 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h6><p>打开cmd运行命令: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn –version</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095532.png"></p><p>若没有正确配置环境变量，可能显示找不到命令</p><hr><h3 id="Pom-xml"><a href="#Pom-xml" class="headerlink" title="Pom.xml"></a>Pom.xml</h3><p>Pom.xml文件说明: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 版本：4.0.0 --&gt;</span>                     <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 组织名称：暂时使用 组织名称+项目名称 作为组织名称 --&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 组织名称：实际名称 按照访问路径规范设置，通常以功能作为名称： eg: junit spring --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 当前项目版本号：同一个项目开发过程中可以发布多个版本，此处标示0.0.1版 --&gt;</span>      <span class="comment">&lt;!-- 当前项目版本号：每个工程发布后可以发布多个版本，依赖时调取不同的版本，使用不同的版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 名称：可省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖设置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖组织名称 --</span></span><br><span class="line"><span class="comment"> &lt;groupId&gt;junit&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment"> &lt;!-- 依赖项目名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖版本名称 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖范围：test包下依赖该设置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="搭建一个原生的Maven项目"><a href="#搭建一个原生的Maven项目" class="headerlink" title="搭建一个原生的Maven项目"></a>搭建一个原生的Maven项目</h3><p>1)通过文件夹的方式创建java项目 :</p><p>目录结构如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在某个磁盘的根目录按照下面结构创建文件夹</span><br><span class="line">ProjectName</span><br><span class="line">• |-src </span><br><span class="line">• |-main </span><br><span class="line">• |-java —— 存放项目的.java文件</span><br><span class="line">|-resources —— 存放项目资源文件 </span><br><span class="line">• |-test</span><br><span class="line">|-java ——存放所有测试.java文件，如JUnit测试类</span><br><span class="line">  |-target —— 目标文件输出位置例如.class、.jar、.war文件（不需要创建，会自动生成）     |-pom.xml ——maven项目核心配置文件</span><br></pre></td></tr></table></figure><p>2)src/main/java下创建目录，存放java代码</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095533.png"  /><p>注意:包目录是:com.kkb,而不包含前面的路径 </p><p>3)新建java文件,编写java代码</p><p>~~这里输出的内容最好是英文，中文会出乱码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kkb; <span class="comment">//注意这里的包路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;maven test success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4)在test/java文件夹下创建测试类的包结构</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095534.png"  /><p>5)编写测试类 </p><p>示例的包路径是:com.testkkb,</p><p>测试类文件名:TestDemo.java,</p><p>这里输出的内容最好是英文，中文会出乱码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testkkb;</span><br><span class="line"><span class="keyword">import</span> com.kkb.Demo;<span class="comment">//这里导入Demo类所在包，注意包路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;<span class="comment">//这里导入junit测试包，注意我们还没有给项目中添加依赖包 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I want get Demo Class&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Demo().test1();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6)在src同级文件夹下存放pom.xml文件</p><p>目的：这里开始引入Junit工具包 </p><p>注意:此时还未有target目录</p><p><img src= "/img/loading.gif" data-lazy-src="../../../Typora_%E5%B7%A5%E5%85%B7%E7%B1%BB/maven_%E4%BD%BF%E7%94%A8/images/pom_xml%E6%96%87%E4%BB%B6.png"></p><p>添加内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt; </span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.kkb.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;HelloWorld&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 依赖关系 --&gt;</span><br><span class="line">    &lt;dependencies&gt; </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>7)通过maven命令行的方式运行项目</p><p>打开cmd后，进入到项目文件夹，运行<code>mvn test</code>命令进行junit测试</p><p><img src= "/img/loading.gif" data-lazy-src="../../../Typora_%E5%B7%A5%E5%85%B7%E7%B1%BB/maven_%E4%BD%BF%E7%94%A8/images/%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9.png"></p><p>命令运行完后，程序会自动下载所需的依赖包，注意这里<strong>不仅仅是junit测试包，还有maven环境的依赖包</strong>，所以需 要耐心等待一段时间。这里依赖包会下载到本地磁盘，后续再使用的时候就不会重新下载了。 </p><hr><ol start="8"><li>运行结果:</li></ol><p>会在src同级目录下<code>生成target文件夹</code>，在cmd命令界面可以看到运行结果，说明maven项目结构运行成功。 </p><p><img src= "/img/loading.gif" data-lazy-src="../../../Typora_%E5%B7%A5%E5%85%B7%E7%B1%BB/maven_%E4%BD%BF%E7%94%A8/images/%E6%9E%84%E5%BB%BA%E7%BB%93%E6%9E%9C.png"></p><hr><h3 id="Maven-常用指令"><a href="#Maven-常用指令" class="headerlink" title="Maven_常用指令"></a>Maven_常用指令</h3><blockquote><p>前提：需要在 pom.xml 所在目录中执行以下命令。</p></blockquote><h5 id="1-Mvn-compile-编译"><a href="#1-Mvn-compile-编译" class="headerlink" title="1)Mvn compile_编译"></a>1)Mvn compile_编译</h5><ul><li>执行 <code>mvn compile</code>命令，完成编译操作 。</li><li>执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</li></ul><hr><h5 id="2-Mvn-clean-清除"><a href="#2-Mvn-clean-清除" class="headerlink" title="2)Mvn clean_清除"></a>2)Mvn clean_清除</h5><ul><li>执行 mvn clean命令,执行完毕后，会将target目录删除。 </li></ul><hr><h5 id="3-Mvn-test-测试"><a href="#3-Mvn-test-测试" class="headerlink" title="3)Mvn test _测试"></a>3)Mvn test _测试</h5><ul><li><p>执行 mvn test命令，完成单元测试操作。</p></li><li><p>执行完毕后，会在target目录中生成三个文件夹：</p><p>surefifire、 surefifire- reports（测试报告）、test-classes（测试的字节码文件）</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095535.png"></p><hr></li></ul><h5 id="4-Maven-package-打包"><a href="#4-Maven-package-打包" class="headerlink" title="4)Maven package_打包"></a>4)Maven package_打包</h5><ul><li>执行 mvn package命令，完成打包操作。</li><li>执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095536.png"></p><hr><h5 id="5-Mvn-install-部署"><a href="#5-Mvn-install-部署" class="headerlink" title="5)Mvn install _部署"></a>5)<strong>Mvn install</strong> _部署</h5><ul><li>执行 mvn install 命令，完成将打好的jar包安装到本地仓库的操作。</li><li>执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用。</li></ul><hr><p>如何查看本地仓库位置:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095537.png"></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095538.png" style="zoom: 80%;" /><p>打包到本地仓库的jar包</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095539.png"></p><hr><h5 id="6-mvn-clean-compile-清除并编译"><a href="#6-mvn-clean-compile-清除并编译" class="headerlink" title="6)mvn clean compile_清除并编译"></a>6)mvn clean compile_清除并编译</h5><ul><li>cmd 中录入 mvn clean compile 命令 </li><li>组合指令，先执行clean，再执行compile，通常应用于<strong>上线前执行</strong>，清除测试类 。</li></ul><hr><h5 id="7-mvn-clean-test-清除并测试"><a href="#7-mvn-clean-test-清除并测试" class="headerlink" title="7)mvn clean test_清除并测试"></a>7)mvn clean test_清除并测试</h5><ul><li>cmd 中录入 mvn clean test 命令 </li><li>组合指令，先执行clean，再执行test，通常应用于<strong>测试环节</strong> </li></ul><hr><h5 id="8-mvn-clean-package-清除并打包"><a href="#8-mvn-clean-package-清除并打包" class="headerlink" title="8)mvn clean package_清除并打包"></a>8)mvn clean package_清除并打包</h5><ul><li>cmd 中录入 mvn clean package命令 </li><li>组合指令，先执行clean，再执行package，将项目打包，通常应用于<strong>发布前</strong> </li></ul><p>执行过程： </p><ul><li>清理————清空环境 </li><li>编译————编译源码 </li><li>测试————测试源码 </li><li>打包————将编译的非测试类打包 </li></ul><hr><h5 id="9-mvn-clean-install-清除并部署"><a href="#9-mvn-clean-install-清除并部署" class="headerlink" title="9)mvn clean install_清除并部署"></a>9)mvn clean install_清除并部署</h5><ul><li>cmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中 </li><li>组合指令，先执行clean，再执行install，将项目打包，通常应用于<strong>发布前</strong> </li></ul><p>执行过程： </p><ul><li>清理————清空环境 </li><li>编译————编译源码 </li><li>测试————测试源码 </li><li>打包————将编译的非测试类打包 </li><li>部署————将打好的包发布到资源仓库中 </li></ul><hr><h3 id="IDEA搭建Maven项目"><a href="#IDEA搭建Maven项目" class="headerlink" title="IDEA搭建Maven项目"></a>IDEA搭建Maven项目</h3><h4 id="搭建Java项目"><a href="#搭建Java项目" class="headerlink" title="搭建Java项目"></a>搭建Java项目</h4><h5 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h5><p>主界面中选择<code>Create New Project</code>,然后在左侧项目类型中选择<code>Maven</code></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095540.jpg"  /><hr><p>Maven 项目结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095541.png"></p><hr><p>补充: </p><ul><li>maven中的仓库分为两种，<strong>snapshot快照仓库</strong>和<strong>release发布仓</strong>库。</li><li>snapshot快照仓库用于保存<strong>开发过程中 的不稳定版本</strong>，release正式仓库则是用来保存<strong>稳定的发行版本。</strong></li><li>定义一个组件/模块为快照版本，只需要在pom文 件中在该模块的版本号后加上**-SNAPSHOT**即可(注意这里必须是大写)。 maven2会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。</li><li>如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情 况下，直接编译打包时，maven会<strong>自动从镜像服务器上下载最新的快照版本。</strong></li><li>如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块<strong>则不会主动去镜像服务器上下载。</strong></li></ul><hr><h5 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h5><h6 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1)添加依赖"></a>1)添加依赖</h6><p>在pom.xml文件中添加junit依赖包 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你之前安装过jdk版本..此时maven不知道你用的哪个,需要指定一下，比如我这里用的JDK11</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--多个jdk版本存在时--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完依赖包后，可以在左侧External Libraries目录下查看依赖包，此时TestDemo1.java文件不再报错 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095542.png"></p><hr><h6 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2)编写代码"></a>2)编写代码</h6><blockquote><p>在src/main/java下编写java代码，在src/test/java下编写测试代码</p></blockquote><p>Java代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xj0927;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-09-08 19:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Demo方法~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a>3）测试</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testxj0927;</span><br><span class="line"><span class="keyword">import</span> com.xj0927.Demo;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xj0927</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> Created in 2020-09-08 19:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Test</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是Demo测试类的方法~&quot;</span>);</span><br><span class="line">            Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">            demo.test(); </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="4）正常运行"><a href="#4）正常运行" class="headerlink" title="4）正常运行"></a>4）正常运行</h6><hr><h4 id="搭建Java-Web项目"><a href="#搭建Java-Web项目" class="headerlink" title="搭建Java Web项目"></a>搭建Java Web项目</h4><h5 id="1、创建项目-1"><a href="#1、创建项目-1" class="headerlink" title="1、创建项目"></a>1、创建项目</h5><blockquote><p>选择create New Project,左侧选择Maven,勾选右侧Create from archetype选项，选择下面区域中的 <code>maven-archetype-webapp</code>类型。 </p></blockquote><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095543.png"  /><hr><p><strong>补充:</strong></p><blockquote><p>archetype的意思就是<strong>模板原型</strong>的意思，原型是一个Maven项目模板工具包。</p></blockquote><p>开发中常用的archetype类型:</p><ul><li><code>maven-archetype-quickstart</code>(简单的java类型项目,除了pom.xml外，没有其他的xml了，但是有main、test两个包，包里放了一个App、AppTest类) </li><li><code>maven-archetype-webapp</code>(一个简单的Java Web应用程序)</li></ul><hr><h5 id="2、项目名称"><a href="#2、项目名称" class="headerlink" title="2、项目名称"></a>2、项目名称</h5><h5 id="3、配置属性"><a href="#3、配置属性" class="headerlink" title="3、配置属性"></a>3、配置属性</h5><h6 id="方式一：一次配置"><a href="#方式一：一次配置" class="headerlink" title="方式一：一次配置"></a>方式一：一次配置</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在Properties选项卡中，点击“＋”号，添加新属性 </span></span><br><span class="line">Name: archetypeCatalog </span><br><span class="line">Value :internal </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095544.png"></p><hr><h6 id="方式二：永久配置"><a href="#方式二：永久配置" class="headerlink" title="方式二：永久配置"></a>方式二：永久配置</h6><blockquote><p>在idea的主界面选择confifigure-&gt;settings</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095545.png"></p><hr><p>在搜索框中搜索:<code>runner</code>,在<code>VM Option选项卡</code>中添加配置代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DarchetypeCatalog&#x3D;internal</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095546.png"  /><p>保存退出后，重新启动软件。</p><hr><h3 id="修改本地仓库"><a href="#修改本地仓库" class="headerlink" title="修改本地仓库"></a>修改本地仓库</h3><h4 id="1、找到setting文件路径"><a href="#1、找到setting文件路径" class="headerlink" title="1、找到setting文件路径"></a>1、找到setting文件路径</h4><blockquote><p>maven路径的conf文件夹下</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095537.png"></p><hr><h4 id="2、默认仓库路径"><a href="#2、默认仓库路径" class="headerlink" title="2、默认仓库路径"></a>2、默认仓库路径</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095538.png"></p><hr><h4 id="3、修改Maven默认仓库"><a href="#3、修改Maven默认仓库" class="headerlink" title="3、修改Maven默认仓库"></a>3、修改Maven默认仓库</h4><blockquote><p>在任意磁盘下创建一个文件夹目录，该文件夹配置成你的本地仓库路径。</p><p>将localRepository标签配置到注释代码的外面，如上图↑</p></blockquote><hr><h3 id="IDEA改变maven版本"><a href="#IDEA改变maven版本" class="headerlink" title="IDEA改变maven版本"></a>IDEA改变maven版本</h3><blockquote><p>我们现在使用的idea都自带maven,但是实际开发中，可能idea自带的版本和我们使用的框架或jdk版本不兼容，那 么就需要我们更改idea中的maven版本。 </p></blockquote><h4 id="1、搜索“maven”"><a href="#1、搜索“maven”" class="headerlink" title="1、搜索“maven”"></a>1、搜索“maven”</h4><p>打开idea主界面，选择Confifigure-&gt;Setting,在搜索框搜索“maven”</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095547.png"  /><hr><h4 id="2、修改路径"><a href="#2、修改路径" class="headerlink" title="2、修改路径"></a>2、修改路径</h4><ul><li>修改<code>Maven home directory路径</code>，改成自己的<code>maven安装路径 </code></li><li>此时local repository会自动更新成我们修改的<code>本地仓库路径</code></li><li>修改settiing配置文件的路径，点击User settings fifile 选项后的<code>override</code>选项卡 </li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095548.png"  /><p>保存退出！！！</p><hr><h3 id="Maven相关概念"><a href="#Maven相关概念" class="headerlink" title="Maven相关概念"></a>Maven相关概念</h3><h4 id="maven-坐标"><a href="#maven-坐标" class="headerlink" title="maven_坐标"></a>maven_坐标</h4><blockquote><p>在maven中坐标就是为了<strong>定位一个唯一确定的jar包</strong>。</p><p>Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范。拥有了统一规范，就可以把查找工作交给机器 。</p></blockquote><p>坐标组成：</p><ul><li>groupId：定义当前Maven组织名称 </li><li>artifactId：定义实际项目名称 </li><li>version：定义当前项目的当前版本或者是所依赖的jar包的版本 </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demoProject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--快照版--&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="maven-特性"><a href="#maven-特性" class="headerlink" title="maven_特性"></a>maven_特性</h4><h5 id="1-依赖性"><a href="#1-依赖性" class="headerlink" title="1.依赖性"></a>1.依赖性</h5><h6 id="1-依赖管理"><a href="#1-依赖管理" class="headerlink" title="1)依赖管理"></a>1)依赖管理</h6><blockquote><p>就是<strong>对项目中jar 包的管理</strong>。可以在pom文件中定义jar包的<strong>GAV坐标</strong>，管理依赖。 </p></blockquote><p>依赖声明主要包含如下元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="2-依赖范围"><a href="#2-依赖范围" class="headerlink" title="2)依赖范围"></a>2)依赖范围</h6><p>即scope的属性值:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095549.png"></p><p><strong>scope属性值介绍:</strong> </p><p>1.compile ：编译范围，默认scope，在工程环境的 classpath（编译环境）和打包（<strong>如果是WAR包，会包含在WAR包中</strong>）时候都有效。 </p><p>2.provided ：容器或JDK已提供范围，表示该依赖包已经由目标容器（如tomcat）和JDK提供，只在编译的classpath中加载和使 用，<strong>打包的时候不会包含在目标包中 。</strong>最常见的是j2ee规范相关的servlet-api和jsp-api等jar包，一般由servlet容 器提供，无需在打包到war包中，如果不配置为provided，把这些包打包到工程war包中，在tomcat6以上版本会 出现冲突无法正常运行程序<strong>（版本不符的情况）。</strong> </p><p>3.runtime ：一般是运行和测试环境使用，编译时候不用加入classpath，<strong>打包时候会打包到目标包中</strong>。一般是通过动态加载或 接口反射加载的情况比较多。也就是说程序只使用了接口，具体的时候可能有多个，运行时通过配置文件或jar包扫 描动态加载的情况。典型的包括：JDBC驱动等。 </p><p>4.test ：测试范围，一般是单元测试场景使用，在编译环境加入classpath，但<strong>打包时不会加入</strong>，如junit等。 </p><p>5.system（一般不用，不同机器可能不兼容） ：系统范围，与provided类似，只是标记为该scope的依赖包需要明确指定基于文件系统的jar包路径。因为需要通过 systemPath指定本地jar文件路径，所以该scope是不推荐的。如果是基于组织的，一般会建立本地镜像，会把本 地的或组织的基础组件加入本地镜像管理，避过使用该scope的情况。</p><hr><h5 id="2-传递性"><a href="#2-传递性" class="headerlink" title="2.传递性"></a>2.传递性</h5><h6 id="1-直接依赖和间接依赖"><a href="#1-直接依赖和间接依赖" class="headerlink" title="1)直接依赖和间接依赖"></a>1)直接依赖和间接依赖</h6><p>如果B中使用A，C中使用B，则称B是C的<strong>直接依赖，</strong>而称A是C的<strong>间接依赖</strong>。 </p><ul><li>C-&gt;B  B-&gt;A </li><li>C直接依赖B </li><li>C间接依赖A </li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095550.png"></p><p><strong>依赖范围与依赖传递关系：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095551.png"></p><p>左边第一列表示第一直接依赖范围 </p><p>上面第一行表示第二直接依赖范围 </p><p>中间的交叉单元格表示传递性依赖范围。 </p><p>总结： </p><ul><li>(1) 当第二依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。 </li><li>(2) 当第二直接依赖的范围是test的时候，依赖不会得以传递。 </li><li>(3) 当第二依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为 provided； </li><li>(4) 当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递的依赖范围为runtime； </li></ul><hr><p><strong>依赖冲突_解决措施:</strong></p><ul><li>(1) 如果直接与间接依赖中包含有同一个坐标不同版本的资源依赖，以<strong>直接依赖的版本</strong>为准（就近原则） </li><li>(2) 如果直接依赖中包含有同一个坐标不同版本的资源依赖，以<strong>配置顺序下方的版本</strong>为准（就近原则） </li></ul><p><strong>可选依赖_设置方法:</strong></p><ul><li>true/false 用于设置是否可选，也可以理解为jar包是否向下传递。 </li><li>在依赖中添加optional选项决定此依赖是否向下传递，如果是true则不传递，如果是false就传递，<strong>默认为false</strong>。 </li></ul><p><strong>排除依赖_解决方法：</strong></p><p>在<code>直接依赖的配置</code>里面添加<code> exclusions→exclusion 元素</code>，指定要排除依赖的 groupId 和 artifactId 就行，如下面代码所示。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明:排除依赖包中所包含的依赖关系，<code>不需要添加版本号</code>。 </p><hr><h5 id="3-继承性"><a href="#3-继承性" class="headerlink" title="3.继承性"></a>3.继承性</h5><p>在一家开发公司里，很多项目中使用的jar包里80%是重复的，难道要每个项目都把这些pom.xml文件的依赖包复 制过来吗？如果后期出现统一的版本升级，那岂不是修改起来也很麻烦？如何解决呢？这里可以使用maven的继承特性来消除重复依赖，可以<strong>把很多相同的配置提取出来</strong>。例如：grouptId，version等 </p><p><strong>实现maven继承性的步骤:</strong> </p><h6 id="1、创建父工程："><a href="#1、创建父工程：" class="headerlink" title="1、创建父工程："></a>1、创建父工程：</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095552.png"></p><p>注意这类项目和原来项目的区别在于，打包方式是<code>pom</code>:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095553.jpg"></p><p>由于pom项目一般都是用来做父项目的，所以该项目的<code>src文件夹可以删除掉</code>。 </p><hr><h6 id="2、创建子工程"><a href="#2、创建子工程" class="headerlink" title="2、创建子工程:"></a>2、创建子工程:</h6><p>方式一：创建新工程为子工程，在创建时设置父工程的GAV。 </p><p>方式二：修改原有的工程为子工程，在子工程的pom.xml文件中手动添加父工程的GAV </p><p><strong>步骤：</strong>可以是java项目，也可以是java_web项目</p><p>先选中父项目的项目名，然后再按照图片步骤执行 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095554.png"></p><p>结果:在子项目的pom文件中，默认通过 parent 标签来继承父项目中的依赖包。这样避免了依赖包的重复依赖 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095555.png"></p><hr><h5 id="父工程统一管理版本号"><a href="#父工程统一管理版本号" class="headerlink" title="父工程统一管理版本号"></a>父工程统一管理版本号</h5><p>在开发中依赖的jar包众多，对应的版本也是很杂乱，那有没有一种方式可以统一管理这么jar包的版本值呢？当然 是有的，Maven使用<code>dependencyManagement</code>来管理依赖的版本号。 </p><p>注意：此处只是定义依赖jar包的版本号，并不实际依赖。如果子工程中需要依赖jar包还需要<code>添加dependency节点</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父工程：声明版本</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">子工程：不需要指定版本号(先继承父元素)</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>father<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kkb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--这里不需要指定版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="父工程中版本号提取"><a href="#父工程中版本号提取" class="headerlink" title="父工程中版本号提取"></a>父工程中版本号提取</h5><p>当父工程中定义的jar包越来越多，找起来越来越麻烦，所以可以<strong>把版本号提取成一个属性集中管理</strong>。 </p><p>定义版本：注意这里的 <code>log4j.version</code>的值是自定义的，但命名时不要使用中文或特殊字符等，标签对中间写版本值 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.9<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用:<code>$&#123;log4j.version&#125;</code>读取该变量值，代码如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子工程的jar包版本不受影响</p><hr><h4 id="maven-生命周期"><a href="#maven-生命周期" class="headerlink" title="maven_生命周期"></a>maven_生命周期</h4><blockquote><p> Maven生命周期就是为了对所有的构建过程进行抽象和统一。包括<strong>项目清理、初始化、编译、打包、测试、部署等几乎所有构建步骤</strong>。</p><p> 生命周期可以理解为构建工程的步骤。 </p></blockquote><p>三套相互独立的生命周期：</p><ul><li>(1) Clean Lifecycle： 在进行真正的构建之前进行一些<strong>清理工作</strong>。 Mvn clean </li><li>(2) Default Lifecycle： 构建的核心部分，编译，测试，打包，部署等等。 Mvn compile test package install deploy </li><li>(3) Site Lifecycle： <strong>生成项目报告</strong>，站点，发布站点。mvn site </li></ul><hr><h5 id="clean：清理项目"><a href="#clean：清理项目" class="headerlink" title="clean：清理项目"></a>clean：清理项目</h5><blockquote><p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行 mvn clean ，这个的clean是Clean生命周期的一个阶段。有Clean生命周期，也有clean阶段。</p></blockquote><p>Clean生命周期一共 包含了三个阶段： </p><ul><li>pre-clean:执行清理前需要完成的工作 </li><li>clean:清理上一次构建过程中生成的文件，比如编译后的class文件等。 </li><li>post-clean:执行清理后需要完成的工作 </li></ul><hr><h5 id="default：构建项目"><a href="#default：构建项目" class="headerlink" title="default：构建项目"></a>default：构建项目</h5><blockquote><p>Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些 </p></blockquote><p>比较重要和常用的阶段： </p><ul><li>validate 验证项目结构是否正常，必要的配置文件是否存在 </li><li>initialize 做构建前的初始化操作，比如初始化参数，创建必要的目录等 </li><li>generate-sources 产生在编译过程中需要的源代码 </li><li>process-sources 处理源代码，比如过滤值 </li><li><strong>generate-resources</strong> 产生主代码中的资源在classpath中的包 </li><li><strong>process-resources</strong> 复制并处理资源文件，至目标目录，准备打包。 </li><li><strong>compile</strong> 编译项目的源代码。 </li><li>process-classes 产生编译过程中生成的文件 </li><li>generate-test-sources 产生编译过程中测试相关的代码 </li><li>process-test-sources 处理测试代码 </li><li><strong>generate-test-resources</strong> 产生测试中资源在classpath中的包 </li><li><strong>process-test-resources</strong> 复制并处理资源文件，至目标测试目录</li><li><strong>test-compile</strong> 编译测试源代码。 </li><li>process-test-classes 产生编译测试代码过程的文件 </li><li><strong>test</strong> 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 </li><li>prepare-package 处理打包前需要初始化的准备工作 </li><li>package 接受编译好的代码，打包成可发布的格式，如 JAR 。 </li><li>pre-integration-test 做好集成测试前的准备工作，比如集成环境的参数设置 </li><li>integration-test 集成测试 </li><li>post-integration-test 完成集成测试前的准备工作，比如集成环境的参数设置 </li><li>verify 检测测试后的包是否完好 </li><li><strong>install</strong> 将包安装至本地仓库，以让其它项目依赖。 </li><li><strong>deploy</strong> 将最终的包复制到远程的仓库，以让其它开发人员与项目共享</li></ul><p><strong>运行任何一个阶段的时候，它前面的所有阶段都会被运行</strong>，这也就是为什么我们运行mvn install 的时候，代码会 被编译，测试，打包。此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要。 </p><hr><h5 id="site：生成项目站点"><a href="#site：生成项目站点" class="headerlink" title="site：生成项目站点"></a>site：生成项目站点</h5><p>Site生命周期 </p><ul><li>pre-site 执行一些需要在生成站点文档之前完成的工作 </li><li>site 生成项目的站点文档 </li><li>post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 </li><li>site-deploy 将生成的站点文档部署到特定的服务器上 </li></ul><p>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能， Manager比较喜欢，文档及统计数据自动生成，很好看。 </p><hr><h4 id="maven-插件"><a href="#maven-插件" class="headerlink" title="maven_插件"></a>maven_插件</h4><blockquote><p>Maven的核心仅仅定义了抽象的生命周期，<strong>具体的任务都是交由插件完成的</strong>。每个插件都能实现一个功能，每个功能就是一个插件目标。<strong>Maven的生命周期与插件目标相互绑定</strong>，以完成某个具体的构建任务。 </p></blockquote><p>compile就是插件<code>maven-compiler-plugin</code>的一个插件目标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接修改maven的<code>setting.xml</code>文件 在里面添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h5 id="Tomcat插件"><a href="#Tomcat插件" class="headerlink" title="Tomcat插件"></a>Tomcat插件</h5><blockquote><p>我们之前创建的web项目都需要额外配置tomcat以后才能运行项目，现在maven提供了tomcat插件，这样我们就无需再添加额外的tomcat了。</p></blockquote><p>1、创建maven类型的web工程</p><p>2、pom.xml文件中添加插件信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、点击“add confifiguration”,按照图片中的步骤添加tomcat命令，运行tomcat插件</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095556.jpg"></p><hr><p>运行方式1: </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 运行tomcat6（默认） </span></span><br><span class="line">tomcat:run </span><br></pre></td></tr></table></figure><p>运行方式2: </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 运行tomcat7（推荐，但是需要添加插件） </span></span><br><span class="line">tomcat7:run </span><br></pre></td></tr></table></figure><hr><h4 id="maven-私服"><a href="#maven-私服" class="headerlink" title="maven_私服"></a>maven_私服</h4><h5 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h5><p>仓库的分类 :</p><ul><li><p>本地仓库 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 每个用户只有一个本地仓库 </span></span><br><span class="line">~/.m2/repository </span><br></pre></td></tr></table></figure></li><li><p>远程仓库 </p><p>中央仓库：Maven默认的远程仓库，不包含版权资源 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2 </span><br></pre></td></tr></table></figure><p>私服：是一种特殊的远程仓库，它是架设<code>在局域网内的仓库 </code></p></li></ul><hr><h5 id="Nexus搭建与使用"><a href="#Nexus搭建与使用" class="headerlink" title="Nexus搭建与使用"></a>Nexus搭建与使用</h5><h6 id="1、安装Nexus"><a href="#1、安装Nexus" class="headerlink" title="1、安装Nexus"></a>1、安装Nexus</h6><p>下载网站：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 安装JDK1.8以上的版本 </span></span><br><span class="line">https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3 </span><br></pre></td></tr></table></figure><hr><h6 id="2、解压nexus压缩包"><a href="#2、解压nexus压缩包" class="headerlink" title="2、解压nexus压缩包"></a>2、解压nexus压缩包</h6><h6 id="3、注册服务"><a href="#3、注册服务" class="headerlink" title="3、注册服务"></a>3、注册服务</h6><p>打开window的命令窗口，切换到解压的文件夹中bin目录下，运行<code>nexus.exe /install nexus</code>命令，注册服务</p><h6 id="4、启动Nexus服务"><a href="#4、启动Nexus服务" class="headerlink" title="4、启动Nexus服务"></a>4、启动Nexus服务</h6><p>在bin文件夹下运行<code>nexus /run</code>命令 </p><p>注意:启动命令会因为版本不同，指令也不同 </p><h6 id="5、打开网站"><a href="#5、打开网站" class="headerlink" title="5、打开网站"></a>5、打开网站</h6><p><a href="http://localhost:8081/">http://localhost:8081</a> </p><p>使用默认的用户名和密码登陆（admin/admin123） </p><p>查看现有仓库: </p><ul><li><p>proxy 表示远程获取 </p></li><li><p>group 组 </p></li><li><p>hosted 本机，第三方jar，如数据库驱动等，需要手动添加   </p></li><li><p>maven-central：maven中央库，默认从<a href="https://repo1.maven.org/maven2/%E8%8E%B7%E5%8F%96jar">https://repo1.maven.org/maven2/获取jar</a> </p></li><li><p>maven-releases：私库发行版jar </p></li><li><p>maven-snapshots：私库快照（调试版本）jar </p></li><li><p>maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml中使用</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217095557.jpg"></p><hr><h6 id="6、使用"><a href="#6、使用" class="headerlink" title="6、使用"></a>6、使用</h6><blockquote><p>配置所有构建均从私服下载 </p></blockquote><p>1）添加镜像配置,将所有访问外网仓库的请求指向私服； </p><p>settings.xml文件 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> <span class="comment">&lt;!--匹配所有的远程仓库--&gt;</span>              <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明:url配置，描述的便是 上一步中提到的那个<strong>Public Reposiories</strong>的信息，这个地址便是他的地址，这些写都可以在界面上看到 ,这里的是localhost是在本机搭建测试用的,如果是公司内部的仓库的话，可自行修改成公司内网ip 地址</p><hr><p>2）添加中央仓库配置 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>3）生效配置 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="配置阿里云镜像仓库"><a href="#配置阿里云镜像仓库" class="headerlink" title="配置阿里云镜像仓库"></a>配置阿里云镜像仓库</h3><blockquote><p>阿里云镜像仓库是国内服务器，下载速度更快。 </p></blockquote><p>修改setting文件: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="2021/02/17/%E5%B7%A5%E5%85%B7/Git/"/>
      <url>2021/02/17/%E5%B7%A5%E5%85%B7/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git版本控制"><a href="#Git版本控制" class="headerlink" title="Git版本控制"></a>Git版本控制</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li><p>多个开发人员共同负责同一个软件或文档的开发，每个人在各自的机器上有整个软件文档的备份，并对之实施编程开发，在分别完成各自任务之后，再通过文本比对工具将各自机器上的不同版本的程序整合到一台机器上。</p></li><li><p><strong>实现开发团队并行开发、提高开发效率的基础。</strong></p></li><li><p><strong>对软件开发进程中文件或目录的发展过程提供有效的追踪手段，</strong>保证在需要时可回到旧的版本，避免文件的丢失、修改的丢失和相互覆盖，通过对版本库的访问控制避免未经授权的访和修改，达到有效保护企业软件资产和知识产权的目的。</p></li><li><p><strong>版本控制的功能在于跟踪记录整个软件的开发过程</strong>，包括软件本身和相关文档，以便对不同阶段的软件及相关文档进行表示并进行差别分析，对软件代码进行可撤消的修改，便于汇总不同开发人员所做的修改，辅助协调和管理软件开发团队。</p></li></ul><hr><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>1)Visual Source Safe(简称VSS）</p><ul><li><p>VSS是美国微软公司的产品，目前常用的版本为6.0版。VSS是配置管理的一种很好的入门级的工具。</p></li><li><p>VSS只能在<strong>windows</strong>平台上运行，不能运行在其他操作系统上。</p></li><li><p>VSS提供share（共 享)、branch(分支）和合并（merge)的功能，对于团队的开发进行支持。VSS不提供对流程的管理功能，如对变更的流程进行控制。</p></li><li><p>VSS不能提供对异地团队开发的支持。</p></li><li><p>VSS的安全性不高，对于VSS的用户，可以在文件夹上设置不可读，可读，可读/写,可完全控制四级权限</p></li></ul><p>2)Concurrent Version System(简称CVS）</p><ul><li><p>CVS是源于<strong>unix</strong>的版本控制工具。</p></li><li><p>跨平台。</p></li><li><p>同样因为CVS是开发源码软件，没有生产厂家为其提供技术的支持。如发现问题，通常只能靠自己查找网上的资料进行解决。</p></li></ul><p>3)SVN *</p><p>全名Subversion，即版本控制系统。</p><ul><li><strong>跨平台</strong>的软件，支持大多数常见的操作系统。</li><li>作为一个<strong>开源的版本控制系统</strong>,Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。</li></ul><p>4)Git *</p><ul><li>开源的<strong>分布式版本控制</strong>系统。</li><li>以有效、高速的处理从很小到非常大的项目版本管理。</li></ul><hr><h3 id="Git与SVN的区别"><a href="#Git与SVN的区别" class="headerlink" title="Git与SVN的区别"></a>Git与SVN的区别</h3><ol><li><p>Git 是分布式的，SVN 不是：</p><p>这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</p></li><li><p>Git 把内容按元数据方式存储，而 SVN 是按文件：</p><p>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.git 等的文件夹里。</p></li><li><p>Git 分支和 SVN 的分支不同：</p><p>Git 有本地分支，SVN 无本地分支。在实际开发过程中，经常会遇到有些代码没写完，但是需紧急处理其他问题，若我们使用 Git，便可以创建本地分支存储没写完的代码，待问题处理完后，再回到本地分支继续完成代码。</p></li><li><p>Git 没有一个全局的版本号，而 SVN 有：</p><p>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</p></li><li><p>Git 的内容完整性要优于 SVN：</p><p>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094716.jpg"></p><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>百度云链接：<a href="https://pan.baidu.com/s/1jysewPgEJV1W0-_X2nhYJw">https://pan.baidu.com/s/1jysewPgEJV1W0-_X2nhYJw</a><br>提取码：s1qb</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094717.png"  /><p>检验是否安装成功,桌面上鼠标右击后:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094718.png"></p><hr><h3 id="Git的工作区域"><a href="#Git的工作区域" class="headerlink" title="Git的工作区域"></a>Git的工作区域</h3><p>一共三个区域</p><ul><li>(1)工作区:用来对代码进行修改</li><li>(2)暂存区</li><li>(3)git仓库区</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094719.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 初始化仓库</span></span><br><span class="line"></span><br><span class="line">(1)新建文件夹，进入到该目录,右键打开<span class="code">`git bash`</span></span><br><span class="line"></span><br><span class="line">(2)在文件夹内初始化git(创建git仓库):(会生成一个.git的隐藏文件)</span><br><span class="line"> git init </span><br></pre></td></tr></table></figure><p>显示隐藏文件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094720.png"></p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 工作区---&gt;暂存区：</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 添加单个文件到暂存区</span></span><br><span class="line">git add 文件名 </span><br><span class="line"></span><br><span class="line"><span class="section"># 添加多个文件到暂存区</span></span><br><span class="line">git add <span class="emphasis">*</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094721.png"></p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 暂存区---&gt;仓库</span></span><br><span class="line">git commit -m &#x27;描述信息&#x27;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094722.png"></p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 删除文件</span></span><br><span class="line">git rm  文件名  </span><br><span class="line">git commit -m &#x27;提交描述&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 删除文件夹</span></span><br><span class="line">git rm -r 文件夹名</span><br><span class="line">git commit -m &#x27;提交描述&#x27;</span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code"># 当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制</span></span><br><span class="line"><span class="code">git rm -r --cached 文件夹名称</span></span><br><span class="line"><span class="code">git commit -m &#x27;提交描述&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Git远程服务器"><a href="#Git远程服务器" class="headerlink" title="Git远程服务器"></a>Git远程服务器</h3><h5 id="1-GitHub"><a href="#1-GitHub" class="headerlink" title="1) GitHub"></a>1) GitHub</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问地址:https:&#x2F;&#x2F;github.com&#x2F;</span><br></pre></td></tr></table></figure><h5 id="2-GitLab"><a href="#2-GitLab" class="headerlink" title="2) GitLab"></a>2) GitLab</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问地址:https:&#x2F;&#x2F;git.lug.ustc.edu.cn&#x2F;users&#x2F;sign_in</span><br></pre></td></tr></table></figure><p>GitHub 作为开源代码库，拥有超过 900 万的开发者用户，目前仍然是最火的开源项目托管平台，GitHub 同时提供公共仓库和私有仓库，但如果使用私有仓库，是需要付费的。<strong>GitLab 解决了这个问题，你可以在上面创建私人的免费仓库。</strong></p><h5 id="3-gitee-码云"><a href="#3-gitee-码云" class="headerlink" title="3)gitee(码云)"></a>3)gitee(码云)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问地址:https:&#x2F;&#x2F;gitee.com&#x2F;</span><br></pre></td></tr></table></figure><p>使用 GitHub 时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况。如果</p><p>你希望体验 Git 飞一般的速度，可以使用国内的代码托管与开发协作平台 —— Gitee。除了<strong>访问速度更</strong></p><p><strong>快</strong>以外，Gitee 还提供了<strong>免费的私有仓库</strong>供个人开发者使用</p><hr><h3 id="gitee使用"><a href="#gitee使用" class="headerlink" title="gitee使用"></a>gitee使用</h3><p>注册地址:<a href="https://gitee.com/">https://gitee.com/</a></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094723.png" style="zoom: 67%;" /><hr><h5 id="1、创建仓库"><a href="#1、创建仓库" class="headerlink" title="1、创建仓库"></a>1、创建仓库</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094724.png"></p><hr><p>仓库管理：</p><ul><li>新建文件</li><li>编辑/删除文件</li><li>被删除的文件如何查看信息:</li><li>上传文件(可以同时选择多文件)：</li><li>下载项目:</li><li>Gitee issue(问题)</li><li>删除仓库</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094725.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094726.png"></p><hr><h5 id="2、管理远程仓库"><a href="#2、管理远程仓库" class="headerlink" title="2、管理远程仓库"></a>2、管理远程仓库</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># git克隆操作：将远程仓库的项目复制到本地</span></span><br><span class="line"> git clone 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="section"># 举例： </span></span><br><span class="line">git clone https://gitee.com/zhao<span class="emphasis">_guojiang6/my_</span>pic<span class="emphasis">_bed.git</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 将本地仓库提交到远程（注意先提交到缓存区，再提交到仓库，最后提交远程）--&gt;即更新本地到仓库</span></span><br><span class="line"><span class="emphasis">git push</span></span><br></pre></td></tr></table></figure><p>第一次进行提交时，会设置登录的账户信息，即你的gitee账户</p><p>注意:该设置在gitee仓库主页显示谁提交的文件,如果想要修改用户信息，则将该命令再执行一次。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 设置用户名: </span></span><br><span class="line">git config --global user.name ‘用户名’</span><br><span class="line"><span class="section"># 设置用户名邮箱:</span></span><br><span class="line">git config --global user.email ‘邮箱’</span><br><span class="line"></span><br><span class="line"><span class="section"># 举例:</span></span><br><span class="line">git config --global user.name ‘赵国江’</span><br><span class="line">git config --global user.email ‘1143575690@qq.com’</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看设置: </span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>也可以在：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094727.png" style="zoom: 80%;" /><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 更新你的本地仓库至最新改动--&gt;更新仓库到本地</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 方式1：默认url</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="section"># 方式2:指定url</span></span><br><span class="line">git pull 仓库地址</span><br><span class="line"></span><br><span class="line"><span class="section"># 举例：</span></span><br><span class="line">git pull https://gitee.com/zhao<span class="emphasis">_guojiang6/my_</span>pic<span class="emphasis">_bed.git</span></span><br></pre></td></tr></table></figure><hr><h5 id="3-IDEA关联git"><a href="#3-IDEA关联git" class="headerlink" title="3)IDEA关联git"></a>3)IDEA关联git</h5><blockquote><p>Idea自身路径需要在英文目录</p></blockquote><h6 id="1、配置Git客户端"><a href="#1、配置Git客户端" class="headerlink" title="1、配置Git客户端"></a>1、配置Git客户端</h6><p>File — Settings—Version Control — Git关联Git安装目录下的<code>bin/git.exe</code>执行文件(这个就是git的客户端指令，类似svn.exe)</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094728.png" style="zoom:80%;" /><hr><h6 id="2、下载gitee插件"><a href="#2、下载gitee插件" class="headerlink" title="2、下载gitee插件"></a>2、下载gitee插件</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094729.jpg"></p><hr><h6 id="3、配置登录信息"><a href="#3、配置登录信息" class="headerlink" title="3、配置登录信息"></a>3、配置登录信息</h6><blockquote><p>登录时，使用邮箱登录</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094730.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094731.png"></p><hr><h6 id="4、本地项目上传到服务器"><a href="#4、本地项目上传到服务器" class="headerlink" title="4、本地项目上传到服务器"></a>4、本地项目上传到服务器</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094732.png"></p><hr><h6 id="5、服务器项目下载到本地"><a href="#5、服务器项目下载到本地" class="headerlink" title="5、服务器项目下载到本地"></a>5、服务器项目下载到本地</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094733.png"></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094734.png" style="zoom:80%;" /><hr><h6 id="6、本地项目更新到服务器与服务器更新到本地"><a href="#6、本地项目更新到服务器与服务器更新到本地" class="headerlink" title="6、本地项目更新到服务器与服务器更新到本地"></a>6、本地项目更新到服务器与服务器更新到本地</h6><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210217094735.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debug调试</title>
      <link href="2021/02/14/IDEA/12_Debug%E8%B0%83%E8%AF%95/"/>
      <url>2021/02/14/IDEA/12_Debug%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Debug调试"><a href="#Debug调试" class="headerlink" title="Debug调试"></a>Debug调试</h1><p><strong>调试步骤：</strong></p><h3 id="1、设置断点"><a href="#1、设置断点" class="headerlink" title="1、设置断点"></a>1、设置断点</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214130436.png"></p><hr><h3 id="2、选择Debug运行方式"><a href="#2、选择Debug运行方式" class="headerlink" title="2、选择Debug运行方式"></a>2、选择Debug运行方式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214130437.png"></p><hr><h3 id="3、选项键的说明"><a href="#3、选项键的说明" class="headerlink" title="3、选项键的说明"></a>3、选项键的说明</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214130438.png"></p><p><strong>依次说明：</strong></p><ul><li><p>Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。 </p></li><li><p>Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</p></li><li><p>Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法</p></li><li><p>Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</p></li><li><p>Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</p></li><li><p>Drop Frame (默认无)：回退断点</p></li><li><p>Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</p></li></ul><hr><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214130439.png"></p><p><strong>依次说明：</strong></p><ul><li><p>Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。</p></li><li><p>Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。</p></li><li><p>Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。</p></li><li><p>View Breakpoints (Ctrl + Shift + F8)：查看所有断点</p></li><li><p>Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="2021/02/14/IDEA/11_IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2021/02/14/IDEA/11_IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h1><ul><li><p>提示与代码生成部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + Enter  IDEA 根据光标所在问题，提供快速修复选择</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层(try，if等语句包裹)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + Insert 代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + O 选择可重写的方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + I 选择可实现的方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + &#x2F; 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</span><br></pre></td></tr></table></figure></li><li><p>选择/移动/复制代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + W 递进式选择代码块</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+Shift+w   递进式取消选择代码块</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+↑或↓ : 移动当前行或代码结构</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Y 删除光标所在行 或 删除选中的行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + X 剪切光标所在行 或 剪切选择内容</span><br></pre></td></tr></table></figure></li><li><p>代码优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用</span><br></pre></td></tr></table></figure></li><li><p>查找与替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + F 在当前文件进行文本查找</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + R 在当前文件进行文本替换</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</span><br></pre></td></tr></table></figure></li><li><p>阅读代码部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + F12 弹出当前文件结构层(类的方法属性等)，可以在弹出的层上直接输入，进行筛选</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Q 光标所在的变量 &#x2F; 类名 &#x2F; 方法名等上面（也可以在提示补充的时候按），显示文档内容</span><br></pre></td></tr></table></figure></li></ul><h2 id="快捷键大全"><a href="#快捷键大全" class="headerlink" title="快捷键大全"></a>快捷键大全</h2><h3 id="1、Ctrl相关"><a href="#1、Ctrl相关" class="headerlink" title="1、Ctrl相关"></a>1、Ctrl相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + F 在当前文件进行文本查找 （必备）</span><br><span class="line">Ctrl + R 在当前文件进行文本替换 （必备）</span><br><span class="line">Ctrl + Z 撤销 （必备）</span><br><span class="line">Ctrl + Y 删除光标所在行 或 删除选中的行 （必备）</span><br><span class="line">Ctrl + X 剪切光标所在行 或 剪切选择内容</span><br><span class="line">Ctrl + C 复制光标所在行 或 复制选择内容</span><br><span class="line">Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</span><br><span class="line">Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</span><br><span class="line">Ctrl + E 显示最近打开的文件记录列表</span><br><span class="line">Ctrl + N 根据输入的 类名 查找类文件</span><br><span class="line">Ctrl + G 在当前文件跳转到指定行处</span><br><span class="line">Ctrl + J 插入自定义动态代码模板</span><br><span class="line">Ctrl + P 方法参数提示显示</span><br><span class="line">Ctrl + Q 光标所在的变量 &#x2F; 类名 &#x2F; 方法名等上面（也可以在提示补充的时候按），显示文档内容</span><br><span class="line">Ctrl + U 前往当前光标所在的方法的父类的方法 &#x2F; 接口定义</span><br><span class="line">Ctrl + B 进入光标所在的方法&#x2F;变量的接口或是定义处，等效于 Ctrl + 左键单击</span><br><span class="line">Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用</span><br><span class="line">Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用</span><br><span class="line">Ctrl + H 显示当前类的层次结构</span><br><span class="line">Ctrl + O 选择可重写的方法</span><br><span class="line">Ctrl + I 选择可继承的方法</span><br><span class="line">Ctrl + + 展开代码</span><br><span class="line">Ctrl + - 折叠代码</span><br><span class="line">Ctrl + &#x2F; 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</span><br><span class="line">Ctrl + [ 移动光标到当前所在代码的花括号开始位置</span><br><span class="line">Ctrl + ] 移动光标到当前所在代码的花括号结束位置</span><br><span class="line">Ctrl + F1 在光标所在的错误代码处显示错误信息</span><br><span class="line">Ctrl + F3 调转到所选中的词的下一个引用位置</span><br><span class="line">Ctrl + F4 关闭当前编辑文件</span><br><span class="line">Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</span><br><span class="line">Ctrl + F9 执行 Make Project 操作</span><br><span class="line">Ctrl + F11 选中文件 &#x2F; 文件夹，使用助记符设定 &#x2F; 取消书签</span><br><span class="line">Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</span><br><span class="line">Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</span><br><span class="line">Ctrl + Enter 智能分隔行</span><br><span class="line">Ctrl + End 跳到文件尾</span><br><span class="line">Ctrl + Home 跳到文件头</span><br><span class="line">Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 ALT+&#x2F;（必备）</span><br><span class="line">Ctrl + Delete 删除光标后面的单词或是中文句</span><br><span class="line">Ctrl + BackSpace 删除光标前面的单词或是中文句</span><br><span class="line">Ctrl + 1,2,3...9 定位到对应数值的书签位置</span><br><span class="line">Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径</span><br><span class="line">Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要</span><br><span class="line">Ctrl + 左方向键 光标跳转到当前单词 &#x2F; 中文句的左侧开头位置</span><br><span class="line">Ctrl + 右方向键 光标跳转到当前单词 &#x2F; 中文句的右侧开头位置</span><br><span class="line">Ctrl + 前方向键 等效于鼠标滚轮向前效果</span><br><span class="line">Ctrl + 后方向键 等效于鼠标滚轮向后效果</span><br></pre></td></tr></table></figure><h3 id="2、Alt相关"><a href="#2、Alt相关" class="headerlink" title="2、Alt相关"></a>2、Alt相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Alt + &#96; 显示版本控制常用操作菜单弹出层</span><br><span class="line">Alt + Q 弹出一个提示，显示当前类的声明 &#x2F; 上下文信息</span><br><span class="line">Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</span><br><span class="line">Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层</span><br><span class="line">Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示</span><br><span class="line">Alt + F7 查找光标所在的方法 &#x2F; 变量 &#x2F; 类被调用的地方</span><br><span class="line">Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</span><br><span class="line">Alt + Home 定位 &#x2F; 显示到当前文件的 Navigation Bar</span><br><span class="line">Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</span><br><span class="line">Alt + Insert 代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等（必备）</span><br><span class="line">Alt + 左方向键 按左方向切换当前已打开的文件视图</span><br><span class="line">Alt + 右方向键 按右方向切换当前已打开的文件视图</span><br><span class="line">Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置</span><br><span class="line">Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置</span><br><span class="line">Alt + 1,2,3...9 显示对应数值的选项卡，其中 1 是 Project 用得最多</span><br></pre></td></tr></table></figure><h3 id="3、Shift相关"><a href="#3、Shift相关" class="headerlink" title="3、Shift相关"></a>3、Shift相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Shift + F1 如果有外部文档可以连接外部文档</span><br><span class="line">Shift + F2 跳转到上一个高亮错误 或 警告位置</span><br><span class="line">Shift + F3 在查找模式下，查找匹配上一个</span><br><span class="line">Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留</span><br><span class="line">Shift + F6 对文件 &#x2F; 文件夹 重命名</span><br><span class="line">Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</span><br><span class="line">Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</span><br><span class="line">Shift + F9 等效于点击工具栏的 Debug 按钮</span><br><span class="line">Shift + F10 等效于点击工具栏的 Run 按钮</span><br><span class="line">Shift + F11 弹出书签显示层</span><br><span class="line">Shift + Tab 取消缩进</span><br><span class="line">Shift + ESC 隐藏当前 或 最后一个激活的工具窗口</span><br><span class="line">Shift + End 选中光标到当前行尾位置</span><br><span class="line">Shift + Home 选中光标到当前行头位置</span><br><span class="line">Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置</span><br><span class="line">Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件</span><br><span class="line">Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动</span><br></pre></td></tr></table></figure><h3 id="4、Ctrl-Alt相关"><a href="#4、Ctrl-Alt相关" class="headerlink" title="4、Ctrl + Alt相关"></a>4、Ctrl + Alt相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备）</span><br><span class="line">Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备）</span><br><span class="line">Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</span><br><span class="line">Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层</span><br><span class="line">Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中</span><br><span class="line">Ctrl + Alt + H 调用层次</span><br><span class="line">Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</span><br><span class="line">Ctrl + Alt + V 快速引进变量</span><br><span class="line">Ctrl + Alt + Y 同步、刷新</span><br><span class="line">Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置</span><br><span class="line">Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</span><br><span class="line">Ctrl + Alt + F11 切换全屏模式</span><br><span class="line">Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行</span><br><span class="line">Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层</span><br><span class="line">Ctrl + Alt + Space 类名自动完成</span><br><span class="line">Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）</span><br><span class="line">Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）</span><br><span class="line">Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件</span><br><span class="line">Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件</span><br></pre></td></tr></table></figure><h3 id="5、Ctrl-Shift相关"><a href="#5、Ctrl-Shift相关" class="headerlink" title="5、Ctrl + Shift相关"></a>5、Ctrl + Shift相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备）</span><br><span class="line">Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</span><br><span class="line">Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备）</span><br><span class="line">Ctrl + Shift + Z 取消撤销 （必备）</span><br><span class="line">Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 </span><br><span class="line"></span><br><span class="line">（必备）</span><br><span class="line">Ctrl + Shift + N 通过文件名定位 &#x2F; 打开文件 &#x2F; 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</span><br><span class="line">Ctrl + Shift + U 对选中的代码进行大 &#x2F; 小写轮流转换 （必备）</span><br><span class="line">Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</span><br><span class="line">Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板</span><br><span class="line">Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层</span><br><span class="line">Ctrl + Shift + E 显示最近修改的文件列表的弹出层</span><br><span class="line">Ctrl + Shift + H 显示方法层次结构</span><br><span class="line">Ctrl + Shift + B 跳转到类型声明处</span><br><span class="line">Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义</span><br><span class="line">Ctrl + Shift + A 查找动作 &#x2F; 设置</span><br><span class="line">Ctrl + Shift + &#x2F; 代码块注释 （必备）</span><br><span class="line">Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置</span><br><span class="line">Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置</span><br><span class="line">Ctrl + Shift + + 展开所有代码</span><br><span class="line">Ctrl + Shift + - 折叠所有代码</span><br><span class="line">Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失</span><br><span class="line">Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件</span><br><span class="line">Ctrl + Shift + F9 编译选中的文件 &#x2F; 包 &#x2F; Module</span><br><span class="line">Ctrl + Shift + F12 编辑器最大化</span><br><span class="line">Ctrl + Shift + Space 智能代码提示</span><br><span class="line">Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备）</span><br><span class="line">Ctrl + Shift + Backspace 退回到上次修改的地方</span><br><span class="line">Ctrl + Shift + 1,2,3...9 快速添加指定数值的书签</span><br><span class="line">Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）</span><br><span class="line">Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 &#x2F; 中文句的左侧开头位置，同时选中该单词 &#x2F; 中文句</span><br><span class="line">Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 &#x2F; 中文句的右侧开头位置，同时选中该单词 &#x2F; 中文句</span><br><span class="line">Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域</span><br><span class="line">Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域</span><br><span class="line">Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</span><br><span class="line">Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</span><br></pre></td></tr></table></figure><h3 id="6、Alt-Shift相关"><a href="#6、Alt-Shift相关" class="headerlink" title="6、Alt + Shift相关"></a>6、Alt + Shift相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Alt + Shift + N 选择 &#x2F; 添加 task</span><br><span class="line">Alt + Shift + F 显示添加到收藏夹弹出层 &#x2F; 添加到收藏夹</span><br><span class="line">Alt + Shift + C 查看最近操作项目的变化情况列表</span><br><span class="line">Alt + Shift + I 查看项目当前文件</span><br><span class="line">Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环</span><br><span class="line"></span><br><span class="line">进入</span><br><span class="line">Alt + Shift + F9 弹出 Debug 的可选择菜单</span><br><span class="line">Alt + Shift + F10 弹出 Run 的可选择菜单</span><br><span class="line">Alt + Shift + 左键双击 选择被双击的单词 &#x2F; 中文句，按住不放，可以同时选择其他单词 &#x2F; 中文句</span><br><span class="line">Alt + Shift + 前方向键 移动光标所在行向上移动</span><br><span class="line">Alt + Shift + 后方向键 移动光标所在行向下移动</span><br></pre></td></tr></table></figure><h3 id="7、其他"><a href="#7、其他" class="headerlink" title="7、其他"></a>7、其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">F2 跳转到下一个高亮错误 或 警告位置 （必备）</span><br><span class="line">F3 在查找模式下，定位到下一个匹配处</span><br><span class="line">F4 编辑源</span><br><span class="line">F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该</span><br><span class="line"></span><br><span class="line">内嵌的方法中</span><br><span class="line">F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</span><br><span class="line">F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</span><br><span class="line">F11 添加书签</span><br><span class="line">F12 回到前一个工具窗口</span><br><span class="line">Tab 缩进</span><br><span class="line">ESC 从工具窗口进入代码文件窗口</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + Alt + V 无格式黏贴</span><br><span class="line">Ctrl + Shift + Alt + N 前往指定的变量 &#x2F; 方法</span><br><span class="line">Ctrl + Shift + Alt + S 打开当前项目设置</span><br><span class="line">Ctrl + Shift + Alt + C 复制参考信息</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 2019.3.4完美破解(亲测有效)</title>
      <link href="2021/02/14/IDEA/10_IDEA-2019-3-4%E5%AE%8C%E7%BE%8E%E7%A0%B4%E8%A7%A3-%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88/"/>
      <url>2021/02/14/IDEA/10_IDEA-2019-3-4%E5%AE%8C%E7%BE%8E%E7%A0%B4%E8%A7%A3-%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA-2019-3-4完美破解-亲测有效"><a href="#IDEA-2019-3-4完美破解-亲测有效" class="headerlink" title="IDEA 2019.3.4完美破解(亲测有效)"></a>IDEA 2019.3.4完美破解(亲测有效)</h1><blockquote><p>本项目只做学习研究之用，不得用于商业用途！</p><p>若资金允许，请点击 [<a href="https://www.jetbrains.com/idea/buy/]">https://www.jetbrains.com/idea/buy/]</a> 购买正版！！！</p></blockquote><hr><p><a href="https://www.jetbrains.com/">IDEA官网</a></p><p>所需要的插件：<font color='orange'>jetbrains-agent.jar</font></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 百度网盘</span></span><br><span class="line">链接：https://pan.baidu.com/s/1RHase0KlvJF-afS<span class="emphasis">_mPDTaw </span></span><br><span class="line"><span class="emphasis">提取码：rbjv </span></span><br></pre></td></tr></table></figure><hr><p>安装步骤：</p><p>首先，安装idea，然后使用免费30天进入，随便创建一个项目，进入主界面。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214120955.png"  /><hr><p>其次，把jetbrains-agent.jar 包拖进idea主界面，选择重启。restart now</p><p>再次，重启完，选择激活方式为 activation_code 方式，会在重启一次。</p><p>最后，idea主界面，选择Help - About,查看激活时间。我的激活时间为70年</p><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA单元测试</title>
      <link href="2021/02/14/IDEA/9_IDEA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>2021/02/14/IDEA/9_IDEA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA单元测试"><a href="#IDEA单元测试" class="headerlink" title="IDEA单元测试"></a>IDEA单元测试</h1><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="下载jar文件"><a href="#下载jar文件" class="headerlink" title="下载jar文件"></a>下载jar文件</h3><p>链接：<a href="https://pan.baidu.com/s/1ZZ7LB1TZK8qQM-hcPwYuaw">https://pan.baidu.com/s/1ZZ7LB1TZK8qQM-hcPwYuaw</a><br>提取码：uv62</p><h3 id="新建lib文件夹"><a href="#新建lib文件夹" class="headerlink" title="新建lib文件夹"></a>新建lib文件夹</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115847.png"></p><h3 id="将jar文件粘贴到lib文件夹中"><a href="#将jar文件粘贴到lib文件夹中" class="headerlink" title="将jar文件粘贴到lib文件夹中"></a>将jar文件粘贴到lib文件夹中</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115848.png"></p><h3 id="引入Jar文件"><a href="#引入Jar文件" class="headerlink" title="引入Jar文件"></a>引入Jar文件</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115849.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115850.png"></p><h3 id="新建test文件夹"><a href="#新建test文件夹" class="headerlink" title="新建test文件夹"></a>新建test文件夹</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115851.png"></p><h3 id="将test文件夹设置为测试文件夹"><a href="#将test文件夹设置为测试文件夹" class="headerlink" title="将test文件夹设置为测试文件夹"></a>将test文件夹设置为测试文件夹</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115852.png"></p><h3 id="在任意要测试的类里按下shift-ctrl-t-生成测试类"><a href="#在任意要测试的类里按下shift-ctrl-t-生成测试类" class="headerlink" title="在任意要测试的类里按下shift+ctrl+t 生成测试类"></a>在任意要测试的类里按下shift+ctrl+t 生成测试类</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115853.png"></p><p>此时可能出现使用<code>shift + ctrl + t</code>弹出 <code>Class类查找</code></p><p>解决方法：手动设置自动创建测试类的快捷键即可</p><p><strong>点击 file-&gt; setting -&gt; keymap 搜索：test</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115854.png"></p><p>鼠标右键：add keyBoard Shortcut 设置你想要的快捷键  Apply -&gt;OK即可</p><hr><h4 id="选择Create-new-Test…"><a href="#选择Create-new-Test…" class="headerlink" title="选择Create new Test…"></a>选择Create new Test…</h4><p>选择要测试的方法和版本:</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115855.png"></p><h4 id="选择已创建过的测试类"><a href="#选择已创建过的测试类" class="headerlink" title="选择已创建过的测试类"></a>选择已创建过的测试类</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115856.png"></p><h4 id="测试类创建完毕-编写测试代码"><a href="#测试类创建完毕-编写测试代码" class="headerlink" title="测试类创建完毕, 编写测试代码"></a>测试类创建完毕, 编写测试代码</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115857.png"></p><h4 id="执行测试观察效果"><a href="#执行测试观察效果" class="headerlink" title="执行测试观察效果"></a>执行测试观察效果</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115858.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 类注释+方法注释的快捷设置</title>
      <link href="2021/02/14/IDEA/8_IDEA-%E7%B1%BB%E6%B3%A8%E9%87%8A-%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%AE%BE%E7%BD%AE/"/>
      <url>2021/02/14/IDEA/8_IDEA-%E7%B1%BB%E6%B3%A8%E9%87%8A-%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA：类注释-方法注释的快捷设置"><a href="#IDEA：类注释-方法注释的快捷设置" class="headerlink" title="IDEA：类注释/方法注释的快捷设置"></a>IDEA：类注释/方法注释的快捷设置</h1><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><h3 id="修改类头的文档注释信息"><a href="#修改类头的文档注释信息" class="headerlink" title="修改类头的文档注释信息"></a>修改类头的文档注释信息</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115421.png"></p><p>模板内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">@Author: xj0927</span><br><span class="line">@Description: </span><br><span class="line">@Date Created in $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125; </span><br><span class="line">@Modified By: </span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>直接在右边的文件框里编辑你说需要注释的东西，然后应用保存之后,<strong>当你创建类的时候就会自动生成注释。</strong> </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115422.png"></p><hr><h2 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h2><h3 id="要求效果："><a href="#要求效果：" class="headerlink" title="要求效果："></a>要求效果：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115423.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">* @Description: 添加你要描述的内容~~</span><br><span class="line">* @Param: [a,b,c,d]</span><br><span class="line">* @Return: </span><br><span class="line">* @Author: xj0927</span><br><span class="line">* @Date Created in 2020&#x2F;08&#x2F;19 11:37</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><h3 id="具体实现步骤："><a href="#具体实现步骤：" class="headerlink" title="具体实现步骤："></a>具体实现步骤：</h3><p>1、打开系统设置Setting（Ctrl+Alt+S快捷键）</p><p>2、Editor—&gt;Live Templates—&gt;点击+号。添加一个templates group来放置自己快捷键，效果图如下：</p><p>3、选中创建的MyGroup—&gt;再次点击+号，添加一个Live template</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115424.png"></p><p>4.还是在fifile-&gt;setting-&gt;Editor-&gt;LiveTemplates这个路径下点击一下刚刚你添加的那个名字MyGroup，然后点击右边 上面那个+号，选择LiveTemplate，填写下面设置自定义的快捷键模板：</p><blockquote><p> Abbreviation：快捷键，</p><p> Description：描述该快捷键</p><p> Template text：自定义的快捷键模板</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">* <span class="meta">@Description</span>: $description$ </span><br><span class="line">* <span class="meta">@Param</span>: $params$ </span><br><span class="line">* <span class="meta">@Return</span>: $<span class="keyword">return</span>$</span><br><span class="line">* <span class="meta">@Author</span>: xj0927</span><br><span class="line">* <span class="meta">@Date</span> Created in $data$ $time$</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115425.png"></p><p>5.设置注释的关联变量：先设置好Template text内容后—&gt;Edit variables，变量如效果图设置就好。效果图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115426.png"></p><p>注意：注意：注意：设置完应用一下Apply</p><p>应用的时候直接在方法前边写：/+快捷键名+Enter键。即可，比如我设置的快捷键方法名是a，效果图便是：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214115427.png"></p><div class="note success simple"><p>设置完成</p></div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给 IDEA 换个养眼的主题</title>
      <link href="2021/02/14/IDEA/7_%E7%BB%99-IDEA-%E6%8D%A2%E4%B8%AA%E5%85%BB%E7%9C%BC%E7%9A%84%E4%B8%BB%E9%A2%98/"/>
      <url>2021/02/14/IDEA/7_%E7%BB%99-IDEA-%E6%8D%A2%E4%B8%AA%E5%85%BB%E7%9C%BC%E7%9A%84%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="以下推荐几款个人喜欢的-两款主题"><a href="#以下推荐几款个人喜欢的-两款主题" class="headerlink" title="以下推荐几款个人喜欢的 两款主题"></a>以下推荐几款个人喜欢的 两款主题</h3><h4 id="第一款：Xcode-Dark-Theme"><a href="#第一款：Xcode-Dark-Theme" class="headerlink" title="第一款：Xcode-Dark Theme"></a>第一款：Xcode-Dark Theme</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114858.png"></p><h4 id="第二款：One-Dark-theme"><a href="#第二款：One-Dark-theme" class="headerlink" title="第二款：One Dark theme"></a>第二款：One Dark theme</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114859.png"></p><hr><h3 id="如何下载主题"><a href="#如何下载主题" class="headerlink" title="如何下载主题"></a>如何下载主题</h3><p>在 IDEA 中下载：搜索这 2 个插件下载即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114900.png"></p><hr><h3 id="如何更换主题"><a href="#如何更换主题" class="headerlink" title="如何更换主题"></a>如何更换主题</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114901.png"></p><p>Apply 即可！！！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora + PicGo + Gitee实现图片上传</title>
      <link href="2021/02/14/Hexo%E5%8D%9A%E5%AE%A2/6_Typora-PicGo-Gitee%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
      <url>2021/02/14/Hexo%E5%8D%9A%E5%AE%A2/6_Typora-PicGo-Gitee%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora-PicGo-Gitee实现图片上传"><a href="#Typora-PicGo-Gitee实现图片上传" class="headerlink" title="Typora + PicGo + Gitee实现图片上传"></a>Typora + PicGo + Gitee实现图片上传</h1><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><h3 id="下载typora"><a href="#下载typora" class="headerlink" title="下载typora"></a>下载typora</h3><blockquote><p>此软件用于撰写markdown文档，新版本支持图片粘贴图片功能</p></blockquote><p><a href="https://www.typora.io/#windows">官网下载</a></p><h3 id="下载图床工具picgo"><a href="#下载图床工具picgo" class="headerlink" title="下载图床工具picgo"></a>下载图床工具picgo</h3><blockquote><p>所谓图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 Electron-vue 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用</p></blockquote><p><a href="https://github.com/Molunerfinn/PicGo/releases">github下载地址</a><br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114644.png" alt="image-20210214111008639"></p><hr><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="在gitee上创建仓库（公开的！）"><a href="#在gitee上创建仓库（公开的！）" class="headerlink" title="在gitee上创建仓库（公开的！）"></a>在gitee上创建仓库（公开的！）</h3><blockquote><p>没有账号可以申请一个</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114645.png" alt="image-20210214111212552"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114646.png" alt="image-20210214112956581"></p><blockquote><p>去设置里面找到私人令牌添加一个新的</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114647.png" alt="image-20210214113141098"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114648.png" alt="image-20210214113153874"></p><hr><h3 id="配置picgo图床工具"><a href="#配置picgo图床工具" class="headerlink" title="配置picgo图床工具"></a>配置picgo图床工具</h3><p>下载<code>gitee-uploader</code>插件，这里需要你电脑有<code>node环境</code>（具体安装可以百度，比较简单）<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114649.png" alt="image-20210214113409680"></p><p>下载完插件后<code>图床设置</code>里面多个gitee，然后进行设置：<code>owner</code>：用户名，<code>repo仓库</code>：仓库名 ,<code>token私人令牌</code> ：你刚设置的令牌 ，然后点击确定</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114650.png" alt="image-20210214113526607"></p><hr><h3 id="配置typora"><a href="#配置typora" class="headerlink" title="配置typora"></a>配置typora</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114651.png" alt="image-20210214113701562"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114652.png" alt="image-20210214113713876"></p><blockquote><p>你也可以验证一下是否成功</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114653.png" alt="image-20210214113726898"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114654.png" alt="image-20210214113738895"></p><blockquote><p>回到你gitee仓库，这时候已经多了两个图片，说明已经图床已经搭建完毕</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114655.png" alt="image-20210214113903651"></p><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>1、随便截一张图，粘贴到typora：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114656.png"></p><hr><p>2、一键上传所有图片<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114657.png" alt="image-20210214114218080"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/zhao_guojiang6/my_pic_bed/raw/master/img/20210214114658.png" alt="image-20210214114315519"></p><hr><p>当你需要的时候，就可以在任何地方引入该链接，使用图片！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo终极部署Github + Vercel</title>
      <link href="2021/02/11/Hexo%E5%8D%9A%E5%AE%A2/5_Hexo%E7%BB%88%E6%9E%81%E9%83%A8%E7%BD%B2Github-Vercel/"/>
      <url>2021/02/11/Hexo%E5%8D%9A%E5%AE%A2/5_Hexo%E7%BB%88%E6%9E%81%E9%83%A8%E7%BD%B2Github-Vercel/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo终极部署：Github-Vercel"><a href="#Hexo终极部署：Github-Vercel" class="headerlink" title="Hexo终极部署：Github + Vercel"></a>Hexo终极部署：Github + Vercel</h1><h2 id="各大服务器特点"><a href="#各大服务器特点" class="headerlink" title="各大服务器特点"></a>各大服务器特点</h2><p>近些日子，静态网站的热度又渐渐高了起来。相比于动态网站，静态网站具有轻量、无需服务器、利于 SEO、速度快等特点，非常适合个人博客。再加上 Hexo、Hugo 等静态博客渲染框架的日渐成熟，已能与 Wordpress、Typecho 等老牌动态博客框架分庭抗礼。 </p><p>与此同时，很多静态托管网站也应运而生。各种托管网站看似鱼龙混杂，其实由于各种原因，在国内能用的也就那么几家；如果你像我一样，没有服务器、没有备案，还想白嫖（），那么仅有的选择就更少了。综合各种因素，目前最适合托管静态博客的服务有：</p><p><strong>GitHub Pages</strong> </p><p>微软旗下，闻名遐迩的全球第一大开源仓库网站。服务器设在荷兰、美国等地。部分地区部分运营商的用户可能遭到<code> DNS 污染</code>，无法正常访问。</p><p><strong>Gitee Pages</strong> </p><p>OSCHINA 旗下，服务器在上海腾讯云，速度较快，较稳定，提供 <code>xxx.gitee.io </code>域名，不支持免费自定义域名。</p><p><strong>旧 Coding Pages</strong> </p><p>腾讯旗下，服务器在香港 / 新加坡腾讯云，速度较快，但稳定性差。部分地区速度极慢或不能访问。支持免费自定义域名。</p><p><strong>新 Coding Pages</strong></p><p>与腾讯云绑定食用，功能较齐全，但按量计费。</p><hr><h2 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h2><p>原名 Zeit，服务器在美国，在港台有 CDN 节点。速度略慢于 Coding，但大部分地区均可正常访问。</p><p><code>提供自定义 xxx.now.sh 和 xxx.vercel.app 域名，且支持免费绑定个人域名。</code></p><p>大部分网站采用的一般都是 GitHub + Coding 双部署的形式。这种方法比较麻烦，需要 DNSPod 解析，因此需要实名认证，而且还真未必快到那里去。</p><p>Colsrch 大佬出过一篇三部署教程，使用了 Coding（联通线路），Vercel（默认线路），Cloudflare 回源 GitHub Page（移动线路），速度略有提升，但是门槛较高，对小白并不友好。而且近期 Coding 似乎越来越不稳定了，所以也不太推荐此方法。 </p><p>和 99 块钱相比，慢点就慢点吧（  还是由于某种原因，市面上的 Vercel 部署教程并不多。而且由于 Vercel 里的一些操作还是挺不常规的，所以就写了这么一篇文章，说一下将网站部署在 Vercel 的详细过程。）</p><hr><h3 id="导入-GitHub-仓库"><a href="#导入-GitHub-仓库" class="headerlink" title="导入 GitHub 仓库"></a>导入 GitHub 仓库</h3><p>Vercel 是一个静态网页部署网站，并不托管代码。因此，我们通过 GitHub 来托管 hexo deploy 生成的网页文件，并设置自动导入。当你的源代码仓库有变动后，Vercel 会第一时间检测到并重新部署网站，部署完成后会通过邮件提醒。</p><blockquote><p>在开始之前，请准备一个 GitHub 账号（注意不能是绑有 QQ 邮箱的）、一个 Git 仓库（存储 Hexo 生成的页面）。</p></blockquote><p>进入  <a href="https://vercel.com/signup">Vercel 官网</a>，点击 <code>Continue with GitHub</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax2.sinaimg.cn/large/007rpHi4gy1gnio31f65aj30u90famzb.jpg"></p><p>出现授权页面，点击<code>Authorize Vercel</code>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax1.sinaimg.cn/large/007rpHi4gy1gnio31re80j30m30tvq46.jpg"></p><p>填写你要导入的Github仓库地址：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnio31krrgj30ly0co0t7.jpg"></p><p>选择个人使用：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax1.sinaimg.cn/large/007rpHi4gy1gnio328zq8j30ys0n8q40.jpg"></p><p>选择Github：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax1.sinaimg.cn/large/007rpHi4gy1gnio3223obj30ys0n8my8.jpg"></p><p>导入项目中会弹出一些自定义选项，不知道会出什么锅的话就不要改，顺着一直点，遵照默认选项就可以了。</p><p>完成后，便可以访问我们的博客了，以我的为例：<a href="https://xj-0927-git-github-io.vercel.app/">https://xj-0927-git-github-io.vercel.app/</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnio32imtij30xi0oo426.jpg"></p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>进入 dashboard，点击 [项目卡片] -&gt; View Domains</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnio32imtij30xi0oo426.jpg"></p><p>如果你想使用 Vercel 提供的二级域名，直接添加 <code>xxx.now.sh </code>（或<code> xxx.vercel.app</code> ，看你想要哪个），如果无人占用，会自动验证成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax2.sinaimg.cn/large/007rpHi4gy1gnio30d9l0j30xk0ewgmt.jpg"></p><hr><p>如果你想绑定自己的域名，也是在输入框中输入你想要绑定的网址，点击右侧 Add 即可。下方会提示 Invalid Config，并给出绑定方式，请按照下面的方式：</p><p>验证方式 ：</p><ul><li>如果是根域名，请在你的 DNS 解析处添加 A 记录，指向 <code>76.76.21.21</code></li><li>如果是子域名，请在你的 DNS 解析处添加 CNAME 记录，指向 <code>cname.vercel-dns.com</code></li></ul><p>以我的为例：(阿里云购买的域名)</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax1.sinaimg.cn/large/007rpHi4gy1gnio30ja8fj30lh0h3q36.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax3.sinaimg.cn/large/007rpHi4gy1gnio30q28jj30lo0ioglv.jpg"></p><p><img src= "/img/loading.gif" data-lazy-src="https://tva4.sinaimg.cn/large/007rpHi4gy1gnio30zh6zj30vm0bq756.jpg"></p><p>添加记录后等待片刻再刷新，下面显示两个对号即表明验证成功：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva2.sinaimg.cn/large/007rpHi4gy1gnio315p5lj30ks0b0aam.jpg"></p><p>完成后，便可以使用你的域名进行访问了！！！</p><hr><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向 ：如果你绑定了多个域名，可以点击域名卡片右上角的 Edit，将某个域名重定向至你的其他域名。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 部署到Gitee 码云</title>
      <link href="2020/01/02/Hexo%E5%8D%9A%E5%AE%A2/3_%E9%83%A8%E7%BD%B2%E5%88%B0Gitee/"/>
      <url>2020/01/02/Hexo%E5%8D%9A%E5%AE%A2/3_%E9%83%A8%E7%BD%B2%E5%88%B0Gitee/</url>
      
        <content type="html"><![CDATA[<h1 id="部署到Gitee"><a href="#部署到Gitee" class="headerlink" title="部署到Gitee"></a>部署到Gitee</h1><div class="note info simple"><p>本次记录的是将Hexo博客部署在码云上面，其<a href="https://gitee.com/education">官方网站</a>，相比于部署到Github上，其访问速度更快，但是后面我发现Gitee现在不能进行自定义域名了，如果你想要自定义域名的话，需要去进行购买。但是如果你不需要自定义域名的话，该方案还是比较可行。</p></div><h2 id="配置码云"><a href="#配置码云" class="headerlink" title="配置码云"></a>配置码云</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>先去<a href="https://gitee.com/">登陆</a>或注册码云，然后创建仓库，路径一定要跟你的用户名一样，这样就可以使用<code>https://用户名.gitee.io/</code>来访问你的博客首页。</p><p>用户名在这里看着先：</p><p><a href="https://caiyantao.gitee.io/2019/04/14/Hexo-%E4%B8%89/df2393c58959860e67ba135a46c0538.png"><img src= "/img/loading.gif" data-lazy-src="https://tvax2.sinaimg.cn/large/007rpHi4gy1gnim3913qgj30xr0izq4w.jpg" alt="df2393c58959860e67ba135a46c0538"></a><br>首先还是得新建一个仓库：填入个人消息</p><p><a href="https://caiyantao.gitee.io/2019/04/14/Hexo-%E4%B8%89/3b8bc27bd4c3b52deaf324d31672feb.png"><img src= "/img/loading.gif" data-lazy-src="https://tva3.sinaimg.cn/large/007rpHi4gy1gnim385elzj311y0k9q4w.jpg" alt="3b8bc27bd4c3b52deaf324d31672feb"></a></p><p>需要<strong>注意</strong>的是<code>路径</code>这个地方可不是想写啥就写啥，一定要写成你的<code>用户名</code></p><p>要写自己的用户名，要写自己的用户名，要写自己的用户名，！！！</p><hr><h3 id="部署密钥"><a href="#部署密钥" class="headerlink" title="部署密钥"></a>部署密钥</h3><h4 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h4><p>配置码云的SSH公钥，首先本地git生成公钥（码云中配置SSH公钥画面有介绍怎么<a href="https://gitee.com/help/articles/4181#article-header0">生成公钥</a>）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnim0cngqfj30xe0go0uh.jpg" alt="img"></p><h4 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h4><p>然后在码云中配置生成的SSH公钥。生成后查看代码将其复制到上面图中的公钥处</p><p>这样的话，<code>Hexo d</code>上传博客到服务器就会自动认证。</p><h3 id="修改Hexo配置文件"><a href="#修改Hexo配置文件" class="headerlink" title="修改Hexo配置文件"></a>修改Hexo配置文件</h3><p>然后写上自己仓库链接，具体看链接如下图：</p><p><a href=""><img src= "/img/loading.gif" data-lazy-src="https://tva2.sinaimg.cn/large/007rpHi4gy1gnim38gyh3j30zz0i2mzt.jpg" alt="73aaa7dc9f71685e0fb6251f2bae520"></a><br>修改hexo的配置文件<code>_config.yml</code>，填上仓库地址。比如我的代码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意名字和值之间要空一格</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@gitee.com:zhao_guojiang6&#x2F;zhao_guojiang6.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><a href="https://wudong-tech.oss-cn-beijing.aliyuncs.com/Hexo%E5%92%8C%E7%A0%81%E4%BA%91%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/hexo%E9%85%8D%E7%BD%AE%E7%A0%81%E4%BA%91.png"><img src= "/img/loading.gif" data-lazy-src="https://tva3.sinaimg.cn/large/007rpHi4gy1gnim4d08tuj30qs0cqwfm.jpg" alt="img"></a></p><p>然后进行命令三连杀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean&amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><hr><h3 id="我们点Page服务"><a href="#我们点Page服务" class="headerlink" title="我们点Page服务"></a>我们点Page服务</h3><p>点击生成，可以看到我们的域名啦：</p><p><a href="https://caiyantao.gitee.io/2019/04/14/Hexo-%E4%B8%89/928f341ba6e91116ecd2ebb2cbd0540.png"><img src= "/img/loading.gif" data-lazy-src="https://tva4.sinaimg.cn/large/007rpHi4gy1gnim16suvtj30jl05gjrs.jpg" alt="928f341ba6e91116ecd2ebb2cbd0540"></a></p><p>然后结果就是：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva3.sinaimg.cn/large/007rpHi4gy1gnim38tnx0j30zn0nr0w4.jpg"></p><p>访问<a href="https://zhao_guojiang6.gitee.io/">https://zhao_guojiang6.gitee.io</a>即可！</p><p>至此，Hexo部署到Gitee就完成了！</p><p>别的小伙伴拿到地址便可以访问你的博客了！</p><hr><div class="note default simple"><p>参考博客：<a href="https://caiyantao.gitee.io/">Hexo部署到码云</a></p></div><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署到Github</title>
      <link href="2020/01/02/Hexo%E5%8D%9A%E5%AE%A2/4_Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/"/>
      <url>2020/01/02/Hexo%E5%8D%9A%E5%AE%A2/4_Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Github/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo部署到Github"><a href="#Hexo部署到Github" class="headerlink" title="Hexo部署到Github"></a>Hexo部署到Github</h1><h3 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h3><h4 id="生成github-io仓库"><a href="#生成github-io仓库" class="headerlink" title="生成github.io仓库"></a>生成github.io仓库</h4><p>首先注册并登录<a href="https://github.com/">GitHub</a>，创建新public仓库，仓库名称<strong>一定要是</strong>：<br><code>YourGitHubName.github.io</code>（YourGitHubName是<strong>你的</strong>GitHub昵称，<strong>大小写敏感！</strong>）</p><p><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gninicam0rj30wz0ffdh2.jpg"></p><h4 id="安装git部署插件"><a href="#安装git部署插件" class="headerlink" title="安装git部署插件"></a>安装git部署插件</h4><p>在Hexo的目录下，输入<code>npm install --save hexo-deployer-git</code>，会报一个peerDependencies WARNING，可以忽略。</p><h4 id="修改Hexo配置文件"><a href="#修改Hexo配置文件" class="headerlink" title="修改Hexo配置文件"></a>修改Hexo配置文件</h4><p>在Hexo目录下，找到<code>_config.yml</code>文件，添加Github仓库地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:XJ0927Git&#x2F;XJ0927Git.github.io.git       #你的github.io的网址</span><br><span class="line">  branch: master                                                           </span><br></pre></td></tr></table></figure><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp; hexo g &amp; hexo d</span><br></pre></td></tr></table></figure><p>部署成功后，浏览器输入<code>YourGitHubName.github.io</code>即可访问，其中YourGitHubName是<strong>你的</strong>GitHub昵称，且<strong>大小写敏感</strong></p><p>以我的为例：<a href="https://xj0927git.github.io/">https://xj0927git.github.io/</a></p><h4 id="写文章-amp-发布"><a href="#写文章-amp-发布" class="headerlink" title="写文章 &amp; 发布"></a>写文章 &amp; 发布</h4><p>和本地一致，都是<code>hexo new &quot;yourArticle&quot;</code>后，发布到本地就用<code>hexo clean &amp; hexo g &amp; hexo s</code></p><p>，部署到服务器就用<code>hexo clean &amp; hexo g &amp; hexo d </code>，不再赘述。</p><hr><div class="note default simple"><p>参考视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty">CodeSheep🐏</a></p><p>参考文章：<a href="http://www.dragonbaby308.com/hexo/">Hexo博客部署到Github</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 本地部署</title>
      <link href="2020/01/01/Hexo%E5%8D%9A%E5%AE%A2/2-Hexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/"/>
      <url>2020/01/01/Hexo%E5%8D%9A%E5%AE%A2/2-Hexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo本地部署"><a href="#Hexo本地部署" class="headerlink" title="Hexo本地部署"></a>Hexo本地部署</h1><p>首先需要说明的是：我本地使用的是Win10（64位）操作系统。</p><p>更权威的安装过程可以参照<a href="https://hexo.io/zh-cn/">Hexo官方主页</a>。</p><h2 id="部署安装环境"><a href="#部署安装环境" class="headerlink" title="部署安装环境"></a>部署安装环境</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>去<a href="https://nodejs.org/en/">Node.js官网</a>下载Windows (x64)长期支持版 Long Term Support (LTS) schedule。</p><p>按提示逐步安装即可，安装完成后打开cmd查看版本号验证是否安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\tangcl&gt; node -v</span><br><span class="line">v12.13.1</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>Node.js中自带了npm包管理工具，在cmd中查看npm版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\tangcl&gt; npm -v</span><br><span class="line">6.12.1</span><br><span class="line">12</span><br></pre></td></tr></table></figure><hr><div class="note info simple"><p>由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过npm安装cnpm：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装成功后，可以通过以下命令查看cnpm版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>如果提示cnpm没找到，那就是你没有配置环境变量（比较简单，把错误提示复制到百度有解决方案）</p><p>通过cnpm来操作下载速度会得到很大提升。</p></div><hr><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>git是一个版本控制工具，国外镜像下载巨慢，建议前往<a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a>下载 git 安装包。</p><p>按提示逐步安装即可（<a href="https://blog.csdn.net/XJ0927/article/details/113374829">Git安装</a>），安装完成后右键菜单中出现Git Bash和Git GUI菜单表明安装成功，如下图所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva1.sinaimg.cn/large/007rpHi4gy1gnhjshrz26j307i0b1dfw.jpg" alt="1"></p><p>注：git和github是两个东西。github是基于git二次开发的，git是github的核心，git负责与github相关的所有本地工作。</p><hr><h2 id="开始安装Hexo"><a href="#开始安装Hexo" class="headerlink" title="开始安装Hexo"></a>开始安装Hexo</h2><h4 id="安装Hexo框架"><a href="#安装Hexo框架" class="headerlink" title="安装Hexo框架"></a>安装Hexo框架</h4><p>右键打开Git Bash，使用 cnpm 安装 Hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://tvax4.sinaimg.cn/large/007rpHi4gy1gnhjv22x15j313c04142a.jpg" alt="image"></p><p>查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><hr><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>Hexo安装完成后，新建myblogs项目，Hexo的所有文章都是以文件的形式存储在目录下的，所以首先需要新建一个目录</p><div class="note success simple"><p>这个目录存放的东西就是你以后操作博客的东西</p></div><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><p>对其进行初始化：（<font color='red'>这个命令只用一次，后面不会再用到了</font>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myblogs</span><br><span class="line">hexo init </span><br></pre></td></tr></table></figure><p>此时，会在myblogs文件夹下生成相应的项目文件</p><p>如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva1.sinaimg.cn/large/007rpHi4gy1gnhjzvn0o0j30qt08tq76.jpg" alt="image"></p><hr><p>这里我们经常用到的有三个命令：（<code>请记住！</code>）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean # 用来清理缓存文件</span><br><span class="line">hexo g      #生成文件</span><br><span class="line">hexo  s     #运行本地服务器</span><br><span class="line">hexo  d   # 上传到服务器</span><br></pre></td></tr></table></figure><hr><p>在myblogs文件夹下启动hexo服务：（s代表server，默认端口号是<strong>4000</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时在本地打开浏览器，通过 <a href="http://localhost:4000/">http://localhost:4000/</a> 便可访问基于Hexo的个人博客主页了</p><p>如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva2.sinaimg.cn/large/007rpHi4gy1gnhk173egvj316y0nlgzm.jpg" alt="image"></p><p>说明本地环境搭建完成！</p><p>下面我们发布一篇博客进行测试</p><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>在博客主目录下，Git Bash here</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># FirstPost是你的文章名称</span></span><br><span class="line">hexo new FirstPost</span><br></pre></td></tr></table></figure><p>会在<code>source/_posts</code>目录下生成 FirstPost.md文件：这个文件就是你本篇博客，可以使用Markdown编辑器进行修改</p><h4 id="生成博客静态文件"><a href="#生成博客静态文件" class="headerlink" title="生成博客静态文件"></a>生成博客静态文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h4 id="启动博客"><a href="#启动博客" class="headerlink" title="启动博客"></a>启动博客</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>每次修改文章后，都需要通过<code>hexo clean</code>清理一下，然后通过<code>hexo g</code>重新生成，最后也不要忘了通过<code>hexo s</code>重新启动Hexo。</p><p>打开浏览器，输入<code>localhost:4000：</code> 便可以看见博客内容</p><hr><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>将需要更换的主题下载并解压缩到<code>theme/yourThemeName</code>目录下，yourThemeName是你给主题取的名字，</p><p>可以去官网下载主题：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p>解压完成后，修改_config.yaml文件中的<code>theme</code>属性，默认是<code>landscape</code>，修改为<code>yourThemeName</code>：</p><p>比如我下载的next主题</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span>                          <span class="comment">#注意：“theme:”后要带一个空格</span></span><br></pre></td></tr></table></figure><p>最后，进行部署到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp; hexo g &amp; hexo s </span><br></pre></td></tr></table></figure><p>访问即可！</p><p>至此，Hexo部署到本地我们就完成了！</p><hr>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客写作配置栏</title>
      <link href="2020/01/01/%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/"/>
      <url>2020/01/01/%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>博客配置，可以直接复制使用，参数根据需要进行添加，详细事宜可参考：<a href="https://butterfly.js.org/posts/dc584b87/">Butterfly官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">updated: </span><br><span class="line">type: </span><br><span class="line"> - </span><br><span class="line"> - </span><br><span class="line">categories:</span><br><span class="line"> - </span><br><span class="line"> - </span><br><span class="line">tags: </span><br><span class="line"> - </span><br><span class="line"> -</span><br><span class="line">sticky: </span><br><span class="line">copyright: </span><br><span class="line">comments: </span><br><span class="line">description: </span><br><span class="line">keywords: </span><br><span class="line">top_img: </span><br><span class="line">toc_number: true</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">cover: </span><br></pre></td></tr></table></figure><hr><p>参数含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: 发表时间</span><br><span class="line">updated: 更新时间</span><br><span class="line">type: 文章类型</span><br><span class="line"> - </span><br><span class="line"> - </span><br><span class="line">categories: 文章分类</span><br><span class="line"> - </span><br><span class="line"> - </span><br><span class="line">tags: 文章标签</span><br><span class="line"> - </span><br><span class="line">toc_number: 是否显示文章标题顺序</span><br><span class="line">sticky: 置顶度，1开始，越大越往前</span><br><span class="line">comments: 是否显示评论</span><br><span class="line">description: 文章描述</span><br><span class="line">keywords: 关键字</span><br><span class="line">top_img: 文章顶部图片</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">copyright: 是否开启文章版权</span><br><span class="line">aside: 侧边栏</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">cover: 文章封面图</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tags: </span><br><span class="line"> - </span><br><span class="line">categories:</span><br><span class="line"> - </span><br><span class="line">cover: </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客选择</title>
      <link href="2020/01/01/Hexo%E5%8D%9A%E5%AE%A2/1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Hexo/"/>
      <url>2020/01/01/Hexo%E5%8D%9A%E5%AE%A2/1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么选择Hexo"><a href="#为什么选择Hexo" class="headerlink" title="为什么选择Hexo"></a>为什么选择Hexo</h1><p>目前，主流的博客主要分<code>静态博客</code>和<code>动态博客</code>两类：</p><ul><li>所谓动态，就是指有前端有后端，可以登录到后台进行管理</li><li>静态博客是纯前端的展示，没有后端</li></ul><hr><h3 id="动态博客搭建"><a href="#动态博客搭建" class="headerlink" title="动态博客搭建"></a>动态博客搭建</h3><p>a. 直接在简书、CSDN（最近吐槽的比较多）、知乎、博客园等动态博客公共平台上写</p><ul><li>优点：简单</li><li>缺点：别人家的东西限制多</li></ul><p>b. 使用 WordPress 等成熟框架搭建动态博客 + 服务器部署</p><ul><li>优点：相对简单</li><li>缺点：笨重</li></ul><p>c. 使用JavaPHP、Python等语言开发属于自己的动态博客 + 服务器部署</p><ul><li>优点：功能强大</li><li>缺点：<font color='red'>麻烦、不易上手</font></li></ul><hr><h3 id="静态博客搭建"><a href="#静态博客搭建" class="headerlink" title="静态博客搭建"></a>静态博客搭建</h3><p>a. 使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 托管在GitHub、码云等公共平台</p><ul><li>优点：轻量级、易上手、不花钱</li><li>缺点：<font color='red'>访问速度慢</font></li></ul><p>b. 使用 Hexo、Hugo、jekyll 等主流博客框架搭建静态博客 + 云端服务器部署</p><ul><li>优点：有独立的域名、访问速度快、自主可控</li><li>缺点：<font color='red'>要花钱买域名和云服务器</font></li></ul><hr><h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><p>Hexo可以理解为是基于node.js制作的一个博客工具。</p><p>它是一个<code>静态页面生成和上传的工具</code>。</p><p>Hexo在本地安装，不需要部署到我们的服务器上，我们只需要在本地通过markdown编写文章，然后让Hexo帮我们生成静态的html页面，并通过Hexo将生成的html文件上传到我们的服务器。</p><hr><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>使用Hexo搭建个人博客并自动部署到阿里云ECS服务器的原理如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://tva4.sinaimg.cn/large/007rpHi4gy1gnhknjrtzhj33341qiqar.jpg" alt="image"></p><p>简单来说就是在本地计算机搭建Hexo环境，Hexo通过generate命令将*.md文件渲染成静态的html页面，然后Hexo通过deploy命令触发git用户通过公钥免密登陆服务器，进而将静态页面推送到服务器的git仓库（repository）中。然后，服务器再通过钩子（git-hooks） 将静态页面checkout到网站的根目录下，进而实现博客的自动部署。具体过程如图中实线箭头所示。</p><p>而我们搭建在github上与此类似，利用 Vercel  解决访问速度慢的问题（代替了使用阿里云服务器）。具体后面再说</p><hr><div class="note default simple"><p>参考文章：<a href="https://blog.csdn.net/A_TangNotes/article/details/104940098">Hexo选择</a></p></div>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
